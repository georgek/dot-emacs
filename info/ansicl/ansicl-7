This is ansicl, produced by makeinfo version 4.13 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: parse-namestring,  Next: wild-pathname-p,  Prev: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Up: Filenames

parse-namestring (Function)
===========================

Syntax:
.......

 -- Function: parse-namestring thing &optional host default-pathname
          &key start end junk-allowed → pathname, position

Arguments and Values:
.....................

THING--a string, a pathname, or a stream associated with a file.

HOST--a valid pathname host, a logical host, or ‘nil’.

DEFAULT-PATHNAME--a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

START, END--bounding index designators of THING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

JUNK-ALLOWED--a generalized boolean.  The default is false.

PATHNAME--a pathname, or ‘nil’.

POSITION--a bounding index designator for THING.

Description:
............

Converts THING into a pathname.

The HOST supplies a host name with respect to which the parsing occurs.

If THING is a stream associated with a file, processing proceeds as if
the pathname used to open that file had been supplied instead.

If THING is a pathname, the HOST and the host component of THING are
compared.  If they match, two values are immediately returned: THING
and START; otherwise (if they do not match), an error is signaled.

Otherwise (if THING is a string), ‘parse-namestring’ parses the name of
a file within the substring of THING bounded by START and END.

If THING is a string then the substring of THING bounded by START and
END is parsed into a pathname as follows:

   * If HOST is a logical host then THING is parsed as a logical
     pathname namestring on the HOST.

   * If HOST is ‘nil’ and THING is a syntactically valid logical
     pathname namestring containing an explicit host, then it is parsed
     as a logical pathname namestring.

   * If  HOST is ‘nil’, DEFAULT-PATHNAME is a logical pathname, and
     THING is a syntactically valid logical pathname namestring without
     an explicit host, then it is parsed as a logical pathname
     namestring on the host that is the host component of
     DEFAULT-PATHNAME.

   * Otherwise, the parsing of THING is implementation-defined.

In the first of these cases, the host portion of the logical pathname
namestring and its following colon are optional.

If the host portion of the namestring and HOST are both present and do
not match, an error is signaled.

If JUNK-ALLOWED is true, then the primary value is the pathname parsed
or, if no syntactically correct pathname was seen, ‘nil’.  If
JUNK-ALLOWED is false, then the entire substring is scanned, and the
primary value is the pathname parsed.

In either case, the secondary value is the index into THING of the
delimiter that terminated the parse, or the index beyond the substring
if the parse terminated at the end of the substring (as will always be
the case if JUNK-ALLOWED is false).

Parsing a null string always succeeds, producing a pathname with all
components (except the host) equal to ‘nil’.

If THING contains an explicit host name and no explicit device name,
then it is implementation-defined whether ‘parse-namestring’ will
supply the standard default device for that host as the device component
of the resulting pathname.

Examples:
.........

 (setq q (parse-namestring "test"))
→ #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
       :TYPE NIL :VERSION NIL)
 (pathnamep q) → true
 (parse-namestring "test")
→ #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test"
       :TYPE NIL :VERSION NIL), 4
 (setq s (open xxx)) → #<Input File Stream...>
 (parse-namestring s)
→ #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME xxx
       :TYPE NIL :VERSION NIL), 0
 (parse-namestring "test" nil nil :start 2 :end 4 )
 → #S(PATHNAME ...), 15
 (parse-namestring "foo.lisp")
→ #P"foo.lisp"

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error of type ‘parse-error’ is signaled if
THING does not consist entirely of the representation of a pathname,
possibly surrounded on either side by whitespace₁ characters if that is
appropriate to the cultural conventions of the implementation.

If HOST is supplied and not ‘nil’, and THING contains a manifest host
name, an error of type ‘error’ is signaled if the hosts do not match.

If THING is a logical pathname namestring and if the host portion of
the namestring and HOST are both present and do not match, an error of
type ‘error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent, *note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: ansicl,  Node: wild-pathname-p,  Next: pathname-match-p,  Prev: parse-namestring,  Up: Filenames

wild-pathname-p (Function)
==========================

Syntax:
.......

 -- Function: wild-pathname-p pathname &optional field-key →
          generalized-boolean

Arguments and Values:
.....................

PATHNAME--a pathname designator.

FIELD-KEY--one of :host, :device :directory, :name, :type, :version, or
‘nil’.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘wild-pathname-p’ tests PATHNAME for the presence of wildcard
components.

If PATHNAME is a pathname (as returned by ‘pathname’) it represents the
name used to open the file. This may be, but is not required to be, the
actual name of the file.

If FIELD-KEY is not supplied or ‘nil’, ‘wild-pathname-p’ returns true
if PATHNAME has any wildcard components, ‘nil’  if PATHNAME has none.
If FIELD-KEY is non-nil, ‘wild-pathname-p’ returns true if the
indicated component of PATHNAME is a wildcard, ‘nil’ if the component
is not a wildcard.

Examples:
.........

 ;;;The following examples are not portable.  They are written to run
 ;;;with particular file systems and particular wildcard conventions.
 ;;;Other implementations will behave differently.  These examples are
 ;;;intended to be illustrative, not to be prescriptive.

 (wild-pathname-p (make-pathname :name :wild)) → true
 (wild-pathname-p (make-pathname :name :wild) :name) → true
 (wild-pathname-p (make-pathname :name :wild) :type) → false
 (wild-pathname-p (pathname "s:>foo>**>")) → true ;Lispm
 (wild-pathname-p (pathname :name "F*O")) → true ;Most places

Exceptional Situations:
.......................

If PATHNAME is not a pathname, a string, or a stream associated with a
file an error of type ‘type-error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

Not all implementations support wildcards in all fields.  See *note
Section 19.2.2.2.2 (.WILD as a Component Value): WildComponents. and
*note Section 19.2.2.3 (Restrictions on Wildcard Pathnames):
WildcardRestrictions.


File: ansicl,  Node: pathname-match-p,  Next: translate-logical-pathname,  Prev: wild-pathname-p,  Up: Filenames

pathname-match-p (Function)
===========================

Syntax:
.......

 -- Function: pathname-match-p pathname wildcard → generalized-boolean

Arguments and Values:
.....................

PATHNAME--a pathname designator.

WILDCARD--a designator for a wild pathname.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘pathname-match-p’ returns true if PATHNAME matches WILDCARD, otherwise
‘nil’.  The matching rules are implementation-defined but should be
consistent with ‘directory’. Missing components of WILDCARD default to
:wild.

It is valid for PATHNAME to be a wild pathname; a wildcard field in
PATHNAME only matches a wildcard field in WILDCARD (i.e.,
‘pathname-match-p’ is not commutative).  It is valid for WILDCARD to be
a non-wild pathname.

Exceptional Situations:
.......................

If PATHNAME or WILDCARD is not a pathname, string, or stream associated
with a file an error of type ‘type-error’ is signaled.

See Also:
.........

*note directory::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: translate-logical-pathname,  Next: translate-pathname,  Prev: pathname-match-p,  Up: Filenames

translate-logical-pathname (Function)
=====================================

Syntax:
.......

 -- Function: translate-logical-pathname pathname &key →
          physical-pathname

Arguments and Values:
.....................

PATHNAME--a pathname designator, or a logical pathname namestring.

PHYSICAL-PATHNAME--a physical pathname.

Description:
............

Translates PATHNAME to a physical pathname, which it returns.

If PATHNAME is a stream, the stream can be either open or closed.
‘translate-logical-pathname’ returns the same physical pathname after a
file is closed as it did when the file was open.  It is an error if
PATHNAME is a stream that is created with ‘make-two-way-stream’,
‘make-echo-stream’, ‘make-broadcast-stream’,
‘make-concatenated-stream’, ‘make-string-input-stream’,
‘make-string-output-stream’.

If PATHNAME is a logical pathname namestring, the host portion of the
logical pathname namestring and its following colon are required.

PATHNAME is first coerced to a pathname.  If the coerced PATHNAME is a
physical pathname, it is returned.  If the coerced PATHNAME is a
logical pathname, the first matching translation (according to
‘pathname-match-p’) of the logical pathname host is applied, as if by
calling ‘translate-pathname’.  If the result is a logical pathname,
this process is repeated.  When the result is finally a physical
pathname, it is returned.  If no translation matches, an error is
signaled.

‘translate-logical-pathname’ might perform additional translations,
typically to provide translation of file types to local naming
conventions, to accomodate physical file systems with limited length
names, or to deal with special character requirements such as
translating hyphens to underscores or uppercase letters to lowercase.
Any such additional translations are implementation-defined.  Some
implementations do no additional translations.

There are no specified keyword arguments for
‘translate-logical-pathname’, but implementations are permitted to
extend it by adding keyword arguments.

Examples:
.........

See ‘logical-pathname-translations’.

Exceptional Situations:
.......................

If PATHNAME is incorrectly supplied, an error of type ‘type-error’ is
signaled.

If no translation matches, an error of type ‘file-error’ is signaled.

See Also:
.........

*note logical-pathname (Function)::, *note
logical-pathname-translations::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: translate-pathname,  Next: merge-pathnames,  Prev: translate-logical-pathname,  Up: Filenames

translate-pathname (Function)
=============================

Syntax:
.......

 -- Function: translate-pathname source from-wildcard to-wildcard &key
          → translated-pathname

Arguments and Values:
.....................

SOURCE--a pathname designator.

FROM-WILDCARD--a pathname designator.

TO-WILDCARD--a pathname designator.

TRANSLATED-PATHNAME--a pathname.

Description:
............

‘translate-pathname’ translates SOURCE (that matches FROM-WILDCARD)
into a corresponding pathname that matches TO-WILDCARD, and returns the
corresponding pathname.

The resulting pathname is TO-WILDCARD with each wildcard or missing
field replaced by a portion of SOURCE.  A "wildcard field" is a
pathname component with a value of :wild, a :wild element of a
list-valued directory component, or an implementation-defined portion
of a component, such as the ‘"*"’ in the complex wildcard string
‘"foo*bar"’ that some implementations support.  An implementation that
adds other wildcard features, such as regular expressions, must define
how ‘translate-pathname’ extends to those features.  A "missing field"
is a pathname component with a value of ‘nil’.

The portion of SOURCE that is copied into the resulting pathname is
implementation-defined.  Typically it is determined by the user
interface conventions of the file systems involved.  Usually it is the
portion of SOURCE that matches a wildcard field of FROM-WILDCARD that
is in the same position as the wildcard or missing field of
TO-WILDCARD.  If there is no wildcard field in FROM-WILDCARD at that
position, then usually it is the entire corresponding pathname
component of SOURCE, or in the case of a list-valued directory
component, the entire corresponding list element.

During the copying of a portion of SOURCE into the resulting pathname,
additional implementation-defined translations of case or file naming
conventions might occur, especially when FROM-WILDCARD and TO-WILDCARD
are for different hosts.

It is valid for SOURCE to be a wild pathname; in general this will
produce a wild result.  It is valid for FROM-WILDCARD and/or
TO-WILDCARD to be non-wild pathnames.

There are no specified keyword arguments for ‘translate-pathname’, but
implementations are permitted to extend it by adding keyword arguments.

‘translate-pathname’ maps customary case in SOURCE into customary case
in the output pathname.

Examples:
.........

 ;; The results of the following five forms are all implementation-dependent.
 ;; The second item in particular is shown with multiple results just to
 ;; emphasize one of many particular variations which commonly occurs.
 (pathname-name (translate-pathname "foobar" "foo*" "*baz")) → "barbaz"
 (pathname-name (translate-pathname "foobar" "foo*" "*"))
→ "foobar"
or→ "bar"
 (pathname-name (translate-pathname "foobar" "*"    "foo*")) → "foofoobar"
 (pathname-name (translate-pathname "bar"    "*"    "foo*")) → "foobar"
 (pathname-name (translate-pathname "foobar" "foo*" "baz*")) → "bazbar"

 (defun translate-logical-pathname-1 (pathname rules)
   (let ((rule (assoc pathname rules :test #'pathname-match-p)))
     (unless rule (error "No translation rule for ~A" pathname))
     (translate-pathname pathname (first rule) (second rule))))
 (translate-logical-pathname-1 "FOO:CODE;BASIC.LISP"
                       '(("FOO:DOCUMENTATION;" "MY-UNIX:/doc/foo/")
                         ("FOO:CODE;"          "MY-UNIX:/lib/foo/")
                         ("FOO:PATCHES;*;"     "MY-UNIX:/lib/foo/patch/*/")))
→ #P"MY-UNIX:/lib/foo/basic.l"

;;;This example assumes one particular set of wildcard conventions
;;;Not all file systems will run this example exactly as written
 (defun rename-files (from to)
   (dolist (file (directory from))
     (rename-file file (translate-pathname file from to))))
 (rename-files "/usr/me/*.lisp" "/dev/her/*.l")
   ;Renames /usr/me/init.lisp to /dev/her/init.l
 (rename-files "/usr/me/pcl*/*" "/sys/pcl/*/")
   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/pcl/pcl-5-may/low.lisp
   ;In some file systems the result might be /sys/pcl/5-may/low.lisp
 (rename-files "/usr/me/pcl*/*" "/sys/library/*/")
   ;Renames /usr/me/pcl-5-may/low.lisp to /sys/library/pcl-5-may/low.lisp
   ;In some file systems the result might be /sys/library/5-may/low.lisp
 (rename-files "/usr/me/foo.bar" "/usr/me2/")
   ;Renames /usr/me/foo.bar to /usr/me2/foo.bar
 (rename-files "/usr/joe/*-recipes.text" "/usr/jim/cookbook/joe's-*-rec.text")
   ;Renames /usr/joe/lamb-recipes.text to /usr/jim/cookbook/joe's-lamb-rec.text
   ;Renames /usr/joe/pork-recipes.text to /usr/jim/cookbook/joe's-pork-rec.text
   ;Renames /usr/joe/veg-recipes.text to /usr/jim/cookbook/joe's-veg-rec.text

Exceptional Situations:
.......................

If any of SOURCE, FROM-WILDCARD, or TO-WILDCARD is not a pathname, a
string, or a stream associated with a file an error of type
‘type-error’ is signaled.

‘(pathname-match-p SOURCE FROM-WILDCARD)’ must be true or an error of
type ‘error’ is signaled.

See Also:
.........

*note namestring::, *note pathname-host::, *note pathname (System
Class)::, *note logical-pathname (System Class)::, *note Section 20.1
(File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

The exact behavior of ‘translate-pathname’ cannot be dictated by the
Common Lisp language and must be allowed to vary, depending on the user
interface conventions of the file systems involved.

The following is an implementation guideline.  One file system performs
this operation by examining each piece of the three pathnames in turn,
where a piece is a pathname component or a list element of a structured
component such as a hierarchical directory.  Hierarchical directory
elements in FROM-WILDCARD and TO-WILDCARD are matched by whether they
are wildcards, not by depth in the directory hierarchy.  If the piece in
TO-WILDCARD is present and not wild, it is copied into the result.  If
the piece in TO-WILDCARD is :wild or ‘nil’, the piece in SOURCE is
copied into the result.  Otherwise, the piece in TO-WILDCARD might be a
complex wildcard such as ‘"foo*bar"’ and the piece in FROM-WILDCARD
should be wild; the portion of the piece in SOURCE that matches the
wildcard portion of the piece in FROM-WILDCARD replaces the wildcard
portion of the piece in TO-WILDCARD and the value produced is used in
the result.


File: ansicl,  Node: merge-pathnames,  Prev: translate-pathname,  Up: Filenames

merge-pathnames (Function)
==========================

Syntax:
.......

 -- Function: merge-pathnames pathname &optional default-pathname
          default-version → merged-pathname

Arguments and Values:
.....................

PATHNAME--a pathname designator.

DEFAULT-PATHNAME--a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

DEFAULT-VERSION--a valid pathname version.  The default is :newest.

MERGED-PATHNAME--a pathname.

Description:
............

Constructs a pathname from PATHNAME by filling in any unsupplied
components with the corresponding values from DEFAULT-PATHNAME and
DEFAULT-VERSION.

Defaulting of pathname components is done by filling in components
taken from another pathname.  This is especially useful for cases such
as a program that has an input file and an output file.  Unspecified
components of the output pathname will come from the input pathname,
except that the type should not default to the type of the input
pathname but rather to the appropriate default type for output from the
program; for example, see the function *note compile-file-pathname::.

If no version is supplied, DEFAULT-VERSION is used.  If DEFAULT-VERSION
is ‘nil’, the version component will remain unchanged.

If PATHNAME explicitly specifies a host and not a device, and if the
host component of DEFAULT-PATHNAME matches the host component of
PATHNAME, then the device is taken from the DEFAULT-PATHNAME; otherwise
the device will be the default file device for that host.  If PATHNAME
does not specify a host, device, directory, name, or type, each such
component is copied from DEFAULT-PATHNAME.  If PATHNAME does not
specify a name, then the version, if not provided, will come from
DEFAULT-PATHNAME, just like the other components.  If PATHNAME does
specify a name, then the version is not affected by DEFAULT-PATHNAME.
If this process leaves the version missing, the DEFAULT-VERSION is used.
If the host's file name syntax provides a way to input a version
without a name or type, the user can let the name and type default but
supply a version different from the one in DEFAULT-PATHNAME.

If PATHNAME is a stream, PATHNAME effectively becomes ‘(pathname
PATHNAME)’. ‘merge-pathnames’ can be used on either an open or a closed
stream.

If PATHNAME is a pathname it represents the name used to open the file.
This may be, but is not required to be, the actual name of the file.

‘merge-pathnames’ recognizes a logical pathname namestring when
DEFAULT-PATHNAME is a logical pathname, or when the namestring begins
with the name of a defined logical host followed by a colon.  In the
first of these two cases, the host portion of the logical pathname
namestring and its following colon are optional.

‘merge-pathnames’ returns a logical pathname if and only if its first
argument is a logical pathname, or its first argument is a logical
pathname namestring with an explicit host, or its first argument does
not specify a host and the DEFAULT-PATHNAME is a logical pathname.

Pathname merging treats a relative directory specially.  If
‘(pathname-directory PATHNAME)’ is a list whose car is :relative, and
‘(pathname-directory DEFAULT-PATHNAME)’ is a list, then the merged
directory is the value of

 (append (pathname-directory DEFAULT-PATHNAME)
         (cdr  ;remove :relative from the front
           (pathname-directory PATHNAME)))

except that if the resulting list contains a string or :wild
immediately followed by :back, both of them are removed.  This removal
of redundant :back keywords is repeated as many times as possible.  If
‘(pathname-directory DEFAULT-PATHNAME)’ is not a list or
‘(pathname-directory PATHNAME)’ is not a list whose car is :relative,
the merged directory is ‘(or (pathname-directory PATHNAME)
(pathname-directory DEFAULT-PATHNAME))’

‘merge-pathnames’ maps customary case in PATHNAME into customary case
in the output pathname.

Examples:
.........

 (merge-pathnames "CMUC::FORMAT"
                  "CMUC::PS:<LISPIO>.FASL")
→ #P"CMUC::PS:<LISPIO>FORMAT.FASL.0"

See Also:
.........

*note *default-pathname-defaults*::, *note pathname (System Class)::,
*note logical-pathname (System Class)::, *note Section 20.1 (File
System Concepts): File System Concepts, *note Section 19.1.2 (Pathnames
as Filenames): Pathnames as Filenames.

Notes:
......

The net effect is that if just a name is supplied, the host, device,
directory, and type will come from DEFAULT-PATHNAME, but the version
will come from DEFAULT-VERSION.  If nothing or just a directory is
supplied, the name, type, and version will come from DEFAULT-PATHNAME
together.


File: ansicl,  Node: Files,  Next: Streams,  Prev: Filenames,  Up: Top

20 Files
********

* Menu:

* File System Concepts::

Dictionary

* directory::
* probe-file::
* ensure-directories-exist::
* truename::
* file-author::
* file-write-date::
* rename-file::
* delete-file::
* file-error::
* file-error-pathname::


File: ansicl,  Node: File System Concepts,  Next: directory,  Up: Files

20.1 File System Concepts
=========================

This section describes the Common Lisp interface to file systems.  The
model used by this interface assumes that "files" are named by "filenames",
that a filename can be represented by a pathname object, and that given
a pathname a "stream" can be constructed that connects to a file whose
filename it represents.

For information about opening and closing files, and manipulating their
contents, see *note Chapter 21 (Streams): Streams.

The next figure lists some operators that are applicable to files and
directories.

compile-file   file-length       open
delete-file    file-position     probe-file
directory      file-write-date   rename-file
file-author    load              with-open-file

Figure 20.1: File and Directory Operations

* Menu:

* Coercion of Streams to Pathnames::
* File Operations on Open and Closed Streams::
* Truenames::


File: ansicl,  Node: Coercion of Streams to Pathnames,  Next: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.1 Coercion of Streams to Pathnames
---------------------------------------

A "stream associated with a file" is either a file stream or a synonym
stream whose target is a "stream associated with a file".  Such streams
can be used as pathname designators.

Normally, when a stream associated with a file is used as a pathname
designator, it denotes the pathname used to open the file; this may be,
but is not required to be, the actual name of the file.

Some functions, such as ‘truename’ and ‘delete-file’, coerce streams to
pathnames in a different way that involves referring to the actual file
that is open, which might or might not be the file whose name was
opened originally.  Such special situations are always notated
specifically and are not the default.


File: ansicl,  Node: File Operations on Open and Closed Streams,  Next: Truenames,  Prev: Coercion of Streams to Pathnames,  Up: File System Concepts

20.1.2 File Operations on Open and Closed Streams
-------------------------------------------------

Many functions that perform file operations accept either open or
closed streams as arguments; see *note Section 21.1.3 (Stream Arguments
to Standardized Functions): Stream Arguments to Standardized Functions.

Of these, the functions in the next figure treat open and closed
streams differently.

delete-file   file-author       probe-file
directory     file-write-date   truename

Figure 20.2: File Functions that Treat Open and Closed Streams
Differently

Since treatment of open streams by the file system may vary
considerably between implementations, however, a closed stream might be
the most reliable kind of argument for some of these functions--in
particular, those in the next figure.  For example, in some file
systems, open files are written under temporary names and not renamed
until closed and/or are held invisible until closed.  In general, any
code that is intended to be portable should use such functions
carefully.

directory   probe-file   truename

Figure 20.3: File Functions where Closed Streams Might Work Best


File: ansicl,  Node: Truenames,  Prev: File Operations on Open and Closed Streams,  Up: File System Concepts

20.1.3 Truenames
----------------

Many file systems permit more than one filename to designate a
particular file.

Even where multiple names are possible, most file systems have a
convention for generating a canonical filename in such situations.
Such a canonical filename (or the pathname representing such a
filename) is called a "truename".

The truename of a file may differ from other filenames for the file
because of symbolic links, version numbers, logical device translations
in the file system, logical pathname translations within Common Lisp,
or other artifacts of the file system.

The truename for a file is often, but not necessarily, unique for each
file.  For instance, a Unix file with multiple hard links could have
several truenames.

20.1.3.1 Examples of Truenames
..............................

For example, a DEC TOPS-20 system with files ‘PS:<JOE>FOO.TXT.1’ and
‘PS:<JOE>FOO.TXT.2’ might permit the second file to be referred to as
‘PS:<JOE>FOO.TXT.0’, since the "‘.0’" notation denotes "newest" version
of several files.  In the same file system, a "logical device" "‘JOE:’"
might be taken to refer to ‘PS:<JOE>’" and so the names ‘JOE:FOO.TXT.2’
or ‘JOE:FOO.TXT.0’ might refer to ‘PS:<JOE>FOO.TXT.2’.  In all of these
cases, the truename of the file would probably be ‘PS:<JOE>FOO.TXT.2’.

If a file is a symbolic link to another file (in a file system
permitting such a thing), it is conventional for the truename to be the
canonical name of the file after any symbolic links have been followed;
that is, it is the canonical name of the file whose contents would
become available if an input stream to that file were opened.

In the case of a file still being created (that is, of an output stream
open to such a file), the exact truename of the file might not be known
until the stream is closed.  In this case, the function ‘truename’
might return different values for such a stream before and after it was
closed.  In fact, before it is closed, the name returned might not even
be a valid name in the file system--for example, while a file is being
written, it might have version :newest and might only take on a
specific numeric value later when the file is closed even in a file
system where all files have numeric versions.


File: ansicl,  Node: directory,  Next: probe-file,  Prev: File System Concepts,  Up: Files

directory (Function)
====================

Syntax:
.......

 -- Function: directory pathspec &key → pathnames

Arguments and Values:
.....................

PATHSPEC--a pathname designator, which may contain wild components.

PATHNAMES--a list of physical pathnames.

Description:
............

Determines which, if any, files that are present in the file system
have names matching PATHSPEC, and returns a fresh list of pathnames
corresponding to the truenames of those files.

An implementation may be extended to accept implementation-defined
keyword arguments to ‘directory’.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

If the attempt to obtain a directory listing is not successful, an
error of type ‘file-error’ is signaled.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note ensure-directories-exist::, *note Section 20.1 (File
System Concepts): File System Concepts, *note Section 21.1.1.1.2 (Open
and Closed Streams): File Operations on Open and Closed Streams, *note
Section 19.1.2 (Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

If the PATHSPEC is not wild, the resulting list will contain either
zero or one elements.

Common Lisp specifies "&key" in the argument list to ‘directory’ even
though no standardized keyword arguments to ‘directory’ are defined.
"‘:allow-other-keys t’" may be used in conforming programs in order to
quietly ignore any additional keywords which are passed by the program
but not supported by the implementation.


File: ansicl,  Node: probe-file,  Next: ensure-directories-exist,  Prev: directory,  Up: Files

probe-file (Function)
=====================

Syntax:
.......

 -- Function: probe-file pathspec → truename

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

TRUENAME--a physical pathname or ‘nil’.

Description:
............

‘probe-file’ tests whether a file exists.

‘probe-file’ returns false if there is no file named PATHSPEC, and
otherwise returns the truename of PATHSPEC.

If the PATHSPEC designator is an open stream, then ‘probe-file’
produces the truename of its associated file.  If PATHSPEC is a stream,
whether open or closed, it is coerced to a pathname as if by the
function ‘pathname’.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note truename::, *note open::, *note ensure-directories-exist::, *note
pathname (System Class)::, *note logical-pathname (System Class)::,
*note Section 20.1 (File System Concepts): File System Concepts, *note
Section 21.1.1.1.2 (Open and Closed Streams): File Operations on Open
and Closed Streams, *note Section 19.1.2 (Pathnames as Filenames):
Pathnames as Filenames.


File: ansicl,  Node: ensure-directories-exist,  Next: truename,  Prev: probe-file,  Up: Files

ensure-directories-exist (Function)
===================================

Syntax:
.......

 -- Function: ensure-directories-exist pathspec &key verbose →
          pathspec, created

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

VERBOSE--a generalized boolean.

CREATED--a generalized boolean.

Description:
............

Tests whether the directories containing the specified file actually
exist, and attempts to create them if they do not.

If the containing directories do not exist and if VERBOSE is true, then
the implementation is permitted (but not required) to perform output to
standard output saying what directories were created.  If the
containing directories exist, or if VERBOSE is false, this function
performs no output.

The primary value is the given pathspec so that this operation can be
straightforwardly composed with other file manipulation expressions.
The secondary value, CREATED, is true if any directories were created.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if the host, device, or
directory part of PATHSPEC is wild.

If the directory creation attempt is not successful, an error of type
‘file-error’ is signaled; if this occurs, it might be the case that
none, some, or all of the requested creations have actually occurred
within the file system.

See Also:
.........

*note probe-file::, *note open::, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: truename,  Next: file-author,  Prev: ensure-directories-exist,  Up: Files

truename (Function)
===================

Syntax:
.......

 -- Function: truename filespec → truename

Arguments and Values:
.....................

FILESPEC--a pathname designator.

TRUENAME--a physical pathname.

Description:
............

‘truename’ tries to find the file indicated by FILESPEC and returns its
truename.  If the FILESPEC designator is an open stream, its associated
file is used.  If FILESPEC is a stream, ‘truename’ can be used whether
the stream is open or closed. It is permissible for ‘truename’ to
return more specific information after the stream is closed than when
the stream was open.  If FILESPEC is a pathname it represents the name
used to open the file. This may be, but is not required to be, the
actual name of the file.

Examples:
.........

;; An example involving version numbers.  Note that the precise nature of
;; the truename is implementation-dependent while the file is still open.
 (with-open-file (stream ">vistor>test.text.newest")
   (values (pathname stream)
           (truename stream)))
→ #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"
or→ #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.newest"
or→ #P"S:>vistor>test.text.newest", #P"S:>vistor>_temp_._temp_.1"

;; In this case, the file is closed when the truename is tried, so the
;; truename information is reliable.
 (with-open-file (stream ">vistor>test.text.newest")
   (close stream)
   (values (pathname stream)
           (truename stream)))
→ #P"S:>vistor>test.text.newest", #P"S:>vistor>test.text.1"

;; An example involving TOP-20's implementation-dependent concept
;; of logical devices -- in this case, "DOC:" is shorthand for
;; "PS:<DOCUMENTATION>" ...
 (with-open-file (stream "CMUC::DOC:DUMPER.HLP")
   (values (pathname stream)
           (truename stream)))
→ #P"CMUC::DOC:DUMPER.HLP", #P"CMUC::PS:<DOCUMENTATION>DUMPER.HLP.13"

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if an appropriate file cannot
be located within the file system for the given FILESPEC, or if the
file system cannot perform the requested operation.

An error of type ‘file-error’ is signaled if PATHNAME is wild.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.

Notes:
......

‘truename’ may be used to account for any filename translations
performed by the file system.


File: ansicl,  Node: file-author,  Next: file-write-date,  Prev: truename,  Up: Files

file-author (Function)
======================

Syntax:
.......

 -- Function: file-author pathspec → author

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

AUTHOR--a string or ‘nil’.

Description:
............

Returns a string naming the author of the file specified by PATHSPEC,
or ‘nil’ if the author's name cannot be determined.

Examples:
.........

 (with-open-file (stream ">relativity>general.text")
   (file-author s))
→ "albert"

Affected By:
............

The host computer's file system.

Other users of the file named by PATHSPEC.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: file-write-date,  Next: rename-file,  Prev: file-author,  Up: Files

file-write-date (Function)
==========================

Syntax:
.......

 -- Function: file-write-date pathspec → date

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

DATE--a universal time or ‘nil’.

Description:
............

Returns a universal time representing the time at which the file
specified by PATHSPEC was last written (or created), or returns
‘nil’ if such a time cannot be determined.

Examples:
.........

 (with-open-file (s "noel.text"
                    :direction :output :if-exists :error)
   (format s "~&Dear Santa,~2%I was good this year.  ~
                Please leave lots of toys.~2%Love, Sue~
             ~2%attachments: milk, cookies~%")
   (truename s))
→ #P"CUPID:/susan/noel.text"
 (with-open-file (s "noel.text")
   (file-write-date s))
→ 2902600800

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

An error of type ‘file-error’ is signaled if PATHSPEC is wild.

An error of type ‘file-error’ is signaled if the file system cannot
perform the requested operation.

See Also:
.........

*note Section 25.1.4.2 (Universal Time): UniversalTime, *note Section
19.1.2 (Pathnames as Filenames): Pathnames as Filenames.


File: ansicl,  Node: rename-file,  Next: delete-file,  Prev: file-write-date,  Up: Files

rename-file (Function)
======================

Syntax:
.......

 -- Function: rename-file filespec new-name → defaulted-new-name,
          old-truename, new-truename

Arguments and Values:
.....................

FILESPEC--a pathname designator.

NEW-NAME--a pathname designator other than a stream.

DEFAULTED-NEW-NAME--a pathname

OLD-TRUENAME--a physical pathname.

NEW-TRUENAME--a physical pathname.

Description:
............

‘rename-file’ modifies the file system in such a way that the file
indicated by FILESPEC is renamed to DEFAULTED-NEW-NAME.

It is an error to specify a filename containing a wild component, for
FILESPEC to contain a ‘nil’ component where the file system does not
permit a ‘nil’ component, or for the result of defaulting missing
components of NEW-NAME from FILESPEC to contain a ‘nil’ component where
the file system does not permit a ‘nil’ component.

If NEW-NAME is a logical pathname, ‘rename-file’ returns a logical
pathname as its primary value.

‘rename-file’ returns three values if successful.  The primary value,
DEFAULTED-NEW-NAME, is the resulting name which is composed of NEW-NAME
with any missing components filled in by performing a ‘merge-pathnames’
operation using FILESPEC as the defaults.  The secondary value,
OLD-TRUENAME, is the truename of the file before it was renamed.  The
tertiary value, NEW-TRUENAME, is the truename of the file after it was
renamed.

If the FILESPEC designator is an open stream, then the stream itself
and the file associated with it are affected (if the file system
permits).

Examples:
.........

;; An example involving logical pathnames.
 (with-open-file (stream "sys:chemistry;lead.text"
                         :direction :output :if-exists :error)
   (princ "eureka" stream)
   (values (pathname stream) (truename stream)))
→ #P"SYS:CHEMISTRY;LEAD.TEXT.NEWEST", #P"Q:>sys>chem>lead.text.1"
 (rename-file "sys:chemistry;lead.text" "gold.text")
→ #P"SYS:CHEMISTRY;GOLD.TEXT.NEWEST",
   #P"Q:>sys>chem>lead.text.1",
   #P"Q:>sys>chem>gold.text.1"

Exceptional Situations:
.......................

If the renaming operation is not successful, an error of type
‘file-error’ is signaled.

An error of type ‘file-error’ might be signaled if FILESPEC is wild.

See Also:
.........

*note truename::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: delete-file,  Next: file-error,  Prev: rename-file,  Up: Files

delete-file (Function)
======================

Syntax:
.......

 -- Function: delete-file filespec → ‘t’

Arguments and Values:
.....................

FILESPEC--a pathname designator.

Description:
............

Deletes the file specified by FILESPEC.

If the FILESPEC designator is an open stream, then FILESPEC and the
file associated with it are affected (if the file system permits), in
which case FILESPEC might be closed immediately, and the deletion might
be immediate or delayed until FILESPEC is explicitly closed, depending
on the requirements of the file system.

It is implementation-dependent whether an attempt to delete a
nonexistent file is considered to be successful.

‘delete-file’ returns true if it succeeds, or signals an error of type
‘file-error’ if it does not.

The consequences are undefined if FILESPEC has a wild component, or if
FILESPEC has a ‘nil’ component and the file system does not permit a
‘nil’ component.

Examples:
.........

 (with-open-file (s "delete-me.text" :direction :output :if-exists :error))
→ NIL
 (setq p (probe-file "delete-me.text")) → #P"R:>fred>delete-me.text.1"
 (delete-file p) → T
 (probe-file "delete-me.text") → false
 (with-open-file (s "delete-me.text" :direction :output :if-exists :error)
   (delete-file s))
→ T
 (probe-file "delete-me.text") → false

Exceptional Situations:
.......................

If the deletion operation is not successful, an error of type
‘file-error’ is signaled.

An error of type ‘file-error’ might be signaled if FILESPEC is wild.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: file-error,  Next: file-error-pathname,  Prev: delete-file,  Up: Files

file-error (Condition Type)
===========================

Class Precedence List:
......................

‘file-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘file-error’ consists of error conditions that occur during an
attempt to open or close a file, or during some low-level transactions
with a file system.  The "offending pathname" is initialized by the
:pathname initialization argument to ‘make-condition’, and is accessed
by the function ‘file-error-pathname’.

See Also:
.........

*note file-error-pathname::, *note open::, *note probe-file::, *note
directory::, *note ensure-directories-exist::


File: ansicl,  Node: file-error-pathname,  Prev: file-error,  Up: Files

file-error-pathname (Function)
==============================

Syntax:
.......

 -- Function: file-error-pathname condition → pathspec

Arguments and Values:
.....................

CONDITION--a condition of type ‘file-error’.

PATHSPEC--a pathname designator.

Description:
............

Returns the "offending pathname" of a condition of type ‘file-error’.

Exceptional Situations:
.......................

See Also:
.........

*note file-error::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: Streams,  Next: Printer,  Prev: Files,  Up: Top

21 Streams
**********

* Menu:

* Stream Concepts::

Dictionary

* stream::
* broadcast-stream::
* concatenated-stream::
* echo-stream::
* file-stream::
* string-stream::
* synonym-stream::
* two-way-stream::
* input-stream-p; output-stream-p::
* interactive-stream-p::
* open-stream-p::
* stream-element-type::
* streamp::
* read-byte::
* write-byte::
* peek-char::
* read-char::
* read-char-no-hang::
* terpri; fresh-line::
* unread-char::
* write-char::
* read-line::
* write-string; write-line::
* read-sequence::
* write-sequence::
* file-length::
* file-position::
* file-string-length::
* open::
* stream-external-format::
* with-open-file::
* close::
* with-open-stream::
* listen::
* clear-input::
* finish-output; force-output; clear-output::
* y-or-n-p; yes-or-no-p::
* make-synonym-stream::
* synonym-stream-symbol::
* broadcast-stream-streams::
* make-broadcast-stream::
* make-two-way-stream::
* two-way-stream-input-stream; two-way-stream-output-stream::
* echo-stream-input-stream; echo-stream-output-stream::
* make-echo-stream::
* concatenated-stream-streams::
* make-concatenated-stream::
* get-output-stream-string::
* make-string-input-stream::
* make-string-output-stream::
* with-input-from-string::
* with-output-to-string::
* *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+::
* *terminal-io*::
* stream-error::
* stream-error-stream::
* end-of-file::


File: ansicl,  Node: Stream Concepts,  Next: stream,  Up: Streams

21.1 Stream Concepts
====================

* Menu:

* Introduction to Streams::
* Stream Variables::
* Stream Arguments to Standardized Functions::
* Restrictions on Composite Streams::


File: ansicl,  Node: Introduction to Streams,  Next: Stream Variables,  Up: Stream Concepts

21.1.1 Introduction to Streams
------------------------------

A "stream" is an object that can be used with an input or output
function to identify an appropriate source or sink of characters or
bytes for that operation.  A "character" "stream" is a source or sink
of characters.  A "binary" "stream" is a source or sink of bytes.

Some operations may be performed on any kind of stream; the next
figure provides a list of standardized operations that are potentially
useful with any kind of stream.

close                  stream-element-type
input-stream-p         streamp
interactive-stream-p   with-open-stream
output-stream-p        

Figure 21.1: Some General-Purpose Stream Operations

Other operations are only meaningful on certain stream types.  For
example, ‘read-char’ is only defined for character streams and
‘read-byte’ is only defined for binary streams.

21.1.1.1 Abstract Classifications of Streams
............................................

21.1.1.1.1 Input, Output, and Bidirectional Streams
...................................................

A stream, whether a character stream or a binary stream, can be an "input" "stream"
(source of data), an "output" "stream" (sink for data), both, or (e.g.,
when "‘:direction :probe’" is given to ‘open’) neither.

The next figure shows operators relating to input streams.

clear-input   read-byte             read-from-string
listen        read-char             read-line
peek-char     read-char-no-hang     read-preserving-whitespace
read          read-delimited-list   unread-char

Figure 21.2: Operators relating to Input Streams.

The next figure shows operators relating to output streams.

clear-output    prin1             write
finish-output   prin1-to-string   write-byte
force-output    princ             write-char
format          princ-to-string   write-line
fresh-line      print             write-string
pprint          terpri            write-to-string

Figure 21.3: Operators relating to Output Streams.

A stream that is both an input stream and an output stream is called a "bidirectional" "stream".
See the functions *note input-stream-p:: and ‘output-stream-p’.

Any of the operators listed in *note Figure 21.2: InputStreamOps. or
*note Figure 21.3: OutputStreamOps.  can be used with bidirectional
streams.  In addition, the next figure shows a list of operators that
relate specificaly to bidirectional streams.

y-or-n-p   yes-or-no-p   

Figure 21.4: Operators relating to Bidirectional Streams.

21.1.1.1.2 Open and Closed Streams
..................................

Streams are either "open" or "closed".

Except as explicitly specified otherwise, operations that create and
return streams return open streams.

The action of closing a stream marks the end of its use as a source or
sink of data, permitting the implementation to reclaim its internal data
structures, and to free any external resources which might have been
locked by the stream when it was opened.

Except as explicitly specified otherwise, the consequences are
undefined when a closed stream is used where a stream is called for.

Coercion of streams to pathnames is permissible for closed streams; in
some situations, such as for a truename computation, the result might
be different for an open stream and for that same stream once it has
been closed.

21.1.1.1.3 Interactive Streams
..............................

An "interactive stream" is one on which it makes sense to perform
interactive querying.

The precise meaning of an interactive stream is implementation-defined,
and may depend on the underlying operating system.  Some examples of
the things that an implementation might choose to use as identifying
characteristics of an interactive stream include:

   * The stream is connected to a person (or equivalent) in such a way
     that the program can prompt for information and expect to receive
     different input depending on the prompt.

   * The program is expected to prompt for input and support "normal
     input editing".

   * ‘read-char’ might wait for the user to type something before
     returning instead of immediately returning a character or
     end-of-file.

The general intent of having some streams be classified as interactive
streams is to allow them to be distinguished from streams containing
batch (or background or command-file) input.  Output to batch streams
is typically discarded or saved for later viewing, so interactive
queries to such streams might not have the expected effect.

Terminal I/O might or might not be an interactive stream.

21.1.1.2 Abstract Classifications of Streams
............................................

21.1.1.2.4 File Streams
.......................

Some streams, called "file streams", provide access to files.  An
object of class ‘file-stream’ is used to represent a file stream.

The basic operation for opening a file is ‘open’, which typically
returns a file stream (see its dictionary entry for details).  The
basic operation for closing a stream is ‘close’.  The macro
‘with-open-file’ is useful to express the common idiom of opening a file
for the duration of a given body of code, and assuring that the
resulting stream is closed upon exit from that body.

21.1.1.3 Other Subclasses of Stream
...................................

The class ‘stream’ has a number of subclasses defined by this
specification.  The next figure shows some information about these
subclasses.

Class                   Related Operators
--------------------------------------------------------- 
‘broadcast-stream’      ‘make-broadcast-stream’
                        ‘broadcast-stream-streams’
‘concatenated-stream’   ‘make-concatenated-stream’
                        ‘concatenated-stream-streams’
‘echo-stream’           ‘make-echo-stream’
                        ‘echo-stream-input-stream’
                        ‘echo-stream-output-stream’
‘string-stream’         ‘make-string-input-stream’
                        ‘with-input-from-string’
                        ‘make-string-output-stream’
                        ‘with-output-to-string’
                        ‘get-output-stream-string’
‘synonym-stream’        ‘make-synonym-stream’
                        ‘synonym-stream-symbol’
‘two-way-stream’        ‘make-two-way-stream’
                        ‘two-way-stream-input-stream’
                        ‘two-way-stream-output-stream’

Figure 21.5: Defined Names related to Specialized Streams


File: ansicl,  Node: Stream Variables,  Next: Stream Arguments to Standardized Functions,  Prev: Introduction to Streams,  Up: Stream Concepts

21.1.2 Stream Variables
-----------------------

Variables whose values must be streams are sometimes called "stream
variables".

Certain stream variables are defined by this specification to be the
proper source of input or output in various situations where no
specific stream has been specified instead.  A complete list of such
standardized stream variables appears in the next figure.  The
consequences are undefined if at any time the value of any of these
variables is not an open stream.

Glossary Term     Variable Name
---------------------------------------- 
debug I/O         ‘*debug-io*’
error output      ‘*error-output*’
query I/O         ‘*query-io*’
standard input    ‘*standard-input*’
standard output   ‘*standard-output*’
terminal I/O      ‘*terminal-io*’
trace output      ‘*trace-output*’

Figure 21.6: Standardized Stream Variables

Note that, by convention, standardized stream variables have names
ending in "‘-input*’"  if they must be input streams, ending in
"‘-output*’" if they must be output streams, or ending in "‘-io*’"
if they must be bidirectional streams.

User programs may assign or bind any standardized stream variable
except ‘*terminal-io*’.


File: ansicl,  Node: Stream Arguments to Standardized Functions,  Next: Restrictions on Composite Streams,  Prev: Stream Variables,  Up: Stream Concepts

21.1.3 Stream Arguments to Standardized Functions
-------------------------------------------------

The operators in the next figure accept stream arguments that might be
either open or closed streams.

broadcast-stream-streams      file-author        pathnamep
close                         file-namestring    probe-file
compile-file                  file-write-date    rename-file
compile-file-pathname         host-namestring    streamp
concatenated-stream-streams   load               synonym-stream-symbol
delete-file                   logical-pathname   translate-logical-pathname
directory                     merge-pathnames    translate-pathname
directory-namestring          namestring         truename
dribble                       open               two-way-stream-input-stream
echo-stream-input-stream      open-stream-p      two-way-stream-output-stream
echo-stream-ouput-stream      parse-namestring   wild-pathname-p
ed                            pathname           with-open-file
enough-namestring             pathname-match-p   

Figure 21.7: Operators that accept either Open or Closed Streams

The operators in the next figure accept stream arguments that must be
open streams.

clear-input                output-stream-p           read-char-no-hang
clear-output               peek-char                 read-delimited-list
file-length                pprint                    read-line
file-position              pprint-fill               read-preserving-whitespace
file-string-length         pprint-indent             stream-element-type
finish-output              pprint-linear             stream-external-format
force-output               pprint-logical-block      terpri
format                     pprint-newline            unread-char
fresh-line                 pprint-tab                with-open-stream
get-output-stream-string   pprint-tabular            write
input-stream-p             prin1                     write-byte
interactive-stream-p       princ                     write-char
listen                     print                     write-line
make-broadcast-stream      print-object              write-string
make-concatenated-stream   print-unreadable-object   y-or-n-p
make-echo-stream           read                      yes-or-no-p
make-synonym-stream        read-byte                 
make-two-way-stream        read-char                 

Figure 21.8: Operators that accept Open Streams only


File: ansicl,  Node: Restrictions on Composite Streams,  Prev: Stream Arguments to Standardized Functions,  Up: Stream Concepts

21.1.4 Restrictions on Composite Streams
----------------------------------------

The consequences are undefined if any component of a composite stream
is closed before the composite stream is closed.

The consequences are undefined if the synonym stream symbol is not bound
to an open stream from the time of the synonym stream's creation until
the time it is closed.


File: ansicl,  Node: stream,  Next: broadcast-stream,  Prev: Stream Concepts,  Up: Streams

stream (System Class)
=====================

Class Precedence List:
......................

‘stream’, ‘t’

Description:
............

A stream is an object that can be used with an input or output function
to identify an appropriate source or sink of characters or bytes for
that operation.

For more complete information, see *note Section 21.1 (Stream
Concepts): Stream Concepts.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts, *note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *note Chapter
22 (Printer): Printer, *note Chapter 23 (Reader): Reader.


File: ansicl,  Node: broadcast-stream,  Next: concatenated-stream,  Prev: stream,  Up: Streams

broadcast-stream (System Class)
===============================

Class Precedence List:
......................

‘broadcast-stream’, ‘stream’, ‘t’

Description:
............

A broadcast stream is an output stream which has associated with it a
set of zero or more output streams such that any output sent to the
broadcast stream gets passed on as output to each of the associated
output streams.  (If a broadcast stream has no component streams, then
all output to the broadcast stream is discarded.)

The set of operations that may be performed on a broadcast stream is
the intersection of those for its associated output streams.

Some output operations (e.g., ‘fresh-line’) return values based on the
state of the stream at the time of the operation.  Since these values
might differ for each of the component streams, it is necessary to
describe their return value specifically:

   * ‘stream-element-type’ returns the value from the last component
     stream, or ‘t’ if there are no component streams.

   * ‘fresh-line’ returns the value from the last component stream, or
     ‘nil’ if there are no component streams.

   * The functions ‘file-length’, ‘file-position’, ‘file-string-length’,
     and ‘stream-external-format’ return the value from the last
     component stream; if there are no component streams, ‘file-length’
     and ‘file-position’ return ‘0’, ‘file-string-length’ returns ‘1’,
     and ‘stream-external-format’ returns :default.

   * The functions ‘streamp’ and ‘output-stream-p’ always return true
     for broadcast streams.

   * The functions ‘open-stream-p’ tests whether the broadcast stream
     is open₂, not whether its component streams are open.

   * The functions ‘input-stream-p’ and interactive-stream-p return an
     implementation-defined, generalized boolean value.

   * For the input operations ‘clear-input’ ‘listen’, ‘peek-char’,
     ‘read-byte’, ‘read-char-no-hang’, ‘read-char’, ‘read-line’, and
     ‘unread-char’, the consequences are undefined if the indicated
     operation is performed.  However, an implementation is permitted
     to define such a behavior as an implementation-dependent extension.

For any output operations not having their return values explicitly
specified above or elsewhere in this document, it is defined that the
values returned by such an operation are the values resulting from
performing the operation on the last of its component streams; the
values resulting from performing the operation on all preceding streams
are discarded.  If there are no component streams, the value is
implementation-dependent.

See Also:
.........

*note broadcast-stream-streams::, *note make-broadcast-stream::


File: ansicl,  Node: concatenated-stream,  Next: echo-stream,  Prev: broadcast-stream,  Up: Streams

concatenated-stream (System Class)
==================================

Class Precedence List:
......................

‘concatenated-stream’, ‘stream’, ‘t’

Description:
............

A concatenated stream is an input stream which is a composite stream of
zero or more other input streams, such that the sequence of data which
can be read from the concatenated stream is the same as the
concatenation of the sequences of data which could be read from each of
the constituent streams.

Input from a concatenated stream is taken from the first of the
associated input streams until it reaches end of file₁; then that
stream is discarded, and subsequent input is taken from the next input
stream, and so on.  An end of file on the associated input streams is
always managed invisibly by the concatenated stream--the only time a
client of a concatenated stream sees an end of file is when an attempt
is made to obtain data from the concatenated stream but it has no
remaining input streams from which to obtain such data.

See Also:
.........

*note concatenated-stream-streams::, *note make-concatenated-stream::


File: ansicl,  Node: echo-stream,  Next: file-stream,  Prev: concatenated-stream,  Up: Streams

echo-stream (System Class)
==========================

Class Precedence List:
......................

‘echo-stream’, ‘stream’, ‘t’

Description:
............

An echo stream is a bidirectional stream that gets  its input  from an
associated input  stream and  sends its output to   an associated
output stream.

All input taken from the input stream is echoed to the output stream.
Whether the input is echoed immediately after it is encountered, or
after it has been read from the input stream is
implementation-dependent.

See Also:
.........

*note echo-stream-input-stream::, *note echo-stream-output-stream::,
*note make-echo-stream::


File: ansicl,  Node: file-stream,  Next: string-stream,  Prev: echo-stream,  Up: Streams

file-stream (System Class)
==========================

Class Precedence List:
......................

‘file-stream’, ‘stream’, ‘t’

Description:
............

An object of type ‘file-stream’ is a stream the direct source or sink
of which is a file.  Such a stream is created explicitly by ‘open’ and
‘with-open-file’, and implicitly by functions such as ‘load’ that
process files.

See Also:
.........

*note load::, *note open::, *note with-open-file::


File: ansicl,  Node: string-stream,  Next: synonym-stream,  Prev: file-stream,  Up: Streams

string-stream (System Class)
============================

Class Precedence List:
......................

‘string-stream’, ‘stream’, ‘t’

Description:
............

A string stream is a stream which reads input from or writes output to
an associated string.

The stream element type of a string stream is always a subtype of type
‘character’.

See Also:
.........

*note make-string-input-stream::, *note make-string-output-stream::,
*note with-input-from-string::, *note with-output-to-string::


File: ansicl,  Node: synonym-stream,  Next: two-way-stream,  Prev: string-stream,  Up: Streams

synonym-stream (System Class)
=============================

Class Precedence List:
......................

‘synonym-stream’, ‘stream’, ‘t’

Description:
............

A stream that is an alias for another stream, which is the value of a
dynamic variable whose name is the synonym stream symbol of the synonym
stream.

Any operations on a synonym stream will be performed on the stream that
is then the value of the dynamic variable named by the synonym stream
symbol.  If the value of the variable should change, or if the variable
should be bound, then the stream will operate on the new value of the
variable.

See Also:
.........

*note make-synonym-stream::, *note synonym-stream-symbol::


File: ansicl,  Node: two-way-stream,  Next: input-stream-p; output-stream-p,  Prev: synonym-stream,  Up: Streams

two-way-stream (System Class)
=============================

Class Precedence List:
......................

‘two-way-stream’, ‘stream’, ‘t’

Description:
............

A bidirectional composite stream that receives its input  from an
associated input  stream and sends    its output to   an associated
output stream.

See Also:
.........

*note make-two-way-stream::, *note two-way-stream-input-stream::, *note
two-way-stream-output-stream::


File: ansicl,  Node: input-stream-p; output-stream-p,  Next: interactive-stream-p,  Prev: two-way-stream,  Up: Streams

input-stream-p, output-stream-p (Function)
==========================================

Syntax:
.......

 -- Function: input-stream-p stream → generalized-boolean

 -- Function: output-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘input-stream-p’ returns true if STREAM is an input stream; otherwise,
returns false.

‘output-stream-p’ returns true if STREAM is an output stream;
otherwise, returns false.

Examples:
.........

 (input-stream-p *standard-input*) → true
 (input-stream-p *terminal-io*) → true
 (input-stream-p (make-string-output-stream)) → false

 (output-stream-p *standard-output*) → true
 (output-stream-p *terminal-io*) → true
 (output-stream-p (make-string-input-stream "jr")) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: interactive-stream-p,  Next: open-stream-p,  Prev: input-stream-p; output-stream-p,  Up: Streams

interactive-stream-p (Function)
===============================

Syntax:
.......

 -- Function: interactive-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if STREAM is an interactive stream; otherwise, returns
false.

Examples:
.........

 (when (> measured limit)
   (let ((error (round (* (- measured limit) 100)
                       limit)))
     (unless (if (interactive-stream-p *query-io*)
                 (yes-or-no-p "The frammis is out of tolerance by ~D%.~@
                               Is it safe to proceed? " error)
                 (< error 15))  ;15% is acceptable
       (error "The frammis is out of tolerance by ~D%." error))))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts.


File: ansicl,  Node: open-stream-p,  Next: stream-element-type,  Prev: interactive-stream-p,  Up: Streams

open-stream-p (Function)
========================

Syntax:
.......

 -- Function: open-stream-p stream → generalized-boolean

Arguments and Values:
.....................

STREAM--a stream.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if STREAM is an open stream; otherwise, returns false.

Streams are open until they have been explicitly closed with ‘close’,
or until they are implicitly closed due to exit from a
‘with-output-to-string’, ‘with-open-file’, ‘with-input-from-string’,  or
‘with-open-stream’ form.

Examples:
.........

 (open-stream-p *standard-input*) → true

Affected By:
............

‘close’.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: stream-element-type,  Next: streamp,  Prev: open-stream-p,  Up: Streams

stream-element-type (Function)
==============================

Syntax:
.......

 -- Function: stream-element-type stream → typespec

Arguments and Values:
.....................

STREAM--a stream.

TYPESPEC--a type specifier.

Description:
............

‘stream-element-type’ returns a type specifier that indicates the types
of objects that may be read from or written to STREAM.

Streams created by ‘open’ have an element type restricted to ‘integer’
or a subtype of type ‘character’.

Examples:
.........

;; Note that the stream must accomodate at least the specified type,
;; but might accomodate other types.  Further note that even if it does
;; accomodate exactly the specified type, the type might be specified in
;; any of several ways.
 (with-open-file (s "test" :element-type '(integer 0 1)
                           :if-exists :error
                           :direction :output)
   (stream-element-type s))
→ INTEGER
or→ (UNSIGNED-BYTE 16)
or→ (UNSIGNED-BYTE 8)
or→ BIT
or→ (UNSIGNED-BYTE 1)
or→ (INTEGER 0 1)
or→ (INTEGER 0 (2))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.


File: ansicl,  Node: streamp,  Next: read-byte,  Prev: stream-element-type,  Up: Streams

streamp (Function)
==================

Syntax:
.......

 -- Function: streamp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘stream’; otherwise, returns false.

‘streamp’ is unaffected by whether OBJECT, if it is a stream, is open
or closed.

Examples:
.........

 (streamp *terminal-io*) → true
 (streamp 1) → false

Notes:
......

 (streamp OBJECT) ≡ (typep OBJECT 'stream)


File: ansicl,  Node: read-byte,  Next: write-byte,  Prev: streamp,  Up: Streams

read-byte (Function)
====================

Syntax:
.......

 -- Function: read-byte stream &optional eof-error-p eof-value → byte

Arguments and Values:
.....................

STREAM--a binary input stream.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ‘nil’.

BYTE--an integer, or the EOF-VALUE.

Description:
............

‘read-byte’ reads and returns one byte from STREAM.

If an end of file₂ occurs and EOF-ERROR-P is false, the EOF-VALUE is
returned.

Examples:
.........

 (with-open-file (s "temp-bytes"
                     :direction :output
                     :element-type 'unsigned-byte)
    (write-byte 101 s)) → 101
 (with-open-file (s "temp-bytes" :element-type 'unsigned-byte)
    (format t "~S ~S" (read-byte s) (read-byte s nil 'eof)))
▷ 101 EOF
→ NIL

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.

Should signal an error of type ‘error’ if STREAM is not  a binary input
stream.

If there are no bytes remaining in the STREAM and EOF-ERROR-P is true,
an error of type ‘end-of-file’ is signaled.

See Also:
.........

*note read-char::, *note read-sequence::, *note write-byte::


File: ansicl,  Node: write-byte,  Next: peek-char,  Prev: read-byte,  Up: Streams

write-byte (Function)
=====================

Syntax:
.......

 -- Function: write-byte byte stream → byte

Arguments and Values:
.....................

BYTE--an integer of the stream element type of stream.

STREAM--a binary output stream.

Description:
............

‘write-byte’ writes one byte, BYTE, to STREAM.

Examples:
.........

 (with-open-file (s "temp-bytes"
                    :direction :output
                    :element-type 'unsigned-byte)
    (write-byte 101 s)) → 101

Side Effects:
.............

STREAM is modified.

Affected By:
............

The element type of the STREAM.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream.
Should signal an error of type ‘error’ if STREAM is not  a binary
output stream.

Might signal an error of type ‘type-error’ if BYTE is not an integer of
the stream element type of stream.

See Also:
.........

*note read-byte::, *note write-char::, *note write-sequence::


File: ansicl,  Node: peek-char,  Next: read-char,  Prev: write-byte,  Up: Streams

peek-char (Function)
====================

Syntax:
.......

 -- Function: peek-char &optional peek-type input-stream eof-error-p
          eof-value recursive-p → char

Arguments and Values:
.....................

PEEK-TYPE--a character or ‘t’ or ‘nil’.

INPUT-STREAM--input stream designator.  The default is standard input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ‘nil’.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or the EOF-VALUE.

Description:
............

‘peek-char’ obtains the next character in INPUT-STREAM without actually
reading it, thus leaving the character to be read at a later time.  It
can also be used to skip over and discard intervening characters in the
INPUT-STREAM until a particular character is found.

If PEEK-TYPE is not supplied or ‘nil’, ‘peek-char’ returns the next
character to be read from INPUT-STREAM, without actually removing it
from INPUT-STREAM.  The next time input is done from INPUT-STREAM, the
character will still be there.  If PEEK-TYPE is ‘t’, then ‘peek-char’
skips over whitespace₂ characters, but not comments, and then performs
the peeking operation on the next character.  The last character
examined, the one that starts an object, is not removed from
INPUT-STREAM.  If PEEK-TYPE is a character, then ‘peek-char’ skips over
input characters until a character that is ‘char=’ to that character is
found; that character is left in INPUT-STREAM.

If an end of file₂ occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

When INPUT-STREAM is an echo stream, characters that are only peeked at
are not echoed. In the case that PEEK-TYPE is not ‘nil’, the characters
that are passed by ‘peek-char’ are treated as if by ‘read-char’, and so
are echoed unless they have been marked otherwise by ‘unread-char’.

Examples:
.........

 (with-input-from-string (input-stream "    1 2 3 4 5")
    (format t "~S ~S ~S"
            (peek-char t input-stream)
            (peek-char #\4 input-stream)
            (peek-char nil input-stream)))
▷ #\1 #\4 #\4
→ NIL

Affected By:
............

‘*readtable*’, ‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If EOF-ERROR-P is true and an end of file₂ occurs an error of type
‘end-of-file’ is signaled.

If     PEEK-TYPE is a character, an end of file₂ occurs, and
EOF-ERROR-P is true, an error of type ‘end-of-file’ is signaled.

If RECURSIVE-P is true and an end of file₂ occurs, an error of type
‘end-of-file’ is signaled.


File: ansicl,  Node: read-char,  Next: read-char-no-hang,  Prev: peek-char,  Up: Streams

read-char (Function)
====================

Syntax:
.......

 -- Function: read-char &optional input-stream eof-error-p eof-value
          recursive-p → char

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ‘nil’.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or the EOF-VALUE.

Description:
............

‘read-char’ returns the next character from INPUT-STREAM.

When INPUT-STREAM is an ECHO STREAM, the character is echoed on
INPUT-STREAM the first time the character is seen.  Characters that are
not echoed by ‘read-char’ are those that were put there by ‘unread-char’
and hence are assumed to have been echoed already by a previous call to
‘read-char’.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

If an end of file₂ occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

Examples:
.........

 (with-input-from-string (is "0123")
    (do ((c (read-char is) (read-char is nil 'the-end)))
        ((not (characterp c)))
     (format t "~S " c)))
▷ #\0 #\1 #\2 #\3
→ NIL

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of file₂ occurs before a character can be read, and
EOF-ERROR-P is true, an error of type ‘end-of-file’ is signaled.

See Also:
.........

*note read-byte::, *note read-sequence::, *note write-char::, *note
read::

Notes:
......

The corresponding output function is ‘write-char’.


File: ansicl,  Node: read-char-no-hang,  Next: terpri; fresh-line,  Prev: read-char,  Up: Streams

read-char-no-hang (Function)
============================

Syntax:
.......

 -- Function: read-char-no-hang &optional input-stream eof-error-p
          eof-value recursive-p → char

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ‘nil’.

RECURSIVE-P--a generalized boolean.  The default is false.

CHAR--a character or ‘nil’ or the EOF-VALUE.

Description:
............

‘read-char-no-hang’ returns a character from INPUT-STREAM if such a
character is available.  If no character is available,
‘read-char-no-hang’ returns ‘nil’.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

If an end of file₂ occurs and EOF-ERROR-P is false, EOF-VALUE is
returned.

Examples:
.........

;; This code assumes an implementation in which a newline is not
;; required to terminate input from the console.
 (defun test-it ()
   (unread-char (read-char))
   (list (read-char-no-hang)
         (read-char-no-hang)
         (read-char-no-hang)))
→ TEST-IT
;; Implementation A, where a Newline is not required to terminate
;; interactive input on the console.
 (test-it)
▷ a
→ (#\a NIL NIL)
;; Implementation B, where a Newline is required to terminate
;; interactive input on the console, and where that Newline remains
;; on the input stream.
 (test-it)
▷ a↩
→ (#\a #\Newline NIL)

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of file₂ occurs when EOF-ERROR-P is true, an error of type
‘end-of-file’ is signaled .

See Also:
.........

*note listen::

Notes:
......

‘read-char-no-hang’ is exactly like ‘read-char’, except that if it
would be necessary to wait in order to get a character (as from a
keyboard), ‘nil’ is immediately returned without waiting.


File: ansicl,  Node: terpri; fresh-line,  Next: unread-char,  Prev: read-char-no-hang,  Up: Streams

terpri, fresh-line (Function)
=============================

Syntax:
.......

 -- Function: terpri &optional output-stream → ‘nil’

 -- Function: fresh-line &optional output-stream → generalized-boolean

Arguments and Values:
.....................

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘terpri’ outputs a newline to OUTPUT-STREAM.

‘fresh-line’ is similar to ‘terpri’ but outputs a newline only if the
OUTPUT-STREAM is not already at the start of a line.  If for some
reason this cannot be determined, then a newline is output anyway.
‘fresh-line’ returns true if it outputs a newline; otherwise it returns
false.

Examples:
.........

 (with-output-to-string (s)
    (write-string "some text" s)
    (terpri s)
    (terpri s)
    (write-string "more text" s))
→ "some text

more text"
 (with-output-to-string (s)
    (write-string "some text" s)
    (fresh-line s)
    (fresh-line s)
    (write-string "more text" s))
→ "some text
more text"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

None.

Notes:
......

‘terpri’ is identical in effect to

 (write-char #\Newline output-stream)


File: ansicl,  Node: unread-char,  Next: write-char,  Prev: terpri; fresh-line,  Up: Streams

unread-char (Function)
======================

Syntax:
.......

 -- Function: unread-char character &optional input-stream → ‘nil’

Arguments and Values:
.....................

CHARACTER--a character; must be the last character that was read from
INPUT-STREAM.

INPUT-STREAM--an input stream designator.  The default is standard
input.

Description:
............

‘unread-char’ places CHARACTER back onto the front of INPUT-STREAM so
that it will again be the next character in INPUT-STREAM.

When INPUT-STREAM is an echo stream, no attempt is made to undo any
echoing of the character that might already have been done on
INPUT-STREAM. However, characters placed on INPUT-STREAM by
‘unread-char’ are marked in such a way as to inhibit later re-echo by
‘read-char’.

It is an error to invoke ‘unread-char’ twice consecutively on the same
stream without an intervening call to ‘read-char’ (or some other input
operation which implicitly reads characters) on that stream.

Invoking ‘peek-char’ or ‘read-char’ commits all previous characters.
The consequences of invoking ‘unread-char’ on any character preceding
that which is returned by ‘peek-char’ (including those passed over by
‘peek-char’ that has a non-nil PEEK-TYPE) are unspecified.  In
particular, the consequences of invoking ‘unread-char’ after ‘peek-char’
are unspecified.

Examples:
.........

 (with-input-from-string (is "0123")
    (dotimes (i 6)
      (let ((c (read-char is)))
        (if (evenp i) (format t "~&~S ~S~%" i c) (unread-char c is)))))
▷ 0 #\0
▷ 2 #\1
▷ 4 #\2
→ NIL

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

See Also:
.........

*note peek-char::, *note read-char::, *note Section 21.1 (Stream
Concepts): Stream Concepts.

Notes:
......

‘unread-char’ is intended to be an efficient mechanism for allowing the
Lisp reader and other parsers to perform one-character lookahead in
INPUT-STREAM.


File: ansicl,  Node: write-char,  Next: read-line,  Prev: unread-char,  Up: Streams

write-char (Function)
=====================

Syntax:
.......

 -- Function: write-char character &optional output-stream → character

Arguments and Values:
.....................

CHARACTER--a character.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

Description:
............

‘write-char’ outputs CHARACTER to OUTPUT-STREAM.

Examples:
.........

 (write-char #\a)
▷ a
→ #\a
 (with-output-to-string (s)
   (write-char #\a s)
   (write-char #\Space s)
   (write-char #\b s))
→ "a b"

Side Effects:
.............

The OUTPUT-STREAM is modified.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

See Also:
.........

*note read-char::, *note write-byte::, *note write-sequence::


File: ansicl,  Node: read-line,  Next: write-string; write-line,  Prev: write-char,  Up: Streams

read-line (Function)
====================

Syntax:
.......

 -- Function: read-line &optional input-stream eof-error-p eof-value
          recursive-p → line, missing-newline-p

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

EOF-ERROR-P--a generalized boolean.  The default is true.

EOF-VALUE--an object.  The default is ‘nil’.

RECURSIVE-P--a generalized boolean.  The default is false.

LINE--a string or the EOF-VALUE.

MISSING-NEWLINE-P--a generalized boolean.

Description:
............

Reads from INPUT-STREAM a line of text that is terminated by a newline
or end of file.

If RECURSIVE-P is true, this call is expected to be embedded in a
higher-level call to ‘read’ or a similar function used by the Lisp
reader.

The primary value, LINE, is the line that is read, represented as a
string (without the trailing newline, if any).  If  EOF-ERROR-P is false
and the end of file for INPUT-STREAM is reached before any characters
are read, EOF-VALUE is returned as the LINE.

The secondary value, MISSING-NEWLINE-P, is a generalized boolean that is
false if the LINE was terminated by a newline, or true  if the LINE was
terminated by the end of file for INPUT-STREAM (or if the LINE is the
EOF-VALUE).

Examples:
.........

 (setq a "line 1
 line2")
→ "line 1
 line2"
 (read-line (setq input-stream (make-string-input-stream a)))
→ "line 1", false
 (read-line input-stream)
→ "line2", true
 (read-line input-stream nil nil)
→ NIL, true

Affected By:
............

‘*standard-input*’, ‘*terminal-io*’.

Exceptional Situations:
.......................

If an end of file₂ occurs before any characters are read in the line,
an error is signaled if EOF-ERROR-P is true.

See Also:
.........

*note read::

Notes:
......

The corresponding output function is ‘write-line’.


File: ansicl,  Node: write-string; write-line,  Next: read-sequence,  Prev: read-line,  Up: Streams

write-string, write-line (Function)
===================================

Syntax:
.......

 -- Function: write-string string &optional output-stream &key start
          end → string

 -- Function: write-line string &optional output-stream &key start end
          → string

Arguments and Values:
.....................

STRING--a string.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

START, END--bounding index designators of STRING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

Description:
............

‘write-string’ writes the characters of the subsequence of STRING
bounded by START and END to OUTPUT-STREAM.  ‘write-line’ does the same
thing, but then outputs a newline afterwards.

Examples:
.........

 (prog1 (write-string "books" nil :end 4) (write-string "worms"))
▷ bookworms
→ "books"
 (progn (write-char #\*)
        (write-line "test12" *standard-output* :end 5)
        (write-line "*test2")
        (write-char #\*)
        nil)
▷ *test1
▷ *test2
▷ *
→ NIL

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’.

See Also:
.........

*note read-line::, *note write-char::

Notes:
......

‘write-line’ and ‘write-string’ return STRING, not the substring
bounded by START and END.

 (write-string string)
≡ (dotimes (i (length string)
      (write-char (char string i)))

 (write-line string)
≡ (prog1 (write-string string) (terpri))


File: ansicl,  Node: read-sequence,  Next: write-sequence,  Prev: write-string; write-line,  Up: Streams

read-sequence (Function)
========================

Syntax:
.......

 -- Function: read-sequence sequence stream &key start end → position

SEQUENCE--a sequence.

STREAM--an input stream.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

POSITION--an integer greater than or equal to zero, and less than or
equal to the length of the SEQUENCE.

Description:
............

Destructively modifies SEQUENCE by replacing the elements of SEQUENCE
bounded by START and END with elements read from STREAM.

SEQUENCE is destructively modified by copying successive elements into
it from STREAM.  If the end of file for STREAM is reached before
copying all elements of the subsequence, then the extra elements near
the end of SEQUENCE are not updated.

POSITION is the index of the first element of SEQUENCE that was not
updated, which might be less than END because the end of file was
reached.

Examples:
.........

 (defvar *data* (make-array 15 :initial-element nil))
 (values (read-sequence *data* (make-string-input-stream "test string")) *data*)
 → 11, #(#\t #\e #\s #\t #\Space #\s #\t #\r #\i #\n #\g NIL NIL NIL NIL)

Side Effects:
.............

Modifies STREAM and SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

Might signal an error of type ‘type-error’ if an element read from the
STREAM is not a member of the element type of the SEQUENCE.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
write-sequence::, *note read-line::

Notes:
......

‘read-sequence’ is identical in effect to iterating over the indicated
subsequence and reading one element at a time from STREAM and storing
it into SEQUENCE, but may be more efficient than the equivalent loop.
An efficient implementation is more likely to exist for the case where
the SEQUENCE is a vector with the same element type as the STREAM.


File: ansicl,  Node: write-sequence,  Next: file-length,  Prev: read-sequence,  Up: Streams

write-sequence (Function)
=========================

Syntax:
.......

 -- Function: write-sequence sequence stream &key start end → sequence

SEQUENCE--a sequence.

STREAM--an output stream.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

Description:
............

‘write-sequence’ writes the elements of the subsequence of SEQUENCE
bounded by START and END to STREAM.

Examples:
.........

 (write-sequence "bookworms" *standard-output* :end 4)
 ▷ book
 → "bookworms"

Side Effects:
.............

Modifies STREAM.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

Might signal an error of type ‘type-error’ if an element of the bounded
sequence is not a member of the stream element type of the STREAM.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
read-sequence::, *note write-string::, *note write-line::

Notes:
......

‘write-sequence’ is identical in effect to iterating over the indicated
subsequence and writing one element at a time to STREAM, but may be
more efficient than the equivalent loop.  An efficient implementation
is more likely to exist for the case where the SEQUENCE is a vector
with the same element type as the STREAM.


File: ansicl,  Node: file-length,  Next: file-position,  Prev: write-sequence,  Up: Streams

file-length (Function)
======================

Syntax:
.......

 -- Function: file-length stream → length

Arguments and Values:
.....................

STREAM--a stream associated with a file.

LENGTH--a non-negative integer or ‘nil’.

Description:
............

‘file-length’ returns the length of STREAM, or ‘nil’ if the length
cannot be determined.

For a binary file, the length is measured in units of the element type
of the STREAM.

Examples:
.........

 (with-open-file (s "decimal-digits.text"
                    :direction :output :if-exists :error)
   (princ "0123456789" s)
   (truename s))
→ #P"A:>Joe>decimal-digits.text.1"
 (with-open-file (s "decimal-digits.text")
   (file-length s))
→ 10

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not a stream
associated with a file.

See Also:
.........

*note open::


File: ansicl,  Node: file-position,  Next: file-string-length,  Prev: file-length,  Up: Streams

file-position (Function)
========================

Syntax:
.......

 -- Function: file-position stream → position

 -- Function: file-position stream position-spec → success-p

Arguments and Values:
.....................

STREAM--a stream.

POSITION-SPEC--a file position designator.

POSITION--a file position or ‘nil’.

SUCCESS-P--a generalized boolean.

Description:
............

Returns or changes the current position within a STREAM.

When POSITION-SPEC is not supplied, ‘file-position’ returns the current
file position in the STREAM, or ‘nil’ if this cannot be determined.

When POSITION-SPEC is supplied, the file position in STREAM is set to
that file position (if possible).  ‘file-position’ returns true if the
repositioning is performed successfully, or false if it is not.

An integer returned by ‘file-position’ of one argument should be
acceptable as POSITION-SPEC for use with the same file.

For a character file, performing a single ‘read-char’ or ‘write-char’
operation may cause the file position to be increased by more than 1
because of character-set translations (such as translating between the
Common Lisp ‘#\Newline’ character and an external ASCII
carriage-return/line-feed sequence) and other aspects of the
implementation.  For a binary file, every ‘read-byte’ or ‘write-byte’
operation increases the file position by 1.

Examples:
.........

 (defun tester ()
   (let ((noticed '()) file-written)
     (flet ((notice (x) (push x noticed) x))
       (with-open-file (s "test.bin"
                          :element-type '(unsigned-byte 8)
                          :direction :output
                          :if-exists :error)
          (notice (file-position s)) ;1
          (write-byte 5 s)
          (write-byte 6 s)
          (let ((p (file-position s)))
            (notice p) ;2
            (notice (when p (file-position s (1- p))))) ;3
          (write-byte 7 s)
          (notice (file-position s)) ;4
          (setq file-written (truename s)))
        (with-open-file (s file-written
                           :element-type '(unsigned-byte 8)
                           :direction :input)
          (notice (file-position s)) ;5
          (let ((length (file-length s)))
            (notice length) ;6
            (when length
              (dotimes (i length)
                (notice (read-byte s)))))) ;7,...
        (nreverse noticed))))
→ tester
 (tester)
→ (0 2 T 2 0 2 5 7)
or→ (0 2 NIL 3 0 3 5 6 7)
or→ (NIL NIL NIL NIL NIL NIL)

Side Effects:
.............

When the POSITION-SPEC argument is supplied, the file position in the
STREAM might be moved.

Affected By:
............

The value returned by ‘file-position’ increases monotonically as input
or output operations are performed.

Exceptional Situations:
.......................

If POSITION-SPEC is supplied, but is too large or otherwise
inappropriate, an error is signaled.

See Also:
.........

*note file-length::, *note file-string-length::, *note open::

Notes:
......

Implementations that have character files represented as a sequence of
records of bounded size might choose to encode the file position as,
for example,
«record-number»*«max-record-size»+«character-within-record».  This is a
valid encoding because it increases monotonically as each character is
read or written, though not necessarily by 1 at each step.  An integer
might then be considered "inappropriate" as POSITION-SPEC to
‘file-position’ if, when decoded into record number and character
number, it turned out that the supplied record was too short for the
specified character number.


File: ansicl,  Node: file-string-length,  Next: open,  Prev: file-position,  Up: Streams

file-string-length (Function)
=============================

Syntax:
.......

 -- Function: file-string-length stream object → length

Arguments and Values:
.....................

STREAM--an output character file stream.

OBJECT--a string or a character.

LENGTH--a non-negative integer, or ‘nil’.

Description:
............

‘file-string-length’ returns the difference between what
‘(file-position STREAM)’ would be after writing OBJECT and its current
value, or ‘nil’ if this cannot be determined.

The returned value corresponds to the current state of STREAM at the
time of the call and might not be the same if it is called again when
the state of the stream has changed.


File: ansicl,  Node: open,  Next: stream-external-format,  Prev: file-string-length,  Up: Streams

open (Function)
===============

Syntax:
.......

 -- Function: open filespec &key direction element-type
          if-exists if-does-not-exist external-format → stream

Arguments and Values:
.....................

FILESPEC--a pathname designator.

DIRECTION--one of :input, :output, :io, or :probe.  The default is
:input.

ELEMENT-TYPE--a type specifier for recognizable subtype of ‘character’;
or a type specifier for a finite recognizable subtype of integer; or
one of the symbols signed-byte, unsigned-byte, or :default.  The
default is ‘character’.

IF-EXISTS--one of :error, :new-version, :rename, :rename-and-delete,
:overwrite, :append, :supersede, or ‘nil’.  The default is :new-version
if the version component of FILESPEC is :newest, or :error otherwise.

IF-DOES-NOT-EXIST--one of :error, :create, or ‘nil’.  The default is
:error if DIRECTION is :input or IF-EXISTS is :overwrite or :append;
:create if DIRECTION is :output or :io, and IF-EXISTS is neither
:overwrite nor :append; or ‘nil’ when DIRECTION is :probe.

EXTERNAL-FORMAT--an external file format designator.  The default is
:default.

STREAM--a file stream or ‘nil’.

Description:
............

‘open’ creates, opens, and returns a file stream that is connected to
the file specified by FILESPEC.  FILESPEC is the name of the file to be
opened.  If the FILESPEC designator is a stream, that stream is not
closed first or otherwise affected.

The keyword arguments to ‘open’ specify the characteristics of the file
stream that is returned, and how to handle errors.

If DIRECTION is :input or :probe, or if IF-EXISTS is not :new-version
and the version component of the FILESPEC is :newest, then the file
opened is that file already existing in the file system that has a
version greater than that of any other file in the file system whose
other pathname components are the same as those of FILESPEC.

An implementation is required to recognize all of the ‘open’ keyword
options and to do something reasonable in the context of the host
operating system.  For example, if a file system does not support
distinct file versions and does not distinguish the notions of deletion
and expunging, :new-version might be treated the same as :rename or
:supersede, and :rename-and-delete might be treated the same as
:supersede.

:direction
     These are the possible values for DIRECTION, and how they affect
     the nature of the stream that is created:

    :input
          Causes the creation of an input file stream.

    :output
          Causes the creation of an output file stream.

    :io
          Causes the creation of a bidirectional file stream.

    :probe
          Causes the creation of a "no-directional" file stream; in
          effect, the file stream is created and then closed prior to
          being returned by ‘open’.

:element-type
     The ELEMENT-TYPE specifies the unit of transaction for the file
     stream.  If it is :default, the unit is determined by file system,
     possibly based on the file.

:if-exists
     IF-EXISTS specifies the action to be taken if DIRECTION is :output
     or :io and a file of the name FILESPEC already exists.  If
     DIRECTION is :input, not supplied, or :probe, IF-EXISTS is ignored.
     These are the results of ‘open’ as modified by IF-EXISTS:

    :error
          An error of type ‘file-error’ is signaled.

    :new-version
          A new file is created with a larger version number.

    :rename
          The existing file is renamed to some other name and then a
          new file is created.

    :rename-and-delete
          The existing file is renamed to some other name, then it is
          deleted but not expunged, and then a new file is created.

    :overwrite
          Output operations on the stream destructively modify the
          existing file.  If DIRECTION is :io the file is opened in a
          bidirectional mode that allows both reading and writing.  The
          file pointer is initially positioned at the beginning of the
          file; however, the file is not truncated back to length zero
          when it is opened.

    :append
          Output operations on the stream destructively modify the
          existing file.  The file pointer is initially positioned at
          the end of the file.

          If DIRECTION is :io, the file is opened in a bidirectional
          mode that allows both reading and writing.

    :supersede
          The existing file is superseded; that is, a new file with the
          same name as the old one is created.  If possible, the
          implementation should not destroy the old file until the new
          stream is closed.

    ‘nil’
          No file or stream is created; instead, ‘nil’ is returned to
          indicate failure.

:if-does-not-exist
     IF-DOES-NOT-EXIST specifies the action to be taken if a file of
     name FILESPEC does not already exist.  These are the results of
     ‘open’ as modified by IF-DOES-NOT-EXIST:

    :error
          An error of type ‘file-error’ is signaled.

    :create
          An empty file is created.  Processing continues  as if the
          file had already existed but no processing as directed by
          IF-EXISTS is performed.

    ‘nil’
          No file or stream is created; instead, ‘nil’ is returned to
          indicate failure.

:external-format
     This option selects an external file format for the file: The only
     standardized value for this option is :default, although
     implementations are permitted to define additional external file
     formats and implementation-dependent values returned by
     ‘stream-external-format’ can also be used by conforming programs.

     The EXTERNAL-FORMAT is meaningful for any kind of file stream
     whose element type is a subtype of character.  This option is
     ignored for streams for which it is not meaningful; however,
     implementations may define other element types for which it is
     meaningful.  The consequences are unspecified if a character is
     written that cannot be represented by the given external file
     format.

When a file is opened, a file stream is constructed to serve as the
file system's ambassador to the Lisp environment; operations on the
file stream are reflected by operations on the file in the file system.

A file can be deleted, renamed, or destructively modified by ‘open’.

For information about opening relative pathnames, see *note Section
19.2.3 (Merging Pathnames): Merging Pathnames.

Examples:
.........

 (open filespec :direction :probe)  → #<Closed Probe File Stream...>
 (setq q (merge-pathnames (user-homedir-pathname) "test"))
→ #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>
 (open filespec :if-does-not-exist :create) → #<Input File Stream...>
 (setq s (open filespec :direction :probe)) → #<Closed Probe File Stream...>
 (truename s) → #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY
    directory-name :NAME filespec :TYPE extension :VERSION 1>
 (open s :direction :output :if-exists nil) → NIL

Affected By:
............

The nature and state of the host computer's file system.

Exceptional Situations:
.......................

If IF-EXISTS is :error, (subject to the constraints on the meaning of
IF-EXISTS listed above), an error of type ‘file-error’ is signaled.

If IF-DOES-NOT-EXIST is :error (subject to the constraints on the
meaning of IF-DOES-NOT-EXIST listed above), an error of type
‘file-error’ is signaled.

If it is impossible for an implementation to handle some option in a
manner close to what is specified here, an error of type ‘error’ might
be signaled.

An error of type ‘file-error’ is signaled if ‘(wild-pathname-p
FILESPEC)’ returns true.

An error of type ‘error’ is signaled if the EXTERNAL-FORMAT is not
understood by the implementation.

The various file systems in existence today have widely differing
capabilities, and some aspects of the file system are beyond the scope
of this specification to define.  A given implementation might not be
able to support all of these options in exactly the manner stated.  An
implementation is required to recognize all of these option keywords
and to try to do something "reasonable" in the context of the host file
system.  Where necessary to accomodate the file system, an
implementation deviate slightly from the semantics specified here
without being disqualified for consideration as a conforming
implementation.  If it is utterly impossible for an implementation to
handle some option in a manner similar to what is specified here, it
may simply signal an error.

With regard to the :element-type option, if a type is requested that is
not supported by the file system, a substitution of types such as that
which goes on in upgrading is permissible.  As a minimum requirement,
it should be the case that opening an output stream to a file in a
given element type and later opening an input stream to the same file
in the same element type should work compatibly.

See Also:
.........

*note with-open-file::, *note close::, *note pathname (System Class)::,
*note logical-pathname (System Class)::, *note Section 19.2.3 (Merging
Pathnames): Merging Pathnames, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

‘open’ does not automatically close the file when an abnormal exit
occurs.

When ELEMENT-TYPE is a subtype of ‘character’, ‘read-char’ and/or
‘write-char’ can be used on the resulting file stream.

When ELEMENT-TYPE is a subtype of integer, ‘read-byte’ and/or
‘write-byte’ can be used on the resulting file stream.

When ELEMENT-TYPE is :default, the type can be determined by using
‘stream-element-type’.


File: ansicl,  Node: stream-external-format,  Next: with-open-file,  Prev: open,  Up: Streams

stream-external-format (Function)
=================================

Syntax:
.......

 -- Function: stream-external-format stream → format

Arguments and Values:
.....................

STREAM--a file stream.

FORMAT--an external file format.

Description:
............

Returns an external file format designator for the STREAM.

Examples:
.........

 (with-open-file (stream "test" :direction :output)
   (stream-external-format stream))
→ :DEFAULT
or→ :ISO8859/1-1987
or→ (:ASCII :SAIL)
or→ ACME::PROPRIETARY-FILE-FORMAT-17
or→ #<FILE-FORMAT :ISO646-1983 2343673>

See Also:
.........

the :external-format argument to the function ‘open’ and the
‘with-open-file’ macro.

Notes:
......

The FORMAT returned is not necessarily meaningful to other
implementations.


File: ansicl,  Node: with-open-file,  Next: close,  Prev: stream-external-format,  Up: Streams

with-open-file (macro)
======================

Syntax:
.......

 -- Macro: with-open-file (stream filespec {options}*) {declaration}*
          {form}* → results

Arguments and Values:
.....................

STREAM--a variable.

FILESPEC--a pathname designator.

OPTIONS--forms; evaluated.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

‘with-open-file’ uses ‘open’ to create a file stream to file named by
FILESPEC.  FILESPEC is the name of the file to be opened.  OPTIONS are
used as keyword arguments to ‘open’.

The stream object to which the STREAM variable is bound has dynamic
extent; its extent ends when the form is exited.

‘with-open-file’ evaluates the FORMS as an implicit progn with STREAM
bound to the value returned by ‘open’.

When control leaves the body, either normally or abnormally (such as by
use of ‘throw’), the file is automatically closed.  If a new output
file is being written, and control leaves abnormally, the file is
aborted and the file system is left, so far as possible, as if the file
had never been opened.

It is possible by the use of ‘:if-exists nil’ or ‘:if-does-not-exist
nil’ for STREAM to be bound to ‘nil’.  Users of ‘:if-does-not-exist
nil’ should check for a valid stream.

The consequences are undefined if an attempt is made to assign the
STREAM variable.  The compiler may choose to issue a warning if such an
attempt is detected.

Examples:
.........

 (setq p (merge-pathnames "test"))
→ #<PATHNAME :HOST NIL :DEVICE device-name :DIRECTORY directory-name
    :NAME "test" :TYPE NIL :VERSION :NEWEST>
 (with-open-file (s p :direction :output :if-exists :supersede)
    (format s "Here are a couple~%of test data lines~%")) → NIL
 (with-open-file (s p)
    (do ((l (read-line s) (read-line s nil 'eof)))
        ((eq l 'eof) "Reached end of file.")
     (format t "~&*** ~A~%" l)))
▷ *** Here are a couple
▷ *** of test data lines
→ "Reached end of file."

;; Normally one would not do this intentionally because it is
;; not perspicuous, but beware when using :IF-DOES-NOT-EXIST NIL
;; that this doesn't happen to you accidentally...
 (with-open-file (foo "no-such-file" :if-does-not-exist nil)
   (read foo))
▷ hello?
→ HELLO? ;This value was read from the terminal, not a file!

;; Here's another bug to avoid...
 (with-open-file (foo "no-such-file" :direction :output :if-does-not-exist nil)
   (format foo "Hello"))
→ "Hello" ;FORMAT got an argument of NIL!

Side Effects:
.............

Creates a stream to the file named by FILENAME (upon entry), and closes
the stream (upon exit).  In some implementations, the file might be
locked in some way while it is open.  If the stream is an output stream,
a file might be created.

Affected By:
............

The host computer's file system.

Exceptional Situations:
.......................

See the function *note open::.

See Also:
.........

*note open::, *note close::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.


File: ansicl,  Node: close,  Next: with-open-stream,  Prev: with-open-file,  Up: Streams

close (Function)
================

Syntax:
.......

 -- Function: close stream &key abort → result

Arguments and Values:
.....................

STREAM--a stream (either open or closed).

ABORT--a generalized boolean.  The default is false.

RESULT--‘t’ if the STREAM was open at the time it was received as an
argument, or implementation-dependent otherwise.

Description:
............

‘close’ closes STREAM.  Closing a stream means that it may no longer be
used in input or output operations.  The act of closing a file stream
ends the association between the stream and its associated file; the
transaction with the file system is terminated, and input/output may no
longer be performed on the stream.

If ABORT is true, an attempt is made to clean up any side effects of
having created STREAM.  If STREAM performs output to a file that was
created when the stream was created, the file is deleted and any
previously existing file is not superseded.

It is permissible to close an already closed stream, but in that case
the RESULT is implementation-dependent.

After STREAM is closed, it is still possible to perform the following
query operations upon it: ‘streamp’, ‘pathname’, ‘truename’,
‘merge-pathnames’, ‘pathname-host’, ‘pathname-device’,
‘pathname-directory’,‘pathname-name’, ‘pathname-type’,
‘pathname-version’, ‘namestring’, ‘file-namestring’,
‘directory-namestring’, ‘host-namestring’, ‘enough-namestring’, ‘open’,
‘probe-file’, and ‘directory’.

The effect of ‘close’ on a constructed stream is to close the argument
STREAM only.  There is no effect on the constituents of composite
streams.

For a stream created with ‘make-string-output-stream’, the result of
‘get-output-stream-string’ is unspecified after ‘close’.

Examples:
.........

 (setq s (make-broadcast-stream)) → #<BROADCAST-STREAM>
 (close s) → T
 (output-stream-p s) → true

Side Effects:
.............

The STREAM is closed (if necessary).  If ABORT is true and the STREAM is
an output file stream, its associated file might be deleted.

See Also:
.........

*note open::


File: ansicl,  Node: with-open-stream,  Next: listen,  Prev: close,  Up: Streams

with-open-stream (Macro)
========================

Syntax:
.......

 -- Macro: with-open-stream (var stream) {declaration}* {form}* →
          {result}*

Arguments and Values:
.....................

VAR--a variable name.

STREAM--a form; evaluated to produce a stream.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

‘with-open-stream’ performs a series of operations on STREAM, returns a
value, and then closes the STREAM.

VAR is bound to the value of STREAM, and then FORMS are executed as an
implicit progn.  STREAM is automatically closed on exit from
‘with-open-stream’, no matter whether the exit is normal or abnormal.
The STREAM has dynamic extent; its extent ends when the form is exited.

The consequences are undefined if an attempt is made to assign the the
variable VAR with the FORMS.

Examples:
.........

 (with-open-stream (s (make-string-input-stream "1 2 3 4"))
    (+ (read s) (read s) (read s))) → 6

Side Effects:
.............

The STREAM is closed (upon exit).

See Also:
.........

*note close::


File: ansicl,  Node: listen,  Next: clear-input,  Prev: with-open-stream,  Up: Streams

listen (Function)
=================

Syntax:
.......

 -- Function: listen &optional input-stream → generalized-boolean

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if there is a character immediately available from
INPUT-STREAM; otherwise, returns false.  On a non-interactive
INPUT-STREAM, ‘listen’ returns true except when at end of file₁.  If an
end of file is encountered, ‘listen’ returns false.  ‘listen’ is
intended to be used when INPUT-STREAM obtains characters from an
interactive device such as a keyboard.

Examples:
.........

 (progn (unread-char (read-char)) (list (listen) (read-char)))
▷ 1
→ (T #\1)
 (progn (clear-input) (listen))
→ NIL ;Unless you're a very fast typist!

Affected By:
............

‘*standard-input*’

See Also:
.........

*note interactive-stream-p::, *note read-char-no-hang::


File: ansicl,  Node: clear-input,  Next: finish-output; force-output; clear-output,  Prev: listen,  Up: Streams

clear-input (Function)
======================

Syntax:
.......

 -- Function: clear-input &optional input-stream → ‘nil’

Arguments and Values:
.....................

INPUT-STREAM--an input stream designator.  The default is standard
input.

Description:
............

Clears any available input from INPUT-STREAM.

If ‘clear-input’ does not make sense for INPUT-STREAM, then
‘clear-input’ does nothing.

Examples:
.........

;; The exact I/O behavior of this example might vary from implementation
;; to implementation depending on the kind of interactive buffering that
;; occurs.  (The call to SLEEP here is intended to help even out the
;; differences in implementations which do not do line-at-a-time buffering.)

(defun read-sleepily (&optional (clear-p nil) (zzz 0))
  (list (progn (print '>) (read))
        ;; Note that input typed within the first ZZZ seconds
        ;; will be discarded.
        (progn (print '>)
               (if zzz (sleep zzz))
               (print '>>)
               (if clear-p (clear-input))
               (read))))

(read-sleepily)
▷ > 10
▷ >
▷ >> 20
→ (10 20)

(read-sleepily t)
▷ > 10
▷ >
▷ >> 20
→ (10 20)

(read-sleepily t 10)
▷ > 10
▷ > 20  ; Some implementations won't echo typeahead here.
▷ >> 30
→ (10 30)

Side Effects:
.............

The INPUT-STREAM is modified.

Affected By:
............

‘*standard-input*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INPUT-STREAM is not a
stream designator.

See Also:
.........

*note clear-output::


File: ansicl,  Node: finish-output; force-output; clear-output,  Next: y-or-n-p; yes-or-no-p,  Prev: clear-input,  Up: Streams

finish-output, force-output, clear-output (Function)
====================================================

Syntax:
.......

 -- Function: finish-output &optional output-stream → ‘nil’

 -- Function: force-output &optional output-stream → ‘nil’

 -- Function: clear-output &optional output-stream → ‘nil’

Arguments and Values:
.....................

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

Description:
............

‘finish-output’, ‘force-output’, and ‘clear-output’ exercise control
over the internal handling of buffered stream output.

‘finish-output’ attempts to ensure that any buffered output sent to
OUTPUT-STREAM has reached its destination, and then returns.

‘force-output’ initiates the emptying of any internal buffers but does
not wait for completion or acknowledgment to return.

‘clear-output’ attempts to abort any outstanding output operation in
progress in order to allow as little output as possible to continue to
the destination.

If any of these operations does not make sense for OUTPUT-STREAM, then
it does nothing.  The precise actions of these functions are
implementation-dependent.

Examples:
.........

;; Implementation A
 (progn (princ "am i seen?") (clear-output))
→ NIL

;; Implementation B
 (progn (princ "am i seen?") (clear-output))
▷ am i seen?
→ NIL

Affected By:
............

‘*standard-output*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if OUTPUT-STREAM is not a
stream designator.

See Also:
.........

*note clear-input::


File: ansicl,  Node: y-or-n-p; yes-or-no-p,  Next: make-synonym-stream,  Prev: finish-output; force-output; clear-output,  Up: Streams

y-or-n-p, yes-or-no-p (Function)
================================

Syntax:
.......

 -- Function: y-or-n-p &optional control &rest arguments →
          generalized-boolean

 -- Function: yes-or-no-p &optional control &rest arguments →
          generalized-boolean

Arguments and Values:
.....................

CONTROL--a format control.

ARGUMENTS--format arguments for CONTROL.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These functions ask a question and parse a response from the user.
They return true if the answer is affirmative, or false if the answer
is negative.

‘y-or-n-p’ is for asking the user a question whose answer is either
"yes" or "no."  It is intended that the reply require the user to
answer a yes-or-no question with a single character.  ‘yes-or-no-p’ is
also for asking the user a question whose answer is either "Yes" or
"No."  It is intended that the reply require the user to take more
action than just a single keystroke, such as typing the full word ‘yes’
or ‘no’ followed by a newline.

‘y-or-n-p’ types out a message (if supplied), reads an answer in some
implementation-dependent manner (intended to be short and simple, such
as reading a single character such as ‘Y’ or ‘N’).  ‘yes-or-no-p’ types
out a message (if supplied), attracts the user's attention (for
example, by ringing the terminal's bell), and reads an answer in some
implementation-dependent manner (intended to be multiple characters,
such as ‘YES’ or ‘NO’).

If FORMAT-CONTROL is supplied and not ‘nil’, then a ‘fresh-line’
operation is performed; then a message is printed as if FORMAT-CONTROL
and ARGUMENTS were given to ‘format’.  In any case, ‘yes-or-no-p’ and
‘y-or-n-p’ will provide a prompt such as "‘(Y or N)’" or "‘(Yes or
No)’" if appropriate.

All input and output are performed using query I/O.

Examples:
.........

 (y-or-n-p "(t or nil) given by")
▷ (t or nil) given by (Y or N) Y
→ true
 (yes-or-no-p "a ~S message" 'frightening)
▷ a FRIGHTENING message (Yes or No) no
→ false
 (y-or-n-p "Produce listing file?")
▷ Produce listing file?
▷ Please respond with Y or N. n
→ false

Side Effects:
.............

Output to and input from query I/O will occur.

Affected By:
............

‘*query-io*’.

See Also:
.........

*note format::

Notes:
......

‘yes-or-no-p’ and ‘yes-or-no-p’ do not add question marks to the end of
the prompt string, so any desired question mark or other punctuation
should be explicitly included in the text query.


File: ansicl,  Node: make-synonym-stream,  Next: synonym-stream-symbol,  Prev: y-or-n-p; yes-or-no-p,  Up: Streams

make-synonym-stream (Function)
==============================

Syntax:
.......

 -- Function: make-synonym-stream symbol → synonym-stream

Arguments and Values:
.....................

SYMBOL--a symbol that names a dynamic variable.

SYNONYM-STREAM--a synonym stream.

Description:
............

Returns a synonym stream whose synonym stream symbol is SYMBOL.

Examples:
.........

 (setq a-stream (make-string-input-stream "a-stream")
        b-stream (make-string-input-stream "b-stream"))
→ #<String Input Stream>
 (setq s-stream (make-synonym-stream 'c-stream))
→ #<SYNONYM-STREAM for C-STREAM>
 (setq c-stream a-stream)
→ #<String Input Stream>
 (read s-stream) → A-STREAM
 (setq c-stream b-stream)
→ #<String Input Stream>
 (read s-stream) → B-STREAM

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a symbol.

See Also:
.........

*note Section 21.1 (Stream Concepts): Stream Concepts.


File: ansicl,  Node: synonym-stream-symbol,  Next: broadcast-stream-streams,  Prev: make-synonym-stream,  Up: Streams

synonym-stream-symbol (Function)
================================

Syntax:
.......

 -- Function: synonym-stream-symbol synonym-stream → symbol

Arguments and Values:
.....................

SYNONYM-STREAM--a synonym stream.

SYMBOL--a symbol.

Description:
............

Returns the symbol whose ‘symbol-value’ the SYNONYM-STREAM is using.

See Also:
.........

*note make-synonym-stream::


File: ansicl,  Node: broadcast-stream-streams,  Next: make-broadcast-stream,  Prev: synonym-stream-symbol,  Up: Streams

broadcast-stream-streams (Function)
===================================

Syntax:
.......

 -- Function: broadcast-stream-streams broadcast-stream → streams

Arguments and Values:
.....................

BROADCAST-STREAM--a broadcast stream.

STREAMS--a list of streams.

Description:
............

Returns a list of output streams that constitute all the streams to
which the BROADCAST-STREAM is broadcasting.


File: ansicl,  Node: make-broadcast-stream,  Next: make-two-way-stream,  Prev: broadcast-stream-streams,  Up: Streams

make-broadcast-stream (Function)
================================

Syntax:
.......

 -- Function: make-broadcast-stream &rest streams → broadcast-stream

Arguments and Values:
.....................

STREAM--an output stream.

BROADCAST-STREAM--a broadcast stream.

Description:
............

Returns a broadcast stream.

Examples:
.........

 (setq a-stream (make-string-output-stream)
        b-stream (make-string-output-stream)) → #<String Output Stream>
 (format (make-broadcast-stream a-stream b-stream)
          "this will go to both streams") → NIL
 (get-output-stream-string a-stream) → "this will go to both streams"
 (get-output-stream-string b-stream) → "this will go to both streams"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STREAM is not an output
stream.

See Also:
.........

*note broadcast-stream-streams::


File: ansicl,  Node: make-two-way-stream,  Next: two-way-stream-input-stream; two-way-stream-output-stream,  Prev: make-broadcast-stream,  Up: Streams

make-two-way-stream (Function)
==============================

Syntax:
.......

 -- Function: make-two-way-stream input-stream output-stream →
          two-way-stream

Arguments and Values:
.....................

INPUT-STREAM--a stream.

OUTPUT-STREAM--a stream.

TWO-WAY-STREAM--a two-way stream.

Description:
............

Returns a two-way stream that gets  its input  from INPUT-STREAM and
sends its output to   OUTPUT-STREAM.

Examples:
.........

 (with-output-to-string (out)
    (with-input-from-string (in "input...")
      (let ((two (make-two-way-stream in out)))
        (format two "output...")
        (setq what-is-read (read two))))) → "output..."
 what-is-read → INPUT...

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INPUT-STREAM is not an
input stream.  Should signal an error of type ‘type-error’ if
OUTPUT-STREAM is not an output stream.


File: ansicl,  Node: two-way-stream-input-stream; two-way-stream-output-stream,  Next: echo-stream-input-stream; echo-stream-output-stream,  Prev: make-two-way-stream,  Up: Streams

two-way-stream-input-stream, two-way-stream-output-stream (Function)
====================================================================

Syntax:
.......

 -- Function: two-way-stream-input-stream two-way-stream → input-stream

 -- Function: two-way-stream-output-stream two-way-stream →
          output-stream

Arguments and Values:
.....................

TWO-WAY-STREAM--a two-way stream.

INPUT-STREAM--an input stream.

OUTPUT-STREAM--an output stream.

Description:
............

‘two-way-stream-input-stream’ returns the stream from which
TWO-WAY-STREAM receives input.

‘two-way-stream-output-stream’ returns the stream to which
TWO-WAY-STREAM sends output.


File: ansicl,  Node: echo-stream-input-stream; echo-stream-output-stream,  Next: make-echo-stream,  Prev: two-way-stream-input-stream; two-way-stream-output-stream,  Up: Streams

echo-stream-input-stream, echo-stream-output-stream (Function)
==============================================================

Syntax:
.......

 -- Function: echo-stream-input-stream echo-stream → input-stream

 -- Function: echo-stream-output-stream echo-stream → output-stream

Arguments and Values:
.....................

ECHO-STREAM--an echo stream.

INPUT-STREAM--an input stream.

‘output-stream’--an output stream.

Description:
............

‘echo-stream-input-stream’ returns the input stream from which
ECHO-STREAM receives input.

‘echo-stream-output-stream’ returns the output stream to which
ECHO-STREAM sends output.


File: ansicl,  Node: make-echo-stream,  Next: concatenated-stream-streams,  Prev: echo-stream-input-stream; echo-stream-output-stream,  Up: Streams

make-echo-stream (Function)
===========================

Syntax:
.......

 -- Function: make-echo-stream input-stream output-stream → echo-stream

Arguments and Values:
.....................

INPUT-STREAM--an input stream.

OUTPUT-STREAM--an output stream.

ECHO-STREAM--an echo stream.

Description:
............

Creates and returns an echo stream that takes input  from INPUT-STREAM
and  sends output to   OUTPUT-STREAM.

Examples:
.........

 (let ((out (make-string-output-stream)))
    (with-open-stream
        (s (make-echo-stream
            (make-string-input-stream "this-is-read-and-echoed")
            out))
      (read s)
      (format s " * this-is-direct-output")
      (get-output-stream-string out)))
→ "this-is-read-and-echoed * this-is-direct-output"

See Also:
.........

*note echo-stream-input-stream::, *note echo-stream-output-stream::,
*note make-two-way-stream::


File: ansicl,  Node: concatenated-stream-streams,  Next: make-concatenated-stream,  Prev: make-echo-stream,  Up: Streams

concatenated-stream-streams (Function)
======================================

Syntax:
.......

 -- Function: concatenated-stream-streams concatenated-stream → streams

Arguments and Values:
.....................

CONCATENATED-STREAM--a concatenated stream.

STREAMS--a list of input streams.

Description:
............

Returns a list of input streams that constitute the ordered set of
streams the CONCATENATED-STREAM still has to read from, starting with
the current one it is reading from.  The list may be empty if no more
streams remain to be read.

The consequences are undefined if the list structure of the STREAMS is
ever modified.


File: ansicl,  Node: make-concatenated-stream,  Next: get-output-stream-string,  Prev: concatenated-stream-streams,  Up: Streams

make-concatenated-stream (Function)
===================================

Syntax:
.......

 -- Function: make-concatenated-stream &rest input-streams →
          concatenated-stream

Arguments and Values:
.....................

INPUT-STREAM--an input stream.

CONCATENATED-STREAM--a concatenated stream.

Description:
............

Returns a concatenated stream that has the indicated INPUT-STREAMS
initially associated with it.

Examples:
.........

 (read (make-concatenated-stream
         (make-string-input-stream "1")
         (make-string-input-stream "2"))) → 12

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an input stream.

See Also:
.........

*note concatenated-stream-streams::


File: ansicl,  Node: get-output-stream-string,  Next: make-string-input-stream,  Prev: make-concatenated-stream,  Up: Streams

get-output-stream-string (Function)
===================================

Syntax:
.......

 -- Function: get-output-stream-string string-output-stream → string

Arguments and Values:
.....................

STRING-OUTPUT-STREAM--a stream.

STRING--a string.

Description:
............

Returns a string containing, in order, all the characters that have
been output to STRING-OUTPUT-STREAM.  This operation clears any
characters on STRING-OUTPUT-STREAM, so the STRING contains only those
characters which have been output since the last call to
‘get-output-stream-string’ or since the creation of the
STRING-OUTPUT-STREAM, whichever occurred most recently.

Examples:
.........

 (setq a-stream (make-string-output-stream)
        a-string "abcdefghijklm") → "abcdefghijklm"
 (write-string a-string a-stream) → "abcdefghijklm"
 (get-output-stream-string a-stream) → "abcdefghijklm"
 (get-output-stream-string a-stream) → ""

Side Effects:
.............

The STRING-OUTPUT-STREAM is cleared.

Exceptional Situations:
.......................

The consequences are undefined if STREAM-OUTPUT-STRING is closed.

The consequences are undefined if STRING-OUTPUT-STREAM is a stream that
was not produced by ‘make-string-output-stream’.  The consequences are
undefined if STRING-OUTPUT-STREAM was created implicitly by
‘with-output-to-string’ or ‘format’.

See Also:
.........

*note make-string-output-stream::


File: ansicl,  Node: make-string-input-stream,  Next: make-string-output-stream,  Prev: get-output-stream-string,  Up: Streams

make-string-input-stream (Function)
===================================

Syntax:
.......

 -- Function: make-string-input-stream string &optional start end →
          string-stream

Arguments and Values:
.....................

STRING--a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

STRING-STREAM--an input string stream.

Description:
............

Returns an input string stream.  This stream will supply, in order, the
characters in the substring of STRING bounded by START and END.  After
the last character has been supplied, the string stream will then be at
end of file.

Examples:
.........

 (let ((string-stream (make-string-input-stream "1 one ")))
   (list (read string-stream nil nil)
         (read string-stream nil nil)
         (read string-stream nil nil)))
→ (1 ONE NIL)

 (read (make-string-input-stream "prefixtargetsuffix" 6 12)) → TARGET

See Also:
.........

*note with-input-from-string::


File: ansicl,  Node: make-string-output-stream,  Next: with-input-from-string,  Prev: make-string-input-stream,  Up: Streams

make-string-output-stream (Function)
====================================

Syntax:
.......

 -- Function: make-string-output-stream &key element-type →
          string-stream

Arguments and Values:
.....................

ELEMENT-TYPE--a type specifier.  The default is ‘character’.

STRING-STREAM--an output string stream.

Description:
............

Returns an output string stream that accepts characters and makes
available (via ‘get-output-stream-string’) a string that contains the
characters that were actually output.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of that element-type.

Examples:
.........

 (let ((s (make-string-output-stream)))
   (write-string "testing... " s)
   (prin1 1234 s)
   (get-output-stream-string s))
→ "testing... 1234"

.

See Also:
.........

*note get-output-stream-string::, *note with-output-to-string::


File: ansicl,  Node: with-input-from-string,  Next: with-output-to-string,  Prev: make-string-output-stream,  Up: Streams

with-input-from-string (Macro)
==============================

Syntax:
.......

 -- Macro: with-input-from-string (var string &key index start end)
          {declaration}* {form}* → {result}*

Arguments and Values:
.....................

VAR--a variable name.

STRING--a form; evaluated to produce a string.

INDEX--a place.

START, END--bounding index designators of STRING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULT--the values returned by the FORMS.

Description:
............

Creates an input string stream, provides an opportunity to perform
operations on the stream (returning zero or more values), and then
closes the string stream.

STRING is evaluated first, and VAR is bound to a character input string
stream that supplies characters from the subsequence of the resulting
string bounded by START and END.  The body is executed as an implicit
progn.

The input string stream is automatically closed on exit from
‘with-input-from-string’, no matter whether the exit is normal or
abnormal.  The input string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

The INDEX is a pointer within the STRING to be advanced.  If
‘with-input-from-string’ is exited normally, then INDEX will have as
its value the index into the STRING indicating the first character not
read which is ‘(length STRING)’ if all characters were used.  The place
specified by INDEX is not updated as reading progresses, but only at the
end of the operation.

START and INDEX may both specify the same variable, which is a pointer
within the STRING to be advanced, perhaps repeatedly by some containing
loop.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

 (with-input-from-string (s "XXX1 2 3 4xxx"
                             :index ind
                             :start 3 :end 10)
    (+ (read s) (read s) (read s))) → 6
 ind → 9
 (with-input-from-string (s "Animal Crackers" :index j :start 6)
   (read s)) → CRACKERS

The variable ‘j’ is set to ‘15’.

Side Effects:
.............

The value of the place named by INDEX, if any, is modified.

See Also:
.........

*note make-string-input-stream::, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: with-output-to-string,  Next: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Prev: with-input-from-string,  Up: Streams

with-output-to-string (Macro)
=============================

Syntax:
.......

 -- Macro: with-output-to-string (var &optional string-form &key
          element-type) {declaration}* {form}* → {result}*

Arguments and Values:
.....................

VAR--a variable name.

STRING-FORM--a form or ‘nil’; if non-nil, evaluated to produce STRING.

STRING--a string that has a fill pointer.

ELEMENT-TYPE--a type specifier; evaluated.  The default is ‘character’.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--If a STRING-FORM is not supplied or ‘nil’, a string; otherwise,
the values returned by the FORMS.

Description:
............

‘with-output-to-string’ creates a character output stream, performs a
series of operations that may send results to this stream, and then
closes the stream.

The ELEMENT-TYPE names the type of the elements of the stream; a stream
is constructed of the most specialized type that can accommodate
elements of the given type.

The body is executed as an implicit progn with VAR bound to an output
string stream.  All output to that string stream is saved in a string.

If STRING is supplied, ELEMENT-TYPE is ignored, and the output is
incrementally appended to STRING as if by use of ‘vector-push-extend’.

The output stream is automatically closed on exit from
‘with-output-from-string’, no matter whether the exit is normal or
abnormal.  The output string stream to which the variable VAR is bound
has dynamic extent; its extent ends when the form is exited.

If no STRING is provided, then ‘with-output-from-string’ produces a
stream that accepts characters and returns a string of the indicated
ELEMENT-TYPE.  If STRING is provided, ‘with-output-to-string’ returns
the results of evaluating the last FORM.

The consequences are undefined if an attempt is made to assign the
variable VAR.

Examples:
.........

 (setq fstr (make-array '(0) :element-type 'base-char
                             :fill-pointer 0 :adjustable t)) → ""
 (with-output-to-string (s fstr)
    (format s "here's some output")
    (input-stream-p s)) → false
 fstr → "here's some output"

Side Effects:
.............

The STRING is modified.

Exceptional Situations:
.......................

The consequences are undefined if destructive modifications are
performed directly on the STRING during the dynamic extent of the call.

See Also:
.........

*note make-string-output-stream::, *note vector-push-extend::, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.


File: ansicl,  Node: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Next: *terminal-io*,  Prev: with-output-to-string,  Up: Streams

*debug-io*, *error-output*, *query-io*, *standard-input*, *standard-output*, *trace-output* (Variable)
======================================================================================================

Value Type:
...........

For ‘*standard-input*’: an input stream

For ‘*error-output*’, ‘*standard-output*’, and ‘*trace-output*’: an
output stream.

For ‘*debug-io*’, ‘*query-io*’: a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.  The initial value might also be a generalized
synonym stream to either the symbol ‘*terminal-io*’ or to the stream
that is its value.

Description:
............

These variables are collectively called the standardized I/O
customization variables.  They can be bound or assigned in order to
change the default destinations for input and/or output used by various
standardized operators and facilities.

The value of ‘*debug-io*’, called debug I/O, is a stream to be used for
interactive debugging purposes.

The value of ‘*error-output*’, called error output, is a stream to
which warnings and non-interactive error messages should be sent.

The value of ‘*query-io*’, called query I/O, is a bidirectional stream
to be used when asking questions of the user.  The question should be
output to this stream, and the answer read from it.

The value of ‘*standard-input*’, called standard input, is a stream
that is used by many operators as a default source of input when no
specific input stream is explicitly supplied.

The value of ‘*standard-output*’, called standard output, is a stream
that is used by many operators as a default destination for output when
no specific output stream is explicitly supplied.

The value of ‘*trace-output*’, called trace output, is the stream on
which traced functions (see ‘trace’) and the ‘time’ macro print their
output.

Examples:
.........

 (with-output-to-string (*error-output*)
   (warn "this string is sent to *error-output*"))
 → "Warning: this string is sent to *error-output*
" ;The exact format of this string is implementation-dependent.


 (with-input-from-string (*standard-input* "1001")
    (+ 990 (read))) → 1991


 (progn (setq out (with-output-to-string (*standard-output*)
                     (print "print and format t send things to")
                     (format t "*standard-output* now going to a string")))
        :done)
→ :DONE
 out
→ "
\"print and format t send things to\" *standard-output* now going to a string"


 (defun fact (n) (if (< n 2) 1 (* n (fact (- n 1)))))
→ FACT
 (trace fact)
→ (FACT)
;; Of course, the format of traced output is implementation-dependent.
 (with-output-to-string (*trace-output*)
   (fact 3))
→ "
1 Enter FACT 3
| 2 Enter FACT 2
|   3 Enter FACT 1
|   3 Exit FACT 1
| 2 Exit FACT 2
1 Exit FACT 6"

See Also:
.........

*note *terminal-io*::, *note synonym-stream::, *note time (Macro)::,
*note trace::, *note Chapter 9 (Conditions): Conditions, *note Chapter
23 (Reader): Reader, *note Chapter 22 (Printer): Printer.

Notes:
......

The intent of the constraints on the initial value of the I/O
customization variables is to ensure that it is always safe to bind or
assign such a variable to the value of another I/O customization
variable, without unduly restricting implementation flexibility.

It is common for an implementation to make the initial values of
‘*debug-io*’ and ‘*query-io*’ be the same stream, and to make the
initial values of ‘*error-output*’ and ‘*standard-output*’ be the same
stream.

The functions ‘y-or-n-p’ and ‘yes-or-no-p’ use query I/O for their
input and output.

In the normal Lisp read-eval-print loop, input is read from standard
input.  Many input functions, including ‘read’ and ‘read-char’, take a
stream argument that defaults to standard input.

In the normal Lisp read-eval-print loop, output is sent to standard
output.  Many output functions, including ‘print’ and ‘write-char’,
take a stream argument that defaults to standard output.

A program that wants, for example, to divert output to a file should do
so by binding ‘*standard-output*’; that way error messages sent to
‘*error-output*’ can still get to the user by going through
‘*terminal-io*’ (if ‘*error-output*’ is bound to ‘*terminal-io*’),
which is usually what is desired.


File: ansicl,  Node: *terminal-io*,  Next: stream-error,  Prev: *debug-io*; *error-output*; *query-io*; *standard-input*; *standard-out+,  Up: Streams

*terminal-io* (Variable)
========================

Value Type:
...........

a bidirectional stream.

Initial Value:
..............

implementation-dependent, but it must be an open stream that is not a
generalized synonym stream to an I/O customization variables but that
might be a generalized synonym stream to the value of some I/O
customization variable.

Description:
............

The value of ‘*terminal-io*’, called  terminal I/O, is ordinarily a
bidirectional stream that connects to the user's console.  Typically,
writing to this stream would cause the output to appear on a display
screen, for example, and reading from the stream would accept input
from a keyboard.  It is intended that standard input functions such as
‘read’ and ‘read-char’, when used with this stream, cause echoing of
the input into the output side of the stream. The means by which this is
accomplished are implementation-dependent.

The effect of changing the value of ‘*terminal-io*’, either by binding
or assignment, is implementation-defined.

Examples:
.........

 (progn (prin1 'foo) (prin1 'bar *terminal-io*))
▷ FOOBAR
→ BAR
 (with-output-to-string (*standard-output*)
   (prin1 'foo)
   (prin1 'bar *terminal-io*))
▷ BAR
→ "FOO"

See Also:
.........

*note *debug-io*::, *note *error-output*::, *note *query-io*::, *note
*standard-input*::, *note *standard-output*::, *note *trace-output*::


File: ansicl,  Node: stream-error,  Next: stream-error-stream,  Prev: *terminal-io*,  Up: Streams

stream-error (Condition Type)
=============================

Class Precedence List:
......................

‘stream-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘stream-error’ consists of error conditions that are related
to receiving input from or sending output to a stream.  The "offending
stream" is initialized by the :stream initialization argument to
‘make-condition’, and is accessed by the function ‘stream-error-stream’.

See Also:
.........

*note stream-error-stream::


File: ansicl,  Node: stream-error-stream,  Next: end-of-file,  Prev: stream-error,  Up: Streams

stream-error-stream (Function)
==============================

Syntax:
.......

 -- Function: stream-error-stream condition → stream

Arguments and Values:
.....................

CONDITION--a condition of type ‘stream-error’.

STREAM--a stream.

Description:
............

Returns the offending stream of a condition of type ‘stream-error’.

Examples:
.........

 (with-input-from-string (s "(FOO")
   (handler-case (read s)
     (end-of-file (c)
       (format nil "~&End of file on ~S." (stream-error-stream c)))))
"End of file on #<String Stream>."

See Also:
.........

*note stream-error::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: end-of-file,  Prev: stream-error-stream,  Up: Streams

end-of-file (Condition Type)
============================

Class Precedence List:
......................

‘end-of-file’, ‘stream-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘end-of-file’ consists of error conditions related to read
operations that are done on streams that have no more data.

See Also:
.........

*note stream-error-stream::


File: ansicl,  Node: Printer,  Next: Reader,  Prev: Streams,  Up: Top

22 Printer
**********

* Menu:

* The Lisp Printer::
* The Lisp Pretty Printer::
* Formatted Output::

Dictionary

* copy-pprint-dispatch::
* formatter::
* pprint-dispatch::
* pprint-exit-if-list-exhausted::
* pprint-fill; pprint-linear; pprint-tabular::
* pprint-indent::
* pprint-logical-block::
* pprint-newline::
* pprint-pop::
* pprint-tab::
* print-object::
* print-unreadable-object::
* set-pprint-dispatch::
* write; prin1; print; pprint; princ::
* write-to-string; prin1-to-string; princ-to-string::
* *print-array*::
* *print-base*; *print-radix*::
* *print-case*::
* *print-circle*::
* *print-escape*::
* *print-gensym*::
* *print-level*; *print-length*::
* *print-lines*::
* *print-miser-width*::
* *print-pprint-dispatch*::
* *print-pretty*::
* *print-readably*::
* *print-right-margin*::
* print-not-readable::
* print-not-readable-object::
* format::


File: ansicl,  Node: The Lisp Printer,  Next: The Lisp Pretty Printer,  Up: Printer

22.1 The Lisp Printer
=====================

* Menu:

* Overview of The Lisp Printer::
* Printer Dispatching::
* Default Print-Object Methods::
* Examples of Printer Behavior::


File: ansicl,  Node: Overview of The Lisp Printer,  Next: Printer Dispatching,  Up: The Lisp Printer

22.1.1 Overview of The Lisp Printer
-----------------------------------

Common Lisp provides a representation of most objects in the form of
printed text called the printed representation.  Functions such as
‘print’ take an object and send the characters of its printed
representation to a stream.  The collection of routines that does this
is known as the (Common Lisp) printer.

Reading a printed representation typically produces an object that is
‘equal’ to the originally printed object.

22.1.1.1 Multiple Possible Textual Representations
..................................................

Most objects have more than one possible textual representation.  For
example, the positive integer with a magnitude of twenty-seven can be
textually expressed in any of these ways:

 27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3

A list containing the two symbols ‘A’ and ‘B’ can also be textually
expressed in a variety of ways:

 (A B)    (a b)    (  a  b )    (\A |B|)
(|\A|
  B
)

In general, from the point of view of the Lisp reader, wherever
whitespace is permissible in a textual representation, any number of
spaces and newlines can appear in standard syntax.

When a function such as ‘print’ produces a printed representation, it
must choose from among many possible textual representations.  In most
cases, it chooses a program readable representation, but in certain
cases it might use a more compact notation that is not program-readable.

A number of option variables, called "printer control variables", are
provided to permit control of individual aspects of the printed
representation of objects.  The next figure shows the standardized
printer control variables; there might also be implementation-defined
printer control variables.

*print-array*    *print-gensym*        *print-pprint-dispatch*
*print-base*     *print-length*        *print-pretty*
*print-case*     *print-level*         *print-radix*
*print-circle*   *print-lines*         *print-readably*
*print-escape*   *print-miser-width*   *print-right-margin*

Figure 22.1: Standardized Printer Control Variables

In addition to the printer control variables, the following additional
defined names relate to or affect the behavior of the Lisp printer:

*package*                     *read-eval*   readtable-case
*read-default-float-format*   *readtable*   

Figure 22.2: Additional Influences on the Lisp printer.

22.1.1.1.1 Printer Escaping
...........................

The variable ‘*print-escape*’ controls whether the Lisp printer tries
to produce notations such as escape characters and package prefixes.

The variable ‘*print-readably*’ can be used to override many of the
individual aspects controlled by the other printer control variables
when program-readable output is especially important.

One of the many effects of making the value of ‘*print-readably*’ be
true is that the Lisp printer behaves as if ‘*print-escape*’ were also
true.  For notational convenience, we say that if the value of either
‘*print-readably*’ or ‘*print-escape*’ is true, then "printer escaping"
is "enabled"; and we say that if the values of both ‘*print-readably*’
and ‘*print-escape*’ are false, then printer escaping is "disabled".


File: ansicl,  Node: Printer Dispatching,  Next: Default Print-Object Methods,  Prev: Overview of The Lisp Printer,  Up: The Lisp Printer

22.1.2 Printer Dispatching
--------------------------

The Lisp printer makes its determination of how to print an object as
follows:

If the value of ‘*print-pretty*’ is true, printing is controlled by the
current pprint dispatch table; see *note Section 22.2.1.4 (Pretty Print
Dispatch Tables): PPrintDispatchTables.

Otherwise (if the value of ‘*print-pretty*’ is false), the object's
‘print-object’ method is used; see *note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods.


File: ansicl,  Node: Default Print-Object Methods,  Next: Examples of Printer Behavior,  Prev: Printer Dispatching,  Up: The Lisp Printer

22.1.3 Default Print-Object Methods
-----------------------------------

This section describes the default behavior of ‘print-object’ methods
for the standardized types.

22.1.3.1 Printing Numbers
.........................

22.1.3.1.1 Printing Integers
............................

Integers are printed in the radix specified by the current output base
in positional notation, most significant digit first.  If appropriate,
a radix specifier can be printed; see ‘*print-radix*’.  If an integer
is negative, a minus sign is printed and then the absolute value of the
integer is printed.  The integer zero is represented by the single
digit ‘0’ and never has a sign.  A decimal point might be printed,
depending on the value of ‘*print-radix*’.

For related information about the syntax of an integer, see *note
Section 2.3.2.1.1 (Syntax of an Integer): SyntaxOfIntegers.

22.1.3.1.2 Printing Ratios
..........................

Ratios are printed as follows: the absolute value of the numerator is
printed, as for an integer; then a ‘/’; then the denominator.  The
numerator and denominator are both printed in the radix specified by
the current output base; they are obtained as if by ‘numerator’ and
‘denominator’, and so ratios are printed in reduced form (lowest terms).
If appropriate, a radix specifier can be printed; see ‘*print-radix*’.
If the ratio is negative, a minus sign is printed before the numerator.

For related information about the syntax of a ratio, see *note Section
2.3.2.1.2 (Syntax of a Ratio): SyntaxOfRatios.

22.1.3.1.3 Printing Floats
..........................

If the magnitude of the float is either zero or between 10^-3
(inclusive) and 10^7 (exclusive), it is printed as the integer part of
the number, then a decimal point, followed by the fractional part of
the number; there is always at least one digit on each side of the
decimal point.  If the sign of the number (as determined by
‘float-sign’) is negative, then a minus sign is printed before the
number.  If the format of the number does not match that specified by
‘*read-default-float-format*’, then the exponent marker for that format
and the digit ‘0’ are also printed.  For example, the base of the
natural logarithms as a short float might be printed as ‘2.71828S0’.

For non-zero magnitudes outside of the range 10^-3 to 10^7, a float is
printed in computerized scientific notation.  The representation of the
number is scaled to be between 1 (inclusive) and 10 (exclusive) and
then printed, with one digit before the decimal point and at least one
digit after the decimal point.  Next the exponent marker for the format
is printed, except that if the format of the number matches that
specified by ‘*read-default-float-format*’, then the exponent marker ‘E’
is used.  Finally, the power of ten by which the fraction must be
multiplied to equal the original number is printed as a decimal integer.
For example, Avogadro's number as a short float is printed as ‘6.02S23’.

For related information about the syntax of a float, see *note Section
2.3.2.2 (Syntax of a Float): SyntaxOfFloats.

22.1.3.1.4 Printing Complexes
.............................

A complex is printed as ‘#C’, an open parenthesis, the printed
representation of its real part, a space, the printed representation of
its imaginary part, and finally a close parenthesis.

For related information about the syntax of a complex, see *note
Section 2.3.2.3 (Syntax of a Complex): SyntaxOfComplexes. and *note
Section 2.4.8.11 (Sharpsign C): SharpsignC.

22.1.3.1.5 Note about Printing Numbers
......................................

The printed representation of a number must not contain escape
characters; see *note Section 2.3.1.1.1 (Escape Characters and
Potential Numbers): EscCharsAndPotentialNums.

22.1.3.2 Printing Characters
............................

When printer escaping is disabled, a character prints as itself; it is
sent directly to the output stream.  When printer escaping is enabled,
then ‘#\’ syntax is used.

When the printer types out the name of a character, it uses the same
table as the ‘#\’ reader macro would use; therefore any character name
that is typed out is acceptable as input (in that implementation).  If
a non-graphic character has a standardized name₅, that name is
preferred over non-standard names for printing in ‘#\’ notation.  For
the graphic standard characters, the character itself is always used
for printing in ‘#\’ notation--even if the character also has a name₅.

For details about the ‘#\’ reader macro, see *note Section 2.4.8.1
(Sharpsign Backslash): SharpsignBackslash.

22.1.3.3 Printing Symbols
.........................

When printer escaping is disabled, only the characters of the symbol's
name are output (but the case in which to print characters in the name
is controlled by ‘*print-case*’; see *note Section 22.1.3.3.2 (Effect
of Readtable Case on the Lisp Printer): ReadtableCasePrintEffect.).

The remainder of this section applies only when printer escaping is
enabled.

When printing a symbol, the printer inserts enough single escape and/or
multiple escape characters (backslashes and/or vertical-bars) so that if
‘read’ were called with the same ‘*readtable*’ and with ‘*read-base*’
bound to the current output base, it would return the same symbol (if
it is not apparently uninterned) or an uninterned symbol with the same
print name (otherwise).

For example, if the value of ‘*print-base*’ were ‘16’ when printing the
symbol ‘face’, it would have to be printed as ‘\FACE’ or ‘\Face’ or
‘|FACE|’, because the token ‘face’ would be read as a hexadecimal
number (decimal value 64206) if the value of ‘*read-base*’ were ‘16’.

For additional restrictions concerning characters with  nonstandard
syntax types in the current readtable, see the variable *note
*print-readably*::

For information about how the Lisp reader parses symbols, see *note
Section 2.3.4 (Symbols as Tokens): Symbols as Tokens. and *note Section
2.4.8.5 (Sharpsign Colon): SharpsignColon.

‘nil’ might be printed as ‘()’ when ‘*print-pretty*’ is true and
printer escaping is enabled.

22.1.3.3.1 Package Prefixes for Symbols
.......................................

Package prefixes are printed if necessary.  The rules for package
prefixes are as follows.  When the symbol is printed, if it is in the
‘KEYWORD’ package, then it is printed with a preceding colon;
otherwise, if it is accessible in the current package, it is printed
without any package prefix; otherwise, it is printed with a package
prefix.

A symbol that is apparently uninterned is printed preceded by "‘#:’" if
‘*print-gensym*’ is true and printer escaping is enabled; if
‘*print-gensym*’ is false or printer escaping is disabled, then the
symbol is printed without a prefix, as if it were in the current
package.

Because the ‘#:’ syntax does not intern the following symbol, it is
necessary to use circular-list syntax if ‘*print-circle*’ is true and
the same uninterned symbol appears several times in an expression to be
printed.  For example, the result of

 (let ((x (make-symbol "FOO"))) (list x x))

would be printed as ‘(#:foo #:foo)’ if ‘*print-circle*’ were false, but
as ‘(#1=#:foo #1#)’ if ‘*print-circle*’ were true.

A summary of the preceding package prefix rules follows:

‘foo:bar’
     ‘foo:bar’ is printed when symbol ‘bar’ is external in its home
     package ‘foo’ and is not accessible in the current package.

‘foo::bar’
     ‘foo::bar’ is printed when ‘bar’ is internal in its home package
     ‘foo’ and is not accessible in the current package.

‘:bar’
     ‘:bar’ is printed when the home package of ‘bar’ is the ‘KEYWORD’
     package.

‘#:bar’
     ‘#:bar’ is printed when ‘bar’ is apparently uninterned, even in
     the pathological case that ‘bar’ has no home package but is
     nevertheless somehow accessible in the current package.

22.1.3.3.2 Effect of Readtable Case on the Lisp Printer
.......................................................

When printer escaping is disabled, or the characters under
consideration are not already quoted specifically by single escape or
multiple escape syntax, the readtable case of the current readtable
affects the way the Lisp printer writes symbols in the following ways:

:upcase
     When the readtable case is :upcase, uppercase characters are
     printed in the case specified by ‘*print-case*’, and lowercase
     characters are printed in their own case.

:downcase
     When the readtable case is :downcase, uppercase characters are
     printed in their own case, and lowercase characters are printed in
     the case specified by ‘*print-case*’.

:preserve
     When the readtable case is :preserve, all alphabetic characters
     are printed in their own case.

:invert
     When the readtable case is :invert, the case of all alphabetic
     characters in single case symbol names is inverted.  Mixed-case
     symbol names are printed as is.

The rules for escaping alphabetic characters in symbol names are
affected by the ‘readtable-case’ if printer escaping is enabled.
Alphabetic characters are escaped as follows:

:upcase
     When the readtable case is :upcase, all lowercase characters must
     be escaped.

:downcase
     When the readtable case is :downcase, all uppercase characters
     must be escaped.

:preserve
     When the readtable case is :preserve, no alphabetic characters
     need be escaped.

:invert
     When the readtable case is :invert, no alphabetic characters need
     be escaped.

22.1.3.3.2.1 Examples of Effect of Readtable Case on the Lisp Printer
.....................................................................

 (defun test-readtable-case-printing ()
   (let ((*readtable* (copy-readtable nil))
         (*print-case* *print-case*))
     (format t "READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~
              ~%--------------------------------------------------~
              ~%")
     (dolist (readtable-case '(:upcase :downcase :preserve :invert))
       (setf (readtable-case *readtable*) readtable-case)
       (dolist (print-case '(:upcase :downcase :capitalize))
         (dolist (symbol '(|ZEBRA| |Zebra| |zebra|))
           (setq *print-case* print-case)
           (format t "~&:~A~15T:~A~29T~A~42T~A"
                   (string-upcase readtable-case)
                   (string-upcase print-case)
                   (symbol-name symbol)
                   (prin1-to-string symbol)))))))

The output from ‘(test-readtable-case-printing)’ should be as follows:

    READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
    --------------------------------------------------
    :UPCASE        :UPCASE       ZEBRA        ZEBRA
    :UPCASE        :UPCASE       Zebra        |Zebra|
    :UPCASE        :UPCASE       zebra        |zebra|
    :UPCASE        :DOWNCASE     ZEBRA        zebra
    :UPCASE        :DOWNCASE     Zebra        |Zebra|
    :UPCASE        :DOWNCASE     zebra        |zebra|
    :UPCASE        :CAPITALIZE   ZEBRA        Zebra
    :UPCASE        :CAPITALIZE   Zebra        |Zebra|
    :UPCASE        :CAPITALIZE   zebra        |zebra|
    :DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|
    :DOWNCASE      :UPCASE       Zebra        |Zebra|
    :DOWNCASE      :UPCASE       zebra        ZEBRA
    :DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|
    :DOWNCASE      :DOWNCASE     Zebra        |Zebra|
    :DOWNCASE      :DOWNCASE     zebra        zebra
    :DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|
    :DOWNCASE      :CAPITALIZE   Zebra        |Zebra|
    :DOWNCASE      :CAPITALIZE   zebra        Zebra
    :PRESERVE      :UPCASE       ZEBRA        ZEBRA
    :PRESERVE      :UPCASE       Zebra        Zebra
    :PRESERVE      :UPCASE       zebra        zebra
    :PRESERVE      :DOWNCASE     ZEBRA        ZEBRA
    :PRESERVE      :DOWNCASE     Zebra        Zebra
    :PRESERVE      :DOWNCASE     zebra        zebra
    :PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA
    :PRESERVE      :CAPITALIZE   Zebra        Zebra
    :PRESERVE      :CAPITALIZE   zebra        zebra
    :INVERT        :UPCASE       ZEBRA        zebra
    :INVERT        :UPCASE       Zebra        Zebra
    :INVERT        :UPCASE       zebra        ZEBRA
    :INVERT        :DOWNCASE     ZEBRA        zebra
    :INVERT        :DOWNCASE     Zebra        Zebra
    :INVERT        :DOWNCASE     zebra        ZEBRA
    :INVERT        :CAPITALIZE   ZEBRA        zebra
    :INVERT        :CAPITALIZE   Zebra        Zebra
    :INVERT        :CAPITALIZE   zebra        ZEBRA

22.1.3.4 Printing Strings
.........................

The characters of the string are output in order.  If printer escaping
is enabled, a double-quote is output before and after, and all
double-quotes and single escapes are preceded by backslash.  The
printing of strings is not affected by ‘*print-array*’.  Only the
active elements of the string are printed.

For information on how the Lisp reader parses strings, see *note
Section 2.4.5 (Double-Quote): Double-Quote.

22.1.3.5 Printing Lists and Conses
..................................

Wherever possible, list notation is preferred over dot notation.
Therefore the following algorithm is used to print a cons x:

  1. A left-parenthesis is printed.

  2. The car of x is printed.

  3. If the cdr of x is itself a cons, it is made to be the current cons
     (i.e., x becomes that cons), a space is printed, and step 2 is
     re-entered.

  4. If the cdr of x is not null, a space, a dot, a space, and the cdr
     of x are printed.

  5. A right-parenthesis is printed.

Actually, the above algorithm is only used when ‘*print-pretty*’ is
false.  When ‘*print-pretty*’ is true (or when ‘pprint’ is used),
additional whitespace₁ may replace the use of a single space, and a
more elaborate algorithm with similar goals but more presentational
flexibility is used; see *note Section 22.1.2 (Printer Dispatching):
Printer Dispatching.

Although the two expressions below are equivalent, and the reader
accepts either one and produces the same cons, the printer always
prints such a cons in the second form.

 (a . (b . ((c . (d . nil)) . (e . nil))))
 (a b (c d) e)

The printing of conses is affected by ‘*print-level*’,
‘*print-length*’, and ‘*print-circle*’.

Following are examples of printed representations of lists:

 (a . b)     ;A dotted pair of a and b
 (a.b)       ;A list of one element, the symbol named a.b
 (a. b)      ;A list of two elements a. and b
 (a .b)      ;A list of two elements a and .b
 (a b . c)   ;A dotted list of a and b with c at the end; two conses
 .iot        ;The symbol whose name is .iot
 (. b)       ;Invalid -- an error is signaled if an attempt is made to read
             ;this syntax.
 (a .)       ;Invalid -- an error is signaled.
 (a .. b)    ;Invalid -- an error is signaled.
 (a . . b)   ;Invalid -- an error is signaled.
 (a b c ...) ;Invalid -- an error is signaled.
 (a \. b)    ;A list of three elements a, ., and b
 (a |.| b)   ;A list of three elements a, ., and b
 (a \... b)  ;A list of three elements a, ..., and b
 (a |...| b) ;A list of three elements a, ..., and b

For information on how the Lisp reader parses lists and conses, see
*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis.

22.1.3.6 Printing Bit Vectors
.............................

A bit vector is printed as ‘#*’ followed by the bits of the bit vector
in order.  If ‘*print-array*’ is false, then the bit vector is printed
in a format (using ‘#<’) that is concise but not readable.  Only the
active elements of the bit vector are printed.

For information on Lisp reader parsing of bit vectors, see *note
Section 2.4.8.4 (Sharpsign Asterisk): SharpsignStar.

22.1.3.7 Printing Other Vectors
...............................

If ‘*print-array*’ is true and ‘*print-readably*’ is false, any vector
other than a string or bit vector is printed using general-vector
syntax; this means that information about specialized vector
representations does not appear.  The printed representation of a
zero-length vector is ‘#()’.  The printed representation of a
non-zero-length vector begins with ‘#(’.  Following that, the first
element of the vector is printed.  If there are any other elements,
they are printed in turn, with each such additional element preceded by
a space if ‘*print-pretty*’ is false, or whitespace₁ if
‘*print-pretty*’ is true.  A right-parenthesis after the last element
terminates the printed representation of the vector.  The printing of
vectors is affected by ‘*print-level*’ and ‘*print-length*’.  If the
vector has a fill pointer, then only those elements below the fill
pointer are printed.

If both ‘*print-array*’ and ‘*print-readably*’ are false, the vector is
not printed as described above, but in a format (using ‘#<’) that is
concise but not readable.

If ‘*print-readably*’ is true, the vector prints in an
implementation-defined manner; see the variable *note
*print-readably*::.

For information on how the Lisp reader parses these "other vectors,"
see *note Section 2.4.8.3 (Sharpsign Left-Parenthesis):
SharpsignLeftParen.

22.1.3.8 Printing Other Arrays
..............................

If  ‘*print-array*’ is true and ‘*print-readably*’ is false, any array
other than a vector is printed using ‘#’‘n’‘A’ format.  Let ‘n’ be the
rank of the array.  Then ‘#’ is printed, then ‘n’ as a decimal integer,
then ‘A’, then ‘n’ open parentheses.  Next the elements are scanned in
row-major order, using ‘write’ on each element, and separating elements
from each other with whitespace₁.  The array's dimensions are numbered
0 to ‘n’-1 from left to right, and are enumerated with the rightmost
index changing fastest.  Every time the index for dimension ‘j’ is
incremented, the following actions are taken:

   * If ‘j’ < ‘n’-1, then a close parenthesis is printed.

   * If incrementing the index for dimension ‘j’ caused it to equal
     dimension ‘j’, that index is reset to zero and the index for
     dimension ‘j’-1 is incremented (thereby performing these three
     steps recursively), unless ‘j’=0, in which case the entire
     algorithm is terminated.  If incrementing the index for dimension
     ‘j’ did not cause it to equal dimension ‘j’, then a space is
     printed.

   * If ‘j’ < ‘n’-1, then an open parenthesis is printed.

This causes the contents to be printed in a format suitable for
:initial-contents to ‘make-array’.  The lists effectively printed by
this procedure are subject to truncation by ‘*print-level*’ and
‘*print-length*’.

If the array is of a specialized type, containing bits or characters,
then the innermost lists generated by the algorithm given above can
instead be printed using bit-vector or string syntax, provided that
these innermost lists would not be subject to truncation by
‘*print-length*’.

If both ‘*print-array*’ and ‘*print-readably*’ are false, then the
array is printed in a format (using ‘#<’) that is concise but not
readable.

If ‘*print-readably*’ is true, the array prints in an
implementation-defined manner; see the variable *note
*print-readably*::.  In particular, this may be important for arrays
having some dimension ‘0’.

For information on how the Lisp reader parses these "other arrays," see
*note Section 2.4.8.12 (Sharpsign A): SharpsignA.

22.1.3.9 Examples of Printing Arrays
....................................

 (let ((a (make-array '(3 3)))
       (*print-pretty* t)
       (*print-array* t))
   (dotimes (i 3) (dotimes (j 3) (setf (aref a i j) (format nil "<~D,~D>" i j))))
   (print a)
   (print (make-array 9 :displaced-to a)))
▷ #2A(("<0,0>" "<0,1>" "<0,2>")
▷     ("<1,0>" "<1,1>" "<1,2>")
▷     ("<2,0>" "<2,1>" "<2,2>"))
▷ #("<0,0>" "<0,1>" "<0,2>" "<1,0>" "<1,1>" "<1,2>" "<2,0>" "<2,1>" "<2,2>")
→ #<ARRAY 9 indirect 36363476>

22.1.3.10 Printing Random States
................................

A specific syntax for printing objects of type ‘random-state’ is not
specified. However, every implementation must arrange to print a random
state object in such a way that, within the same implementation, ‘read’
can construct from the printed representation a copy of the random state
object as if the copy had been made by ‘make-random-state’.

If the type random state is effectively implemented by using the
machinery for ‘defstruct’, the usual structure syntax can then be used
for printing random state objects; one might look something like

 #S(RANDOM-STATE :DATA #(14 49 98436589 786345 8734658324 ... ))

where the components are implementation-dependent.

22.1.3.11 Printing Pathnames
............................

When printer escaping is enabled, the syntax ‘#P"..."’ is how a
pathname is printed by ‘write’ and the other functions herein described.
The ‘"..."’ is the namestring representation of the pathname.

When printer escaping is disabled, ‘write’ writes a pathname P by
writing ‘(namestring P)’ instead.

For information on how the Lisp reader parses pathnames, see *note
Section 2.4.8.14 (Sharpsign P): SharpsignP.

22.1.3.12 Printing Structures
.............................

By default, a structure of type S is printed using ‘#S’ syntax.  This
behavior can be customized by specifying a :print-function or
:print-object option to the ‘defstruct’ form that defines S, or by
writing a ‘print-object’ method that is specialized for objects of type
S.

Different structures might print out in different ways; the default
notation for structures is:

 #S(STRUCTURE-NAME {SLOT-KEY SLOT-VALUE}*)

where ‘#S’ indicates structure syntax, STRUCTURE-NAME is a structure
name, each SLOT-KEY is an initialization argument name for a slot in
the structure, and each corresponding SLOT-VALUE is a representation of
the object in that slot.

For information on how the Lisp reader parses structures, see *note
Section 2.4.8.13 (Sharpsign S): SharpsignS.

22.1.3.13 Printing Other Objects
................................

Other objects are printed in an implementation-dependent manner.  It is
not required that an implementation print those objects readably.

For example, hash tables, readtables, packages, streams, and functions
might not print readably.

A common notation to use in this circumstance is ‘#<...>’.  Since ‘#<’
is not readable by the Lisp reader, the precise format of the text
which follows is not important, but a common format to use is that
provided by the ‘print-unreadable-object’ macro.

For information on how the Lisp reader treats this notation, see *note
Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.  For
information on how to notate objects that cannot be printed readably,
see *note Section 2.4.8.6 (Sharpsign Dot): SharpsignDot.


File: ansicl,  Node: Examples of Printer Behavior,  Prev: Default Print-Object Methods,  Up: The Lisp Printer

22.1.4 Examples of Printer Behavior
-----------------------------------

 (let ((*print-escape* t)) (fresh-line) (write #\a))
▷ #\a
→ #\a
 (let ((*print-escape* nil) (*print-readably* nil))
   (fresh-line)
   (write #\a))
▷ a
→ #\a
 (progn (fresh-line) (prin1 #\a))
▷ #\a
→ #\a
 (progn (fresh-line) (print #\a))
▷
▷ #\a
→ #\a
 (progn (fresh-line) (princ #\a))
▷ a
→ #\a


 (dolist (val '(t nil))
   (let ((*print-escape* val) (*print-readably* val))
     (print '#\a)
     (prin1 #\a) (write-char #\Space)
     (princ #\a) (write-char #\Space)
     (write #\a)))
▷ #\a #\a a #\a
▷ #\a #\a a a
→ NIL


 (progn (fresh-line) (write '(let ((a 1) (b 2)) (+ a b))))
▷ (LET ((A 1) (B 2)) (+ A B))
→ (LET ((A 1) (B 2)) (+ A B))


 (progn (fresh-line) (pprint '(let ((a 1) (b 2)) (+ a b))))
▷ (LET ((A 1)
▷       (B 2))
▷   (+ A B))
→ (LET ((A 1) (B 2)) (+ A B))


 (progn (fresh-line)
        (write '(let ((a 1) (b 2)) (+ a b)) :pretty t))
▷ (LET ((A 1)
▷       (B 2))
▷   (+ A B))
→ (LET ((A 1) (B 2)) (+ A B))


 (with-output-to-string (s)
    (write 'write :stream s)
    (prin1 'prin1 s))
→ "WRITEPRIN1"


File: ansicl,  Node: The Lisp Pretty Printer,  Next: Formatted Output,  Prev: The Lisp Printer,  Up: Printer

22.2 The Lisp Pretty Printer
============================

* Menu:

* Pretty Printer Concepts::
* Examples of using the Pretty Printer::
* Notes about the Pretty Printer's Background::


File: ansicl,  Node: Pretty Printer Concepts,  Next: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.1 Pretty Printer Concepts
------------------------------

The facilities provided by the "pretty printer" permit programs to
redefine the way in which code is displayed, and allow the full power
of pretty printing to be applied to complex combinations of data
structures.

Whether any given style of output is in fact "pretty" is inherently a
somewhat subjective issue.  However, since the effect of the pretty
printer can be customized by conforming programs, the necessary
flexibility is provided for individual programs to achieve an arbitrary
degree of aesthetic control.

By providing direct access to the mechanisms within the pretty printer
that make dynamic decisions about layout, the macros and functions
‘pprint-logical-block’, ‘pprint-newline’, and ‘pprint-indent’ make it
possible to specify pretty printing layout rules as a part of any
function that produces output.  They also make it very easy for the
detection of circularity and sharing, and abbreviation based on length
and nesting depth to be supported by the function.

The pretty printer is driven entirely by dispatch based on the value of
‘*print-pprint-dispatch*’.  The function ‘set-pprint-dispatch’ makes it
possible for conforming programs to associate new pretty printing
functions with a type.

22.2.1.1 Dynamic Control of the Arrangement of Output
.....................................................

The actions of the pretty printer when a piece of output is too large
to fit in the space available can be precisely controlled.  Three
concepts underlie the way these operations work--"logical blocks", "conditional
newlines", and "sections".  Before proceeding further, it is important
to define these terms.

The first line of the next figure shows a schematic piece of output.
Each of the characters in the output is represented by "‘-’".  The
positions of conditional newlines are indicated by digits.  The
beginnings and ends of logical blocks are indicated by "‘<’" and "‘>’"
respectively.

The output as a whole is a logical block and the outermost section.
This section is indicated by the ‘0’'s on the second line of Figure 1.
Logical blocks nested within the output are specified by the macro
‘pprint-logical-block’.  Conditional newline positions are specified by
calls to ‘pprint-newline’.  Each conditional newline defines two
sections (one before it and one after it) and is associated with a
third (the section immediately containing it).

The section after a conditional newline consists of: all the output up
to, but not including, (a) the next conditional newline immediately
contained in the same logical block; or if (a) is not applicable, (b)
the next newline that is at a lesser level of nesting in logical
blocks; or if (b) is not applicable, (c) the end of the output.

The section before a conditional newline consists of: all the output
back to, but not including, (a) the previous conditional newline that is
immediately contained in the same logical block; or if (a) is not
applicable, (b) the beginning of the immediately containing logical
block.  The last four lines in Figure 1 indicate the sections before
and after the four conditional newlines.

The section immediately containing a conditional newline is the shortest
section that contains the conditional newline in question.  In the next
figure, the first conditional newline is immediately contained in the
section marked with ‘0’'s, the second and third conditional newlines
are immediately contained in the section before the fourth conditional
newline, and the fourth conditional newline is immediately contained in
the section after the first conditional newline.

 <-1---<--<--2---3->--4-->->
 000000000000000000000000000
 11 111111111111111111111111
           22 222
              333 3333
        44444444444444 44444

Figure 22.3: Example of Logical Blocks, Conditional Newlines, and
Sections

Whenever possible, the pretty printer displays the entire contents of a
section on a single line.  However, if the section is too long to fit in
the space available, line breaks are inserted at conditional newline
positions within the section.

22.2.1.2 Format Directive Interface
...................................

The primary interface to operations for dynamically determining the
arrangement of output is provided through the functions and macros of
the pretty printer.  The next figure shows the defined names related to
pretty printing.

*print-lines*             pprint-dispatch                 pprint-pop
*print-miser-width*       pprint-exit-if-list-exhausted   pprint-tab
*print-pprint-dispatch*   pprint-fill                     pprint-tabular
*print-right-margin*      pprint-indent                   set-pprint-dispatch
copy-pprint-dispatch      pprint-linear                   write
format                    pprint-logical-block            
formatter                 pprint-newline                  

Figure 22.4: Defined names related to pretty printing.

The next figure identifies a set of format directives which serve as an
alternate interface to the same pretty printing operations in a more
textually compact form.

`~I'    `~W'       `~<... :>'
`~:T'   `~/.../'   `~_'

Figure 22.5: Format directives related to Pretty Printing

22.2.1.3 Compiling Format Strings
.................................

A format string is essentially a program in a special-purpose language
that performs printing, and that is interpreted by the function
‘format’.  The ‘formatter’ macro provides the efficiency of using a
compiled function to do that same printing but without losing the
textual compactness of format strings.

A "format control" is either a format string or a function that was
returned by the the ‘formatter’ macro.

22.2.1.4 Pretty Print Dispatch Tables
.....................................

A "pprint dispatch table" is a mapping from keys to pairs of values.
Each key is a type specifier.  The values associated with a key are a
"function" (specifically, a function designator or ‘nil’) and a
"numerical priority" (specifically, a real).  Basic insertion and
retrieval is done based on the keys with the equality of keys being
tested by ‘equal’.

When ‘*print-pretty*’ is true, the "current pprint dispatch table" (in
‘*print-pprint-dispatch*’) controls how objects are printed.  The
information in this table takes precedence over all other mechanisms
for specifying how to print objects.  In particular, it has priority
over user-defined ‘print-object’ methods because the current pprint
dispatch table is consulted first.

The function is chosen from the current pprint dispatch table by
finding the highest priority function that is associated with a type
specifier that matches the object; if there is more than one such
function, it is implementation-dependent which is used.

However, if there is no information in the table about how to pretty
print a particular kind of object, a function is invoked which uses
‘print-object’ to print the object.  The value of ‘*print-pretty*’ is
still true when this function is called, and individual methods for
‘print-object’ might still elect to produce output in a special format
conditional on the value of ‘*print-pretty*’.

22.2.1.5 Pretty Printer Margins
...............................

A primary goal of pretty printing is to keep the output between a pair
of margins.  The column where the output begins is taken as the left
margin.  If the current column cannot be determined at the time output
begins, the left margin is assumed to be zero.  The right margin is
controlled by ‘*print-right-margin*’.


File: ansicl,  Node: Examples of using the Pretty Printer,  Next: Notes about the Pretty Printer's Background,  Prev: Pretty Printer Concepts,  Up: The Lisp Pretty Printer

22.2.2 Examples of using the Pretty Printer
-------------------------------------------

As an example of the interaction of logical blocks, conditional
newlines, and indentation, consider the function ‘simple-pprint-defun’
below.  This function prints out lists whose cars are ‘defun’ in the
standard way assuming that the list has exactly length ‘4’.

(defun simple-pprint-defun (*standard-output* list)
  (pprint-logical-block (*standard-output* list :prefix "(" :suffix ")")
    (write (first list))
    (write-char #\Space)
    (pprint-newline :miser)
    (pprint-indent :current 0)
    (write (second list))
    (write-char #\Space)
    (pprint-newline :fill)
    (write (third list))
    (pprint-indent :block 1)
    (write-char #\Space)
    (pprint-newline :linear)
    (write (fourth list))))

Suppose that one evaluates the following:

(simple-pprint-defun *standard-output* '(defun prod (x y) (* x y)))

If the line width available is greater than or equal to ‘26’, then all
of the output appears on one line.  If the line width available is
reduced to ‘25’, a line break is inserted at the linear-style
conditional newline before the expression ‘(* x y)’, producing the
output shown.  The ‘(pprint-indent :block 1)’ causes ‘(* x y)’ to be
printed at a relative indentation of ‘1’ in the logical block.

 (DEFUN PROD (X Y)
   (* X Y))

If the line width available is ‘15’, a line break is also inserted at
the fill style conditional newline before the argument list.  The call
on ‘(pprint-indent :current 0)’ causes the argument list to line up
under the function name.

(DEFUN PROD
       (X Y)
  (* X Y))

If ‘*print-miser-width*’ were greater than or equal to 14, the example
output above would have been as follows, because all indentation changes
are ignored in miser mode and line breaks are inserted at miser-style
conditional newlines.  

 (DEFUN
  PROD
  (X Y)
  (* X Y))

As an example of a per-line prefix, consider that evaluating the
following produces the output shown with a line width of ‘20’ and
‘*print-miser-width*’ of ‘nil’.

 (pprint-logical-block (*standard-output* nil :per-line-prefix ";;; ")
   (simple-pprint-defun *standard-output* '(defun prod (x y) (* x y))))

 ;;; (DEFUN PROD
 ;;;        (X Y)
 ;;;   (* X Y))

As a more complex (and realistic) example, consider the function
‘pprint-let’ below.  This specifies how to print a ‘let’ form in the
traditional style.  It is more complex than the example above, because
it has to deal with nested structure.  Also, unlike the example above
it contains complete code to readably print any possible list that
begins with the symbol ‘let’.  The outermost ‘pprint-logical-block’
form handles the printing of the input list as a whole and specifies
that parentheses should be printed in the output.  The second
‘pprint-logical-block’ form handles the list of binding pairs.  Each
pair in the list is itself printed by the innermost
‘pprint-logical-block’.  (A ‘loop’ form is used instead of merely
decomposing the pair into two objects so that readable output will be
produced no matter whether the list corresponding to the pair has one
element, two elements, or (being malformed) has more than two elements.)
A space and a fill-style conditional newline are placed after each pair
except the last.  The loop at the end of the topmost
‘pprint-logical-block’ form prints out the forms in the body of the
‘let’ form separated by spaces and linear-style conditional newlines.

 (defun pprint-let (*standard-output* list)
   (pprint-logical-block (nil list :prefix "(" :suffix ")")
     (write (pprint-pop))
     (pprint-exit-if-list-exhausted)
     (write-char #\Space)
     (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
       (pprint-exit-if-list-exhausted)
       (loop (pprint-logical-block (nil (pprint-pop) :prefix "(" :suffix ")")
               (pprint-exit-if-list-exhausted)
               (loop (write (pprint-pop))
                     (pprint-exit-if-list-exhausted)
                     (write-char #\Space)
                     (pprint-newline :linear)))
             (pprint-exit-if-list-exhausted)
             (write-char #\Space)
             (pprint-newline :fill)))
     (pprint-indent :block 1)
     (loop (pprint-exit-if-list-exhausted)
           (write-char #\Space)
           (pprint-newline :linear)
           (write (pprint-pop)))))

Suppose that one evaluates the following with ‘*print-level*’ being 4,
and ‘*print-circle*’ being true.

 (pprint-let *standard-output*
             '#1=(let (x (*print-length* (f (g 3)))
                       (z . 2) (k (car y)))
                   (setq x (sqrt z)) #1#))

If the line length is greater than or equal to ‘77’, the output produced
appears on one line.  However, if the line length is ‘76’, line breaks
are inserted at the linear-style conditional newlines separating the
forms in the body and the output below is produced.  Note that, the
degenerate binding pair ‘x’ is printed readably even though it fails to
be a list; a depth abbreviation marker is printed in place of ‘(g 3)’;
the binding pair ‘(z . 2)’ is printed readably even though it is not a
proper list; and appropriate circularity markers are printed.

 #1=(LET (X (*PRINT-LENGTH* (F #)) (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)

If the line length is reduced to ‘35’, a line break is inserted at one
of the fill-style conditional newlines separating the binding pairs.

 #1=(LET (X (*PRINT-PRETTY* (F #))
          (Z . 2) (K (CAR Y)))
      (SETQ X (SQRT Z))
      #1#)

Suppose that the line length is further reduced to ‘22’ and
‘*print-length*’ is set to ‘3’. In this situation, line breaks are
inserted after both the first and second binding pairs.  In addition,
the second binding pair is itself broken across two lines.  Clause (b)
of the description of fill-style conditional newlines (see the function
*note pprint-newline::) prevents the binding pair ‘(z . 2)’ from being
printed at the end of the third line.  Note that the length
abbreviation hides the circularity from view and therefore the printing
of circularity markers disappears.

 (LET (X
       (*PRINT-LENGTH*
        (F #))
       (Z . 2) ...)
   (SETQ X (SQRT Z))
   ...)

The next function prints a vector using "‘#(...)’" notation.

(defun pprint-vector (*standard-output* v)
  (pprint-logical-block (nil nil :prefix "#(" :suffix ")")
    (let ((end (length v)) (i 0))
      (when (plusp end)
        (loop (pprint-pop)
              (write (aref v i))
              (if (= (incf i) end) (return nil))
              (write-char #\Space)
              (pprint-newline :fill))))))

Evaluating the following with a line length of 15 produces the output
shown.

 (pprint-vector *standard-output* '#(12 34 567 8 9012 34 567 89 0 1 23))

 #(12 34 567 8
   9012 34 567
   89 0 1 23)

As examples of the convenience of specifying pretty printing with
format strings, consider that the functions ‘simple-pprint-defun’ and
‘pprint-let’ used as examples above can be compactly defined as follows.
(The function ‘pprint-vector’ cannot be defined using ‘format’ because
the data structure it traverses is not a list.)

(defun simple-pprint-defun (*standard-output* list)
  (format T "~:<~W ~@_~:I~W ~:_~W~1I ~_~W~:>" list))

(defun pprint-let (*standard-output* list)
  (format T "~:<~W~^~:<~@{~:<~@{~W~^~_~}~:>~^~:_~}~:>~1I~@{~^~_~W~}~:>" list))

In the following example, the first form restores
‘*print-pprint-dispatch*’ to the equivalent of its initial value.  The
next two forms then set up a special way to pretty print ratios.  Note
that the more specific type specifier has to be associated with a
higher priority.

 (setq *print-pprint-dispatch* (copy-pprint-dispatch nil))

 (set-pprint-dispatch 'ratio
   #'(lambda (s obj)
       (format s "#.(/ ~W ~W)"
                 (numerator obj) (denominator obj))))

 (set-pprint-dispatch '(and ratio (satisfies minusp))
   #'(lambda (s obj)
       (format s "#.(- (/ ~W ~W))"
               (- (numerator obj)) (denominator obj)))
   5)

 (pprint '(1/3 -2/3))
 (#.(/ 1 3) #.(- (/ 2 3)))

The following two forms illustrate the definition of pretty printing
functions for types of code.  The first form illustrates how to specify
the traditional method for printing quoted objects using single-quote.
Note the care taken to ensure that data lists that happen to begin with
quote will be printed readably.  The second form specifies that lists
beginning with the symbol ‘my-let’ should print the same way that lists
beginning with ‘let’ print when the initial pprint dispatch table is in
effect.

 (set-pprint-dispatch '(cons (member quote)) ()
   #'(lambda (s list)
       (if (and (consp (cdr list)) (null (cddr list)))
          (funcall (formatter "'~W") s (cadr list))
          (pprint-fill s list))))

 (set-pprint-dispatch '(cons (member my-let))
                      (pprint-dispatch '(let) nil))

The next example specifies a default method for printing lists that do
not correspond to function calls.  Note that the functions
‘pprint-linear’, ‘pprint-fill’, and ‘pprint-tabular’ are all defined
with optional COLON-P and AT-SIGN-P arguments so that they can be used
as ‘pprint dispatch functions’ as well as `~/.../' functions.

 (set-pprint-dispatch '(cons (not (and symbol (satisfies fboundp))))
                      #'pprint-fill -5)

 ;; Assume a line length of 9
 (pprint '(0 b c d e f g h i j k))
 (0 b c d
  e f g h
  i j k)

This final example shows how to define a pretty printing function for a
user defined data structure.

 (defstruct family mom kids)

 (set-pprint-dispatch 'family
   #'(lambda (s f)
       (funcall (formatter "~@<#<~;~W and ~2I~_~/pprint-fill/~;>~:>")
               s (family-mom f) (family-kids f))))

The pretty printing function for the structure ‘family’ specifies how to
adjust the layout of the output so that it can fit aesthetically into a
variety of line widths.  In addition, it obeys the printer control
variables ‘*print-level*’, ‘*print-length*’, ‘*print-lines*’,
‘*print-circle*’ and ‘*print-escape*’, and can tolerate several
different kinds of malformity in the data structure.  The output below
shows what is printed out with a right margin of ‘25’, ‘*print-pretty*’
being true, ‘*print-escape*’ being false, and a malformed ‘kids’ list.

 (write (list 'principal-family
              (make-family :mom "Lucy"
                           :kids '("Mark" "Bob" . "Dan")))
        :right-margin 25 :pretty T :escape nil :miser-width nil)
 (PRINCIPAL-FAMILY
  #<Lucy and
      Mark Bob . Dan>)

Note that a pretty printing function for a structure is different from
the structure's ‘print-object’ method.  While ‘print-object’ methods
are permanently associated with a structure, pretty printing functions
are stored in pprint dispatch tables and can be rapidly changed to
reflect different printing needs.  If there is no pretty printing
function for a structure in the current pprint dispatch table, its
‘print-object’ method is used instead.


File: ansicl,  Node: Notes about the Pretty Printer's Background,  Prev: Examples of using the Pretty Printer,  Up: The Lisp Pretty Printer

22.2.3 Notes about the Pretty Printer's Background
--------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see `XP: A Common Lisp Pretty Printing System'.  The details
of that paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: ansicl,  Node: Formatted Output,  Next: copy-pprint-dispatch,  Prev: The Lisp Pretty Printer,  Up: Printer

22.3 Formatted Output
=====================

‘format’ is useful for producing nicely formatted text, producing
good-looking messages, and so on.  ‘format’ can generate and return a
string or output to DESTINATION.

The CONTROL-STRING argument to ‘format’ is actually a format control.
That is, it can be either a format string or a function, for example a
function returned by the ‘formatter’ macro.

If it is a function, the function is called with the appropriate output
stream as its first argument and the data arguments to ‘format’ as its
remaining arguments.  The function should perform whatever output is
necessary and return the unused tail of the arguments (if any).

The compilation process performed by ‘formatter’ produces a function
that would do with its arguments as the ‘format’ interpreter would do
with those arguments.

The remainder of this section describes what happens if the
CONTROL-STRING is a format string.

CONTROL-STRING is composed of simple text (characters) and embedded
directives.

‘format’ writes the simple text as is; each embedded directive
specifies further text output that is to appear at the corresponding
point within the simple text.  Most directives use one or more elements
of ARGS to create their output.

A directive consists of a tilde, optional prefix parameters separated
by commas, optional colon and at-sign modifiers, and a single character
indicating what kind of directive this is.  There is no required
ordering between the at-sign and colon modifier.  The case of the
directive character is ignored.  Prefix parameters are notated as
signed (sign is optional) decimal numbers, or as a single-quote
followed by a character.  For example, ‘~5,'0d’ can be used to print an
integer in decimal radix in five columns with leading zeros, or
‘~5,'*d’ to get leading asterisks.

In place of a prefix parameter to a directive, ‘V’ (or ‘v’) can be used.
In this case, ‘format’ takes an argument from ARGS as a parameter to
the directive.  The argument should be an integer or character.  If the
ARG used by a ‘V’ parameter is ‘nil’, the effect is as if the parameter
had been omitted.  ‘#’ can be used in place of a prefix parameter; it
represents the number of ARGS remaining to be processed.  When used
within a recursive format, in the context of ‘~?’ or ‘~{’, the ‘#’
prefix parameter represents the number of format arguments remaining
within the recursive call.

Examples of format strings:

‘"~S"’         ;This is an S directive with no parameters or modifiers.
‘"~3,-4:@s"’   ;This is an S directive with two parameters, ‘3’ and ‘-4’,
               ; and both the colon and at-sign flags.
‘"~,+4S"’      ;Here the first prefix parameter is omitted and takes
               ; on its default value, while the second parameter is ‘4’.

Figure 22.6: Examples of format control strings

‘format’ sends the output to DESTINATION.  If DESTINATION is ‘nil’,
‘format’ creates and returns a string containing the output from
CONTROL-STRING.  If DESTINATION is non-nil, it must be a string with a
fill pointer, a stream, or the symbol ‘t’.  If DESTINATION is a string
with a fill pointer, the output is added to the end of the string.  If
DESTINATION is a stream, the output is sent to that stream.  If
DESTINATION is ‘t’, the output is sent to standard output.

In the description of the directives that follows, the term arg in
general refers to the next item of the set of ARGS to be processed.
The word or phrase at the beginning of each description is a mnemonic
for the directive.  ‘format’ directives do not bind any of the printer
control variables (‘*print-...*’) except as specified in the following
descriptions.  Implementations may specify the binding of new,
implementation-specific printer control variables for each ‘format’
directive, but they may neither bind any standard printer control
variables not specified in description of a ‘format’ directive nor fail
to bind any standard printer control variables as specified in the
description.

* Menu:

* FORMAT Basic Output::
* FORMAT Radix Control::
* FORMAT Floating-Point Printers::
* FORMAT Printer Operations::
* FORMAT Pretty Printer Operations::
* FORMAT Layout Control::
* FORMAT Control-Flow Operations::
* FORMAT Miscellaneous Operations::
* FORMAT Miscellaneous Pseudo-Operations::
* Additional Information about FORMAT Operations::
* Examples of FORMAT::
* Notes about FORMAT::


File: ansicl,  Node: FORMAT Basic Output,  Next: FORMAT Radix Control,  Up: Formatted Output

22.3.1 FORMAT Basic Output
--------------------------

22.3.1.1 Tilde C: Character
...........................

The next arg should be a character; it is printed according to the
modifier flags.

‘~C’ prints the character as if by using ‘write-char’ if it is a simple
character.  Characters that are not simple are not necessarily printed
as if by ‘write-char’, but are displayed in an implementation-defined,
abbreviated format.  For example,

 (format nil "~C" #\A) → "A"
 (format nil "~C" #\Space) → " "

‘~:C’ is the same as ‘~C’ for printing characters, but other characters
are "spelled out."  The intent is that this is a "pretty" format for
printing characters.  For simple characters that are not printing, what
is spelled out is the name of the character (see ‘char-name’).  For
characters that are not simple and not printing, what is spelled out is
implementation-defined.  For example,

 (format nil "~:C" #\A) → "A"
 (format nil "~:C" #\Space) → "Space"
;; This next example assumes an implementation-defined "Control" attribute.
 (format nil "~:C" #\Control-Space)
→ "Control-Space"
or→ "c-Space"

‘~:@C’ prints what ‘~:C’ would, and then if the character requires
unusual shift keys on the keyboard to type it, this fact is mentioned.
For example,

 (format nil "~:@C" #\Control-Partial) → "Control-∂ (Top-F)"

This is the format used for telling the user about a key he is expected
to type, in prompts, for instance.  The precise output may depend not
only on the implementation, but on the particular I/O devices in use.

‘~@C’ prints the character in a way that the Lisp reader can understand,
using ‘#\’ syntax.

‘~@C’  binds ‘*print-escape*’ to ‘t’.

22.3.1.2 Tilde Percent: Newline
...............................

This outputs a ‘#\Newline’ character, thereby terminating the current
output line and beginning a new one.  ‘~n%’ outputs n newlines.  No arg
is used.

22.3.1.3 Tilde Ampersand: Fresh-Line
....................................

Unless it can be determined that the output stream is already at the
beginning of a line, this outputs a newline.  ‘~n&’ calls ‘fresh-line’
and then outputs n- 1 newlines.  ‘~0&’ does nothing.

22.3.1.4 Tilde Vertical-Bar: Page
.................................

This outputs a page separator character, if possible.  ‘~n|’ does this
n times.

22.3.1.5 Tilde Tilde: Tilde
...........................

This outputs a tilde.  ‘~n~’ outputs n tildes.


File: ansicl,  Node: FORMAT Radix Control,  Next: FORMAT Floating-Point Printers,  Prev: FORMAT Basic Output,  Up: Formatted Output

22.3.2 FORMAT Radix Control
---------------------------

22.3.2.1 Tilde R: Radix
.......................

‘~nR’ prints arg in radix n.  The modifier flags and any remaining
parameters are used as for the ‘~D’ directive.  ‘~D’ is the same as
‘~10R’.  The full form is
‘~radix,mincol,padchar,commachar,comma-intervalR’.

If no prefix parameters are given to ‘~R’, then a different
interpretation is given.  The argument should be an integer.  For
example, if arg is 4:

   * ‘~R’ prints arg as a cardinal English number: ‘four’.

   * ‘~:R’ prints arg as an ordinal English number: ‘fourth’.

   * ‘~@R’ prints arg as a Roman numeral: ‘IV’.

   * ‘~:@R’ prints arg as an old Roman numeral: ‘IIII’.

For example:

 (format nil "~,,' ,4:B" 13) → "1101"
 (format nil "~,,' ,4:B" 17) → "1 0001"
 (format nil "~19,0,' ,4:B" 3333) → "0000 1101 0000 0101"
 (format nil "~3,,,' ,2:R" 17) → "1 22"
 (format nil "~,,'|,2:D" #xFFFF) →  "6|55|35"

If and only if the first parameter, n, is supplied, ‘~R’ binds
‘*print-escape*’ to false, ‘*print-radix*’ to false, ‘*print-base*’ to
n, and ‘*print-readably*’ to false.

If and only if no parameters are supplied, ‘~R’ binds ‘*print-base*’ to
‘10’.

22.3.2.2 Tilde D: Decimal
.........................

An arg, which should be an integer, is printed in decimal radix.  ‘~D’
will never put a decimal point after the number.

‘~mincolD’ uses a column width of mincol; spaces are inserted on the
left if the number requires fewer than mincol columns for its digits
and sign.  If the number doesn't fit in mincol columns, additional
columns are used as needed.

‘~mincol,padcharD’ uses padchar as the pad character instead of space.

If arg is not an integer, it is printed in ‘~A’ format and decimal base.

The ‘@’ modifier causes the number's sign to be printed always; the
default is to print it only if the number is negative.  The ‘:’
modifier causes commas to be printed between groups of digits;
commachar may be used to change the character used as the comma.
comma-interval must be an integer and defaults to 3.  When the ‘:’
modifier is given to any of these directives, the commachar is printed
between groups of comma-interval digits.

Thus the most general form of ‘~D’ is
‘~mincol,padchar,commachar,comma-intervalD’.

‘~D’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘10’, and ‘*print-readably*’ to false.

22.3.2.3 Tilde B: Binary
........................

This is just like ‘~D’ but prints in binary radix (radix 2) instead of
decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalB’.

‘~B’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘2’, and ‘*print-readably*’ to false.

22.3.2.4 Tilde O: Octal
.......................

This is just like ‘~D’ but prints in octal radix (radix 8) instead of
decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalO’.

‘~O’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘8’, and ‘*print-readably*’ to false.

22.3.2.5 Tilde X: Hexadecimal
.............................

This is just like ‘~D’ but prints in hexadecimal radix (radix 16)
instead of decimal.  The full form is therefore
‘~mincol,padchar,commachar,comma-intervalX’.

‘~X’ binds ‘*print-escape*’ to false, ‘*print-radix*’ to false,
‘*print-base*’ to ‘16’, and ‘*print-readably*’ to false.


File: ansicl,  Node: FORMAT Floating-Point Printers,  Next: FORMAT Printer Operations,  Prev: FORMAT Radix Control,  Up: Formatted Output

22.3.3 FORMAT Floating-Point Printers
-------------------------------------

22.3.3.1 Tilde F: Fixed-Format Floating-Point
.............................................

The next arg is printed as a float.

The full form is ‘~w,d,k,overflowchar,padcharF’.  The parameter w is
the width of the field to be printed; d is the number of digits to
print after the decimal point; k is a scale factor that defaults to
zero.

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if
necessary, to pad the field on the left.  If the arg is negative, then
a minus sign is printed; if the arg is not negative, then a plus sign
is printed if and only if the ‘@’ modifier was supplied.  Then a
sequence of digits, containing a single embedded decimal point, is
printed; this represents the magnitude of the value of arg times 10^k,
rounded to d fractional digits.  When rounding up and rounding down
would produce printed values equidistant from the scaled value of arg,
then the implementation is free to use either one.  For example,
printing the argument ‘6.375’ using the format ‘~4,2F’ may correctly
produce either ‘6.37’ or ‘6.38’.  Leading zeros are not permitted,
except that a single zero digit is output before the decimal point if
the printed value is less than one, and this single zero digit is not
output at all if w=d+1.

If it is impossible to print the value in the required format in a field
of width w, then one of two actions is taken.  If the parameter
overflowchar is supplied, then w copies of that parameter are printed
instead of the scaled value of arg.  If the overflowchar parameter is
omitted, then the scaled value is printed using more than w characters,
as many more as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect, a value is chosen for w in such a way that no leading pad
characters need to be printed and exactly d characters will follow the
decimal point.  For example, the directive ‘~,2F’ will print exactly
two digits after the decimal point and as many as necessary before the
decimal point.

If the parameter d is omitted, then there is no constraint on the
number of digits to appear after the decimal point.  A value is chosen
for d in such a way that as many digits as possible may be printed
subject to the width constraint imposed by the parameter w and the
constraint that no trailing zero digits may appear in the fraction,
except that if the fraction to be printed is zero, then a single zero
digit should appear after the decimal point if permitted by the width
constraint.

If both w and d are omitted, then the effect is to print the value
using ordinary free-format output; ‘prin1’ uses this format for any
number whose magnitude is either zero or between 10^-3 (inclusive) and
10^7 (exclusive).

If w is omitted, then if the magnitude of arg is so large (or, if d is
also omitted, so small) that more than 100 digits would have to be
printed, then an implementation is free, at its discretion, to print
the number using exponential notation instead, as if by the directive
‘~E’ (with all parameters to ‘~E’ defaulted, not taking their values
from the ‘~F’ directive).

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are not supplied and the number has no exact
decimal representation, for example ‘1/3’, some precision cutoff must
be chosen by the implementation since only a finite number of digits
may be printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in
decimal radix and a minimum field width of w.

‘~F’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.2 Tilde E: Exponential Floating-Point
............................................

The next arg is printed as a float in exponential notation.

The full form is ‘~w,d,e,k,overflowchar,padchar,exponentcharE’.  The
parameter w is the width of the field to be printed; d is the number of
digits to print after the decimal point; e is the number of digits to
use when printing the exponent; k is a scale factor that defaults to
one (not zero).

Exactly w characters will be output.  First, leading copies of the
character padchar (which defaults to a space) are printed, if
necessary, to pad the field on the left.  If the arg is negative, then
a minus sign is printed; if the arg is not negative, then a plus sign
is printed if and only if the ‘@’ modifier was supplied.  Then a
sequence of digits containing a single embedded decimal point is
printed.  The form of this sequence of digits depends on the scale
factor k.  If k is zero, then d digits are printed after the decimal
point, and a single zero digit appears before the decimal point if the
total field width will permit it.  If k is positive, then it must be
strictly less than d+2;  k significant digits are printed before the
decimal point, and d- k+1 digits are printed after the decimal point.
If k is negative, then it must be strictly greater than - d; a single
zero digit appears before the decimal point if the total field width
will permit it, and after the decimal point are printed first - k zeros
and then d+k significant digits.  The printed fraction must be properly
rounded.  When rounding up and rounding down would produce printed
values equidistant from the scaled value of arg, then the implementation
is free to use either one.  For example, printing the argument ‘637.5’
using the format ‘~8,2E’ may correctly produce either ‘6.37E+2’ or
‘6.38E+2’.

Following the digit sequence, the exponent is printed.  First the
character parameter exponentchar is printed; if this parameter is
omitted, then the exponent marker that ‘prin1’ would use is printed, as
determined from the type of the float and the current value of
‘*read-default-float-format*’.  Next, either a plus sign or a minus sign
is printed, followed by e digits representing the power of ten by which
the printed fraction must be multiplied to properly represent the
rounded value of arg.

If it is impossible to print the value in the required format in a field
of width w, possibly because k is too large or too small or because the
exponent cannot be printed in e character positions, then one of two
actions is taken.  If the parameter overflowchar is supplied, then w
copies of that parameter are printed instead of the scaled value of arg.
If the overflowchar parameter is omitted, then the scaled value is
printed using more than w characters, as many more as may be needed; if
the problem is that d is too small for the supplied k or that e is too
small, then a larger value is used for d or e as may be needed.

If the w parameter is omitted, then the field is of variable width.  In
effect a value is chosen for w in such a way that no leading pad
characters need to be printed.

If the parameter d is omitted, then there is no constraint on the
number of digits to appear.  A value is chosen for d in such a way that
as many digits as possible may be printed subject to the width
constraint imposed by the parameter w, the constraint of the scale
factor k, and the constraint that no trailing zero digits may appear in
the fraction, except that if the fraction to be printed is zero then a
single zero digit should appear after the decimal point.

If the parameter e is omitted, then the exponent is printed using the
smallest number of digits necessary to represent its value.

If all of w, d, and e are omitted, then the effect is to print the
value using ordinary free-format exponential-notation output; ‘prin1’
uses a similar format for any non-zero number whose magnitude is less
than 10^-3 or greater than or equal to 10^7.  The only difference is
that the ‘~E’ directive always prints a plus or minus sign in front of
the exponent, while ‘prin1’ omits the plus sign if the exponent is
non-negative.

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.  If w and d are unsupplied and the number has no exact
decimal representation, for example ‘1/3’, some precision cutoff must
be chosen by the implementation since only a finite number of digits
may be printed.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in
decimal radix and a minimum field width of w.

‘~E’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.3 Tilde G: General Floating-Point
........................................

The next arg is printed as a float in either fixed-format or
exponential notation as appropriate.

The full form is ‘~w,d,e,k,overflowchar,padchar,exponentcharG’.  The
format in which to print arg depends on the magnitude (absolute value)
of the arg.  Let n be an integer such that 10^n-1 ≤ |arg| < 10^n.  Let
ee equal e+2, or 4 if e is omitted.  Let ww equal w- ee, or ‘nil’ if w
is omitted.  If d is omitted, first let q be the number of digits
needed to print arg with no loss of information and without leading or
trailing zeros; then let d equal ‘(max q (min n 7))’.  Let dd equal d-
n.

If 0 ≤ dd ≤ d, then arg is printed as if by the format directives

‘~ww,dd,,overflowchar,padcharF~ee@T’

Note that the scale factor k is not passed to the ‘~F’ directive.  For
all other values of dd, arg is printed as if by the format directive

‘~w,d,e,k,overflowchar,padchar,exponentcharE’

In either case, an ‘@’ modifier is supplied to the ‘~F’ or ‘~E’
directive if and only if one was supplied to the ‘~G’ directive.

‘~G’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.

22.3.3.4 Tilde Dollarsign: Monetary Floating-Point
..................................................

The next arg is printed as a float in fixed-format notation.

The full form is ‘~d,n,w,padchar$’.  The parameter d is the number of
digits to print after the decimal point (default value 2); n is the
minimum number of digits to print before the decimal point (default
value 1); w is the minimum total width of the field to be printed
(default value 0).

First padding and the sign are output.  If the arg is negative, then a
minus sign is printed; if the arg is not negative, then a plus sign is
printed if and only if the ‘@’ modifier was supplied.  If the ‘:’
modifier is used, the sign appears before any padding, and otherwise
after the padding.  If w is supplied and the number of other characters
to be output is less than w, then copies of padchar (which defaults to
a space) are output to make the total field width equal w.  Then n
digits are printed for the integer part of arg, with leading zeros if
necessary; then a decimal point; then d digits of fraction, properly
rounded.

If the magnitude of arg is so large that more than m digits would have
to be printed, where m is the larger of w and 100, then an
implementation is free, at its discretion, to print the number using
exponential notation instead, as if by the directive
‘~w,q,,,,padcharE’, where w and padchar are present or omitted
according to whether they were present or omitted in the ‘~$’
directive, and where q=d+n- 1, where d and n are the (possibly default)
values given to the ‘~$’ directive.

If arg is a rational number, then it is coerced to be a single float
and then printed.  Alternatively, an implementation is permitted to
process a rational number by any other method that has essentially the
same behavior but avoids loss of precision or overflow because of the
coercion.

If arg is a complex number or some non-numeric object, then it is
printed using the format directive ‘~wD’, thereby printing it in
decimal radix and a minimum field width of w.

‘~$’ binds ‘*print-escape*’ to false and ‘*print-readably*’ to false.


File: ansicl,  Node: FORMAT Printer Operations,  Next: FORMAT Pretty Printer Operations,  Prev: FORMAT Floating-Point Printers,  Up: Formatted Output

22.3.4 FORMAT Printer Operations
--------------------------------

22.3.4.1 Tilde A: Aesthetic
...........................

An arg, any object, is printed without escape characters (as by
‘princ’).  If arg is a string, its characters will be output verbatim.
If arg is ‘nil’ it will be printed as ‘nil’; the colon modifier (‘~:A’)
will cause an arg of ‘nil’ to be printed as (), but if arg is a
composite structure, such as a list or vector, any contained
occurrences of ‘nil’ will still be printed as ‘nil’.

‘~mincolA’ inserts spaces on the right, if necessary, to make the width
at least mincol columns.  The ‘@’ modifier causes the spaces to be
inserted on the left rather than the right.

‘~mincol,colinc,minpad,padcharA’ is the full form of ‘~A’, which allows
control of the padding.  The string is padded on the right (or on the
left if the ‘@’ modifier is used) with at least minpad copies of
padchar; padding characters are then inserted colinc characters at a
time until the total width is at least mincol.  The defaults are ‘0’
for mincol and minpad, ‘1’ for colinc, and the space character for
padchar.

‘~A’ binds ‘*print-escape*’ to false, and ‘*print-readably*’ to false.

22.3.4.2 Tilde S: Standard
..........................

This is just like ‘~A’, but arg is printed with escape characters (as
by ‘prin1’ rather than ‘princ’).  The output is therefore suitable for
input to ‘read’.  ‘~S’ accepts all the arguments and modifiers that
‘~A’ does.

‘~S’ binds ‘*print-escape*’ to ‘t’.

22.3.4.3 Tilde W: Write
.......................

An argument, any object, is printed obeying every printer control
variable (as by ‘write’).  In addition, ‘~W’ interacts correctly with
depth abbreviation, by not resetting the depth counter to zero.  ‘~W’
does not accept parameters.  If given the colon modifier, ‘~W’ binds
‘*print-pretty*’ to true.  If given the at-sign modifier, ‘~W’ binds
‘*print-level*’ and ‘*print-length*’ to ‘nil’.

‘~W’ provides automatic support for the detection of circularity and
sharing.  If the value of ‘*print-circle*’ is not ‘nil’ and ‘~W’ is
applied to an argument that is a circular (or shared) reference, an
appropriate ‘#N#’ marker is inserted in the output instead of printing
the argument.


File: ansicl,  Node: FORMAT Pretty Printer Operations,  Next: FORMAT Layout Control,  Prev: FORMAT Printer Operations,  Up: Formatted Output

22.3.5 FORMAT Pretty Printer Operations
---------------------------------------

The following constructs provide access to the pretty printer:

22.3.5.1 Tilde Underscore: Conditional Newline
..............................................

Without any modifiers, ‘~_’ is the same as ‘(pprint-newline :linear)’.
‘~@_’  is the same as ‘(pprint-newline :miser)’.  ‘~:_’  is the same as
‘(pprint-newline :fill)’.  ‘~:@_’ is the same as ‘(pprint-newline
:mandatory)’.

22.3.5.2 Tilde Less-Than-Sign: Logical Block
............................................

‘~<...~:>’

If ‘~:>’ is used to terminate a ‘~<...~>’, the directive is equivalent
to a call to ‘pprint-logical-block’.  The argument corresponding to the
‘~<...~:>’ directive is treated in the same way as the list argument to
‘pprint-logical-block’, thereby providing automatic support for
non-list arguments and the detection of circularity, sharing, and depth
abbreviation.  The portion of the CONTROL-STRING nested within the
‘~<...~:>’ specifies the :prefix (or :per-line-prefix), :suffix, and
body of the ‘pprint-logical-block’.

The CONTROL-STRING portion enclosed by ‘~<...~:>’ can be divided into
segments ‘~<PREFIX~;BODY~;SUFFIX~:>’ by ‘~;’ directives.  If the first
section is terminated by ‘~@;’, it specifies a per-line prefix rather
than a simple prefix.  The PREFIX and SUFFIX cannot contain format
directives.  An error is signaled if either the prefix or suffix fails
to be a constant string or if the enclosed portion is divided into more
than three segments.

If the enclosed portion is divided into only two segments, the SUFFIX
defaults to the null string.  If the enclosed portion consists of only
a single segment, both the PREFIX and the SUFFIX default to the null
string.  If the colon modifier is used (i.e., ‘~:<...~:>’), the PREFIX
and SUFFIX default to ‘"("’ and ‘")"’ (respectively) instead of the
null string.

The body segment can be any arbitrary format string.  This format
string is applied to the elements of the list corresponding to the
‘~<...~:>’ directive as a whole.  Elements are extracted from this list
using ‘pprint-pop’, thereby providing automatic support for malformed
lists, and the detection of circularity, sharing, and length
abbreviation.  Within the body segment, ‘~^’ acts like
‘pprint-exit-if-list-exhausted’.

‘~<...~:>’ supports a feature not supported by ‘pprint-logical-block’.
If ‘~:@>’ is used to terminate the directive (i.e., ‘~<...~:@>’), then
a fill-style conditional newline is automatically inserted after each
group of blanks immediately contained in the body (except for blanks
after a  <Newline> directive).  This makes it easy to achieve the
equivalent of paragraph filling.

If the at-sign modifier is used with ‘~<...~:>’, the entire remaining
argument list is passed to the directive as its argument.  All of the
remaining arguments are always consumed by ‘~@<...~:>’, even if they
are not all used by the format string nested in the directive.  Other
than the difference in its argument, ‘~@<...~:>’ is exactly the same as
‘~<...~:>’ except that circularity detection is not applied if
‘~@<...~:>’ is encountered at top level in a format string.  This
ensures that circularity detection is applied only to data lists, not
to format argument lists.

‘" . #N#"’ is printed if circularity or sharing has to be indicated for
its argument as a whole.

To a considerable extent, the basic form of the directive ‘~<...~>’ is
incompatible with the dynamic control of the arrangement of output by
‘~W’, ‘~_’, ‘~<...~:>’, ‘~I’, and ‘~:T’.  As a result, an error is
signaled if any of these directives is nested within ‘~<...~>’.  Beyond
this, an error is also signaled if the ‘~<...~:;...~>’ form of
‘~<...~>’ is used in the same format string with ‘~W’, ‘~_’,
‘~<...~:>’, ‘~I’, or ‘~:T’.

See also *note Section 22.3.6.2 (Tilde Less-Than-Sign. Justification):
TildeLessThanJustification.

22.3.5.3 Tilde I: Indent
........................

‘~NI’  is the same as ‘(pprint-indent :block n)’.

‘~N:I’ is the same as ‘(pprint-indent :current n)’.  In both cases, N
defaults to zero, if it is omitted.

22.3.5.4 Tilde Slash: Call Function
...................................

‘~/NAME/’

User defined functions can be called from within a format string by
using the directive ‘~/NAME/’.  The colon modifier, the at-sign
modifier, and arbitrarily many parameters can be specified with the
‘~/NAME/’ directive.  NAME can be any arbitrary string that does not
contain a "/".  All of the characters in NAME are treated as if they
were upper case.  If NAME contains a single colon (‘:’) or double colon
(‘::’), then everything up to but not including the first ‘":"’ or
‘"::"’ is taken to be a string that names a package.  Everything after
the first ‘":"’ or ‘"::"’ (if any) is taken to be a string that names a
‘symbol’.  The function corresponding to a ‘~/name/’ directive is
obtained by looking up the symbol that has the indicated name in the
indicated package.  If NAME does not contain a ‘":"’ or ‘"::"’, then
the whole NAME string is looked up in the ‘COMMON-LISP-USER’ package.

When a ‘~/name/’ directive is encountered, the indicated function is
called with four or more arguments.  The first four arguments are: the
output stream, the format argument corresponding to the directive, a
generalized boolean that is true if the colon modifier was used, and a
generalized boolean that is true if the at-sign modifier was used.  The
remaining arguments consist of any parameters specified with the
directive.  The function should print the argument appropriately.  Any
values returned by the function are ignored.

The three functions ‘pprint-linear’, ‘pprint-fill’, and ‘pprint-tabular’
are specifically designed so that they can be called by ‘~/.../’ (i.e.,
‘~/pprint-linear/’, ‘~/pprint-fill/’, and ‘~/pprint-tabular/’).  In
particular they take colon and at-sign arguments.


File: ansicl,  Node: FORMAT Layout Control,  Next: FORMAT Control-Flow Operations,  Prev: FORMAT Pretty Printer Operations,  Up: Formatted Output

22.3.6 FORMAT Layout Control
----------------------------

22.3.6.1 Tilde T: Tabulate
..........................

This spaces over to a given column.  ‘~colnum,colincT’ will output
sufficient spaces to move the cursor to column colnum.  If the cursor
is already at or beyond column colnum, it will output spaces to move it
to column colnum+k*colinc for the smallest positive integer k possible,
unless colinc is zero, in which case no spaces are output if the cursor
is already at or beyond column colnum.  colnum and colinc default to
‘1’.

If for some reason the current absolute column position cannot be
determined by direct inquiry, ‘format’ may be able to deduce the
current column position by noting that certain directives (such as
‘~%’, or ‘~&’, or ‘~A’ with the argument being a string containing a
newline) cause the column position to be reset to zero, and counting
the number of characters emitted since that point.  If that fails,
‘format’ may attempt a similar deduction on the riskier assumption that
the destination was at column zero when ‘format’ was invoked.  If even
this heuristic fails or is implementationally inconvenient, at worst
the ‘~T’ operation will simply output two spaces.

‘~@T’ performs relative tabulation.  ‘~colrel,colinc@T’ outputs colrel
spaces and then outputs the smallest non-negative number of additional
spaces necessary to move the cursor to a column that is a multiple of
colinc.  For example, the directive ‘~3,8@T’ outputs three spaces and
then moves the cursor to a "standard multiple-of-eight tab stop" if not
at one already.  If the current output column cannot be determined,
however, then colinc is ignored, and exactly colrel spaces are output.

If the colon modifier is used with the ‘~T’ directive, the tabbing
computation is done relative to the horizontal position where the
section immediately containing the directive begins, rather than with
respect to a horizontal position of zero.  The numerical parameters are
both interpreted as being in units of ems and both default to ‘1’.
‘~N,M:T’ is the same as ‘(pprint-tab :section N M)’.  ‘~N,M:@T’ is the
same as ‘(pprint-tab :section-relative N M)’.

22.3.6.2 Tilde Less-Than-Sign: Justification
............................................

‘~mincol,colinc,minpad,padchar<str~>’

This justifies the text produced by processing str within a field at
least mincol columns wide.  str may be divided up into segments with
‘~;’, in which case the spacing is evenly divided between the text
segments.

With no modifiers, the leftmost text segment is left justified in the
field, and the rightmost text segment is right justified.  If there is
only one text element, as a special case, it is right justified.  The
‘:’ modifier causes spacing to be introduced before the first text
segment;  the ‘@’ modifier causes spacing to be added after the last.
The minpad parameter (default ‘0’) is the minimum number of padding
characters to be output between each segment.  The padding character is
supplied by padchar, which defaults to the space character.  If the
total width needed to satisfy these constraints is greater than mincol,
then the width used is mincol+k*colinc for the smallest possible
non-negative integer value k.  colinc defaults to ‘1’, and mincol
defaults to ‘0’.

Note that str may include ‘format’ directives.  All the clauses in str
are processed in order; it is the resulting pieces of text that are
justified.

The ‘~^ ’ directive may be used to terminate processing of the clauses
prematurely, in which case only the completely processed clauses are
justified.

If the first clause of a ‘~<’ is terminated with ‘~:;’ instead of ‘~;’,
then it is used in a special way.  All of the clauses are processed
(subject to ‘~^ ’, of course), but the first one is not used in
performing the spacing and padding.  When the padded result has been
determined, then if it will fit on the current line of output, it is
output, and the text for the first clause is discarded.  If, however,
the padded text will not fit on the current line, then the text segment
for the first clause is output before the padded text.  The first clause
ought to contain a newline (such as a ‘~%’ directive).  The first
clause is always processed, and so any arguments it refers to will be
used; the decision is whether to use the resulting segment of text, not
whether to process the first clause.  If the ‘~:;’ has a prefix
parameter n, then the padded text must fit on the current line with n
character positions to spare to avoid outputting the first clause's
text.  For example, the control string

 "~%;; ~{ ~<~%;; ~1:; ~S~>~^ ,~} .~%"

can be used to print a list of items separated by commas without
breaking items over line boundaries, beginning each line with ‘;; ’.
The prefix parameter ‘1’ in ‘~1:;’ accounts for the width of the comma
that will follow the justified item if it is not the last element in
the list, or the period if it is.  If ‘~:;’ has a second prefix
parameter, then it is used as the width of the line, thus overriding
the natural line width of the output stream.  To make the preceding
example use a line width of 50, one would write

 "~%;; ~{ ~<~%;; ~1,50:; ~S~>~^ ,~}  .~%"

If the second argument is not supplied, then ‘format’ uses the line
width of the DESTINATION output stream.  If this cannot be determined
(for example, when producing a string result), then ‘format’ uses ‘72’
as the line length.

See also *note Section 22.3.5.2 (Tilde Less-Than-Sign. Logical Block):
TildeLessThanLogicalBlock.

22.3.6.3 Tilde Greater-Than-Sign: End of Justification
......................................................

‘~>’ terminates a ‘~<’.  The consequences of using it elsewhere are
undefined.


File: ansicl,  Node: FORMAT Control-Flow Operations,  Next: FORMAT Miscellaneous Operations,  Prev: FORMAT Layout Control,  Up: Formatted Output

22.3.7 FORMAT Control-Flow Operations
-------------------------------------

22.3.7.1 Tilde Asterisk: Go-To
..............................

The next arg is ignored.  ‘~n*’ ignores the next n arguments.

‘~:*’ backs up in the list of arguments so that the argument last
processed will be processed again.  ‘~n:*’ backs up n arguments.

When within a ‘~{’ construct (see below), the ignoring (in either
direction) is relative to the list of arguments being processed by the
iteration.

‘~n@*’ goes to the nth arg, where 0 means the first one; n defaults to
0, so ‘~@*’ goes back to the first arg.  Directives after a ‘~n@*’ will
take arguments in sequence beginning with the one gone to.  When within
a ‘~{’ construct, the "goto" is relative to the list of arguments being
processed by the iteration.

22.3.7.2 Tilde Left-Bracket: Conditional Expression
...................................................

‘~[str0~;str1~;...~;strn~]’

This is a set of control strings, called clauses, one of which is
chosen and used.  The clauses are separated by ‘~;’ and the construct
is terminated by ‘~]’.  For example,

‘"~[Siamese~;Manx~;Persian~] Cat"’

The argth clause is selected, where the first clause is number 0.  If a
prefix parameter is given (as ‘~n[’), then the parameter is used
instead of an argument.  If arg is out of range then no clause is
selected and no error is signaled.  After the selected alternative has
been processed, the control string continues after the ‘~]’.

‘~[str0~;str1~;...~;strn~:;default~]’ has a default case.  If the last
‘~;’ used to separate clauses is ‘~:;’ instead, then the last clause is
an else clause that is performed if no other clause is selected.  For
example:

‘"~[Siamese~;Manx~;Persian~:;Alley~] Cat"’

‘~:[ALTERNATIVE~;CONSEQUENT~]’ selects the ALTERNATIVE control string
if arg is false, and selects the CONSEQUENT control string otherwise.

‘~@[CONSEQUENT~]’ tests the argument.  If it is true, then the argument
is not used up by the ‘~[’ command but remains as the next one to be
processed, and the one clause CONSEQUENT is processed.  If the arg is
false, then the argument is used up, and the clause is not processed.
The clause therefore should normally use exactly one argument, and may
expect it to be non-nil.  For example:

 (setq *print-level* nil *print-length* 5)
 (format nil
        "~@[ print level = ~D~]~@[ print length = ~D~]"
        *print-level* *print-length*)
→  " print length = 5"

Note also that

 (format STREAM "...~@[STR~]..." ...)
≡ (format STREAM "...~:[~;~:*STR~]..." ...)

The combination of ‘~[’ and ‘#’ is useful, for example, for dealing
with English conventions for printing lists:

 (setq foo "Items:~#[ none~; ~S~; ~S and ~S~
           ~:;~@{~#[~; and~] ~S~^ ,~}~].")
 (format nil foo) →  "Items: none."
 (format nil foo 'foo) →  "Items: FOO."
 (format nil foo 'foo 'bar) →  "Items: FOO and BAR."
 (format nil foo 'foo 'bar 'baz) →  "Items: FOO, BAR, and BAZ."
 (format nil foo 'foo 'bar 'baz 'quux) →  "Items: FOO, BAR, BAZ, and QUUX."

22.3.7.3 Tilde Right-Bracket: End of Conditional Expression
...........................................................

‘~]’ terminates a ‘~[’.  The consequences of using it elsewhere are
undefined.

22.3.7.4 Tilde Left-Brace: Iteration
....................................

‘~{str~}’

This is an iteration construct.  The argument should be a list, which
is used as a set of arguments as if for a recursive call to ‘format’.
The string str is used repeatedly as the control string.  Each
iteration can absorb as many elements of the list as it likes as
arguments; if str uses up two arguments by itself, then two elements of
the list will get used up each time around the loop.  If before any
iteration step the list is empty, then the iteration is terminated.
Also, if a prefix parameter n is given, then there will be at most n
repetitions of processing of str.  Finally, the ‘~^ ’ directive can be
used to terminate the iteration prematurely.

For example:

 (format nil "The winners are:~{ ~S~}."
         '(fred harry jill))
→ "The winners are: FRED HARRY JILL."
 (format nil "Pairs:~{ <~S,~S>~}."
         '(a 1 b 2 c 3))
→ "Pairs: <A,1> <B,2> <C,3>."

‘~:{ str~}  ’ is similar, but the argument should be a list of sublists.
At each repetition step, one sublist is used as the set of arguments for
processing str; on the next repetition, a new sublist is used, whether
or not all of the last sublist had been processed.  For example:

 (format nil "Pairs:~:{ <~S,~S>~} ."
                 '((a 1) (b 2) (c 3)))
→ "Pairs: <A,1> <B,2> <C,3>."

‘~@{ str~} ’ is similar to ‘~{ str~}  ’, but instead of using one
argument that is a list, all the remaining arguments are used as the
list of arguments for the iteration.  Example:

 (format nil "Pairs:~@{ <~S,~S>~} ." 'a 1 'b 2 'c 3)
→ "Pairs: <A,1> <B,2> <C,3>."

If the iteration is terminated before all the remaining arguments are
consumed, then any arguments not processed by the iteration remain to be
processed by any directives following the iteration construct.

‘~:@{ str~}  ’ combines the features of ‘~:{ str~}  ’ and ‘~@{ str~}  ’.
All the remaining arguments are used, and each one must be a list.  On
each iteration, the next argument is used as a list of arguments to str.
Example:

 (format nil "Pairs:~:@{ <~S,~S>~} ."
              '(a 1) '(b 2) '(c 3))
→ "Pairs: <A,1> <B,2> <C,3>."

Terminating the repetition construct with ‘~:} ’ instead of ‘~}  ’
forces str to be processed at least once, even if the initial list of
arguments is null. However, this will not override an explicit prefix
parameter of zero.

If str is empty, then an argument is used as str.  It must be a format
control and precede any arguments processed by the iteration.  As an
example, the following are equivalent:

    (apply #'format stream string arguments)
 ≡ (format stream "~1{~:}" string arguments)

This will use ‘string’ as a formatting string.  The ‘~1{ ’ says it will
be processed at most once, and the ‘~:} ’ says it will be processed at
least once.  Therefore it is processed exactly once, using ‘arguments’
as the arguments.  This case may be handled more clearly by the ‘~?’
directive, but this general feature of ‘~{  ’ is more powerful than
‘~?’.

22.3.7.5 Tilde Right-Brace: End of Iteration
............................................

‘~}’ terminates a ‘~{’.  The consequences of using it elsewhere are
undefined.

22.3.7.6 Tilde Question-Mark: Recursive Processing
..................................................

The next arg must be a format control, and the one after it a list;
both are consumed by the ‘~?’ directive.  The two are processed as a
CONTROL-STRING, with the elements of the list as the arguments.  Once
the recursive processing has been finished, the processing of the
control string containing the ‘~?’ directive is resumed.  Example:

 (format nil "~? ~D" "<~A ~D>" '("Foo" 5) 7) → "<Foo 5> 7"
 (format nil "~? ~D" "<~A ~D>" '("Foo" 5 14) 7) → "<Foo 5> 7"

Note that in the second example three arguments are supplied to the
format string ‘"<~A ~D>"’, but only two are processed and the third is
therefore ignored.

With the ‘@’ modifier, only one arg is directly consumed.  The arg must
be a string; it is processed as part of the control string as if it had
appeared in place of the ‘~@?’ construct, and any directives in the
recursively processed control string may consume arguments of the
control string containing the ‘~@?’ directive.  Example:

 (format nil "~@? ~D" "<~A ~D>" "Foo" 5 7) → "<Foo 5> 7"
 (format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7) → "<Foo 5> 14"


File: ansicl,  Node: FORMAT Miscellaneous Operations,  Next: FORMAT Miscellaneous Pseudo-Operations,  Prev: FORMAT Control-Flow Operations,  Up: Formatted Output

22.3.8 FORMAT Miscellaneous Operations
--------------------------------------

22.3.8.1 Tilde Left-Paren: Case Conversion
..........................................

‘~(str~)’

The contained control string str is processed, and what it produces is
subject to case conversion.

With no flags, every uppercase character is converted to the
corresponding lowercase character.

‘~:(’ capitalizes all words, as if by ‘string-capitalize’.

‘~@(’ capitalizes just the first word and forces the rest to lower case.

‘~:@(’ converts every lowercase character to the corresponding
uppercase character.

In this example ‘~@(’ is used to cause the first word produced by ‘~@R’
to be capitalized:

 (format nil "~@R ~(~@R~)" 14 14)
→ "XIV xiv"
 (defun f (n) (format nil "~@(~R~) error~:P detected." n)) → F
 (f 0) → "Zero errors detected."
 (f 1) → "One error detected."
 (f 23) → "Twenty-three errors detected."

When case conversions appear nested, the outer conversion dominates, as
illustrated in the following example:

 (format nil "~@(how is ~:(BOB SMITH~)?~)")
 → "How is bob smith?"
 not→ "How is Bob Smith?"

22.3.8.2 Tilde Right-Paren: End of Case Conversion
..................................................

‘~)’ terminates a ‘~(’.  The consequences of using it elsewhere are
undefined.

22.3.8.3 Tilde P: Plural
........................

If arg is not ‘eql’ to the integer ‘1’, a lowercase ‘s’ is printed; if
arg is ‘eql’ to ‘1’, nothing is printed.  If arg is a floating-point
‘1.0’, the ‘s’ is printed.

‘~:P’ does the same thing, after doing a ‘~:*’ to back up one argument;
that is, it prints a lowercase ‘s’ if the previous argument was not ‘1’.

‘~@P’ prints ‘y’ if the argument is ‘1’, or ‘ies’ if it is not.  ‘~:@P’
does the same thing, but backs up first.

 (format nil "~D tr~:@P/~D win~:P" 7 1) → "7 tries/1 win"
 (format nil "~D tr~:@P/~D win~:P" 1 0) → "1 try/0 wins"
 (format nil "~D tr~:@P/~D win~:P" 1 3) → "1 try/3 wins"


File: ansicl,  Node: FORMAT Miscellaneous Pseudo-Operations,  Next: Additional Information about FORMAT Operations,  Prev: FORMAT Miscellaneous Operations,  Up: Formatted Output

22.3.9 FORMAT Miscellaneous Pseudo-Operations
---------------------------------------------

22.3.9.1 Tilde Semicolon: Clause Separator
..........................................

This separates clauses in ‘~[’ and ‘~<’ constructs.  The consequences
of using it elsewhere are undefined.

22.3.9.2 Tilde Circumflex: Escape Upward
........................................

‘~^ ’

This is an escape construct.  If there are no more arguments remaining
to be processed, then the immediately enclosing ‘~{  ’ or ‘~<’ construct
is terminated.  If there is no such enclosing construct, then the entire
formatting operation is terminated.  In the ‘~<’ case, the formatting
is performed, but no more segments are processed before doing the
justification.  ‘~^ ’ may appear anywhere in a ‘~{  ’ construct.

 (setq donestr "Done.~^ ~D warning~:P.~^ ~D error~:P.")
→ "Done.~^ ~D warning~:P.~^ ~D error~:P."
 (format nil donestr) → "Done."
 (format nil donestr 3) → "Done. 3 warnings."
 (format nil donestr 1 5) → "Done. 1 warning. 5 errors."

If a prefix parameter is given, then termination occurs if the parameter
is zero.  (Hence ‘~^’ is equivalent to ‘~#^’.)  If two parameters are
given, termination occurs if they are equal.    If three parameters are
given, termination occurs if the first is less than or equal to the
second and the second is less than or equal to the third.  Of course,
this is useless if all the prefix parameters are constants; at least
one of them should be a ‘#’ or a ‘V’ parameter.

If ‘~^’ is used within a ‘~:{  ’ construct, then it terminates the
current iteration step because in the standard case it tests for
remaining arguments of the current step only; the next iteration step
commences immediately.  ‘~:^’ is used to terminate the iteration
process.  ‘~:^’ may be used only if the command it would terminate is
‘~:{  ’ or ‘~:@{  ’.  The entire iteration process is terminated if and
only if the sublist that is supplying the arguments for the current
iteration step is the last sublist in the case of ‘~:{ ’, or the last
‘format’ argument in the case of ‘~:@{  ’.  ‘~:^’ is not equivalent to
‘~#:^’; the latter terminates the entire iteration if and only if no
arguments remain for the current iteration step.  For example:

 (format nil "~:{ ~@?~:^ ...~} " '(("a") ("b"))) → "a...b"

If ‘~^’ appears within a control string being processed under the
control of a ‘~?’ directive, but not within any ‘~{  ’ or ‘~<’
construct within that string, then the string being processed will be
terminated, thereby ending processing of the ‘~?’ directive.
Processing then continues within the string containing the ‘~?’
directive at the point following that directive.

If ‘~^’ appears within a ‘~[’ or ‘~(’ construct, then all the commands
up to the ‘~^’ are properly selected or case-converted, the ‘~[’ or
‘~(’ processing is terminated, and the outward search continues for a
‘~{  ’ or ‘~<’ construct to be terminated.  For example:

 (setq tellstr "~@(~@[~R~]~^ ~A!~)")
→ "~@(~@[~R~]~^ ~A!~)"
 (format nil tellstr 23) → "Twenty-three!"
 (format nil tellstr nil "losers") → " Losers!"
 (format nil tellstr 23 "losers") → "Twenty-three losers!"

Following are examples of the use of ‘~^’ within a ‘~<’ construct.

 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo)
→  "            FOO"
 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar)
→  "FOO         BAR"
 (format nil "~15<~S~;~^~S~;~^~S~>" 'foo 'bar 'baz)
→  "FOO   BAR   BAZ"

22.3.9.3 Tilde Newline: Ignored Newline
.......................................

Tilde immediately followed by a newline ignores the newline and any
following non-newline whitespace₁ characters.  With a ‘:’, the newline
is ignored, but any following whitespace₁ is left in place.  With an
‘@’, the newline is left in place, but any following whitespace₁ is
ignored.  For example:

 (defun type-clash-error (fn nargs argnum right-type wrong-type)
   (format *error-output*
           "~&~S requires its ~:[~:R~;~*~]~
           argument to be of type ~S,~%but it was called ~
           with an argument of type ~S.~%"
           fn (eql nargs 1) argnum right-type wrong-type))
 (type-clash-error 'aref nil 2 'integer 'vector)  prints:
AREF requires its second argument to be of type INTEGER,
but it was called with an argument of type VECTOR.
NIL
 (type-clash-error 'car 1 1 'list 'short-float)  prints:
CAR requires its argument to be of type LIST,
but it was called with an argument of type SHORT-FLOAT.
NIL

Note that in this example newlines appear in the output only as
specified by the ‘~&’ and ‘~%’ directives; the actual newline characters
in the control string are suppressed because each is preceded by a
tilde.


File: ansicl,  Node: Additional Information about FORMAT Operations,  Next: Examples of FORMAT,  Prev: FORMAT Miscellaneous Pseudo-Operations,  Up: Formatted Output

22.3.10 Additional Information about FORMAT Operations
------------------------------------------------------

22.3.10.1 Nesting of FORMAT Operations
......................................

The case-conversion, conditional, iteration, and justification
constructs can contain other formatting constructs by bracketing them.
These constructs must nest properly with respect to each other.  For
example, it is not legitimate to put the start of a case-conversion
construct in each arm of a conditional and the end of the
case-conversion construct outside the conditional:

 (format nil "~:[abc~:@(def~;ghi~
:@(jkl~]mno~)" x) ;Invalid!

This notation is invalid because the ‘~[...~;...~]’ and ‘~(...~)’
constructs are not properly nested.

The processing indirection caused by the ‘~?’ directive is also a kind
of nesting for the purposes of this rule of proper nesting.  It is not
permitted to start a bracketing construct within a string processed
under control of a ‘~?’ directive and end the construct at some point
after the ‘~?’ construct in the string containing that construct, or
vice versa.  For example, this situation is invalid:

 (format nil "~@?ghi~)" "abc~@(def") ;Invalid!

This notation is invalid because the ‘~?’ and ‘~(...~)’ constructs are
not properly nested.

22.3.10.2 Missing and Additional FORMAT Arguments
.................................................

The consequences are undefined if no ARG remains for a directive
requiring an argument.  However, it is permissible for one or more ARGS
to remain unprocessed by a directive; such ARGS are ignored.

22.3.10.3 Additional FORMAT Parameters
......................................

The consequences are undefined if a format directive is given more
parameters than it is described here as accepting.

22.3.10.4 Undefined FORMAT Modifier Combinations
................................................

The consequences are undefined if colon or at-sign modifiers are given
to a directive in a combination not specifically described here as
being meaningful.


File: ansicl,  Node: Examples of FORMAT,  Next: Notes about FORMAT,  Prev: Additional Information about FORMAT Operations,  Up: Formatted Output

22.3.11 Examples of FORMAT
--------------------------

 (format nil "foo") → "foo"
 (setq x 5) → 5
 (format nil "The answer is ~D." x) → "The answer is 5."
 (format nil "The answer is ~3D." x) → "The answer is   5."
 (format nil "The answer is ~3,'0D." x) → "The answer is 005."
 (format nil "The answer is ~:D." (expt 47 x))
→ "The answer is 229,345,007."
 (setq y "elephant") → "elephant"
 (format nil "Look at the ~A!" y) → "Look at the elephant!"
 (setq n 3) → 3
 (format nil "~D item~:P found." n) → "3 items found."
 (format nil "~R dog~:[s are~; is~] here." n (= n 1))
→ "three dogs are here."
 (format nil "~R dog~:*~[s are~; is~:;s are~] here." n)
→ "three dogs are here."
 (format nil "Here ~[are~;is~:;are~] ~:*~R pupp~:@P." n)
→ "Here are three puppies."

 (defun foo (x)
   (format nil "~6,2F|~6,2,1,'*F|~6,2,,'?F|~6F|~,2F|~F"
           x x x x x x)) → FOO
 (foo 3.14159)  → "  3.14| 31.42|  3.14|3.1416|3.14|3.14159"
 (foo -3.14159) → " -3.14|-31.42| -3.14|-3.142|-3.14|-3.14159"
 (foo 100.0)    → "100.00|******|100.00| 100.0|100.00|100.0"
 (foo 1234.0)   → "1234.00|******|??????|1234.0|1234.00|1234.0"
 (foo 0.006)    → "  0.01|  0.06|  0.01| 0.006|0.01|0.006"

 (defun foo (x)
    (format nil
           "~9,2,1,,'*E|~10,3,2,2,'?,,'$E|~
            ~9,3,2,-2,'%@E|~9,2E"
           x x x x))
 (foo 3.14159)  → "  3.14E+0| 31.42$-01|+.003E+03|  3.14E+0"
 (foo -3.14159) → " -3.14E+0|-31.42$-01|-.003E+03| -3.14E+0"
 (foo 1100.0)   → "  1.10E+3| 11.00$+02|+.001E+06|  1.10E+3"
 (foo 1100.0L0) → "  1.10L+3| 11.00$+02|+.001L+06|  1.10L+3"
 (foo 1.1E13)   → "*********| 11.00$+12|+.001E+16| 1.10E+13"
 (foo 1.1L120)  → "*********|??????????|%%%%%%%%%|1.10L+120"
 (foo 1.1L1200) → "*********|??????????|%%%%%%%%%|1.10L+1200"

As an example of the effects of varying the scale factor, the code

 (dotimes (k 13)
   (format t "~%Scale factor ~2D: |~13,6,2,VE|"
           (- k 5) (- k 5) 3.14159))

produces the following output:

Scale factor -5: | 0.000003E+06|
Scale factor -4: | 0.000031E+05|
Scale factor -3: | 0.000314E+04|
Scale factor -2: | 0.003142E+03|
Scale factor -1: | 0.031416E+02|
Scale factor  0: | 0.314159E+01|
Scale factor  1: | 3.141590E+00|
Scale factor  2: | 31.41590E-01|
Scale factor  3: | 314.1590E-02|
Scale factor  4: | 3141.590E-03|
Scale factor  5: | 31415.90E-04|
Scale factor  6: | 314159.0E-05|
Scale factor  7: | 3141590.E-06|

 (defun foo (x)
   (format nil "~9,2,1,,'*G|~9,3,2,3,'?,,'$G|~9,3,2,0,'%G|~9,2G"
          x x x x))
 (foo 0.0314159) → "  3.14E-2|314.2$-04|0.314E-01|  3.14E-2"
 (foo 0.314159)  → "  0.31   |0.314    |0.314    | 0.31    "
 (foo 3.14159)   → "   3.1   | 3.14    | 3.14    |  3.1    "
 (foo 31.4159)   → "   31.   | 31.4    | 31.4    |  31.    "
 (foo 314.159)   → "  3.14E+2| 314.    | 314.    |  3.14E+2"
 (foo 3141.59)   → "  3.14E+3|314.2$+01|0.314E+04|  3.14E+3"
 (foo 3141.59L0) → "  3.14L+3|314.2$+01|0.314L+04|  3.14L+3"
 (foo 3.14E12)   → "*********|314.0$+10|0.314E+13| 3.14E+12"
 (foo 3.14L120)  → "*********|?????????|%%%%%%%%%|3.14L+120"
 (foo 3.14L1200) → "*********|?????????|%%%%%%%%%|3.14L+1200"

 (format nil "~10<foo~;bar~>")   → "foo    bar"
 (format nil "~10:<foo~;bar~>")  → "  foo  bar"
 (format nil "~10<foobar~>")     → "    foobar"
 (format nil "~10:<foobar~>")    → "    foobar"
 (format nil "~10:@<foo~;bar~>") → "  foo bar "
 (format nil "~10@<foobar~>")    → "foobar    "
 (format nil "~10:@<foobar~>")   → "  foobar  "

  (FORMAT NIL "Written to ~A." #P"foo.bin")
  → "Written to foo.bin."


File: ansicl,  Node: Notes about FORMAT,  Prev: Examples of FORMAT,  Up: Formatted Output

22.3.12 Notes about FORMAT
--------------------------

Formatted output is performed not only by ‘format’, but by certain
other functions that accept a format control the way ‘format’ does.
For example, error-signaling functions such as ‘cerror’ accept format
controls.

Note that the meaning of ‘nil’ and ‘t’ as destinations to ‘format’ are
different than those of ‘nil’ and ‘t’ as stream designators.

The ‘~^’ should appear only at the beginning of a ‘~<’ clause, because
it aborts the entire clause in which it appears (as well as all
following clauses).


File: ansicl,  Node: copy-pprint-dispatch,  Next: formatter,  Prev: Formatted Output,  Up: Printer

copy-pprint-dispatch (Function)
===============================

Syntax:
.......

 -- Function: copy-pprint-dispatch &optional table → new-table

Arguments and Values:
.....................

TABLE--a pprint dispatch table, or ‘nil’.

NEW-TABLE--a fresh pprint dispatch table.

Description:
............

Creates and returns a copy of the specified TABLE, or of the value of
‘*print-pprint-dispatch*’ if no TABLE is specified, or of the initial
value of ‘*print-pprint-dispatch*’ if ‘nil’ is specified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if TABLE is not a pprint
dispatch table.


File: ansicl,  Node: formatter,  Next: pprint-dispatch,  Prev: copy-pprint-dispatch,  Up: Printer

formatter (Macro)
=================

Syntax:
.......

 -- Macro: formatter control-string → function

Arguments and Values:
.....................

CONTROL-STRING--a format string; not evaluated.

FUNCTION--a function.

Description:
............

Returns a function which has behavior equivalent to:

  #'(lambda (*standard-output* &rest arguments)
      (apply #'format t control-string arguments)
      arguments-tail)

where arguments-tail is either the tail of arguments which has as its
car the argument that would be processed next if there were more format
directives in the CONTROL-STRING, or else ‘nil’ if no more arguments
follow the most recently processed argument.

Examples:
.........

(funcall (formatter "~&~A~A") *standard-output* 'a 'b 'c)
▷ AB
→ (C)

(format t (formatter "~&~A~A") 'a 'b 'c)
▷ AB
→ NIL

Exceptional Situations:
.......................

Might signal an error (at macro expansion time or at run time) if the
argument is not a valid format string.

See Also:
.........

*note format::


File: ansicl,  Node: pprint-dispatch,  Next: pprint-exit-if-list-exhausted,  Prev: formatter,  Up: Printer

pprint-dispatch (Function)
==========================

Syntax:
.......

 -- Function: pprint-dispatch object &optional table → function, found-p

Arguments and Values:
.....................

OBJECT--an object.

TABLE--a pprint dispatch table, or ‘nil’.  The default is the value of
‘*print-pprint-dispatch*’.

FUNCTION--a function designator.

FOUND-P--a generalized boolean.

Description:
............

Retrieves the highest priority function in TABLE that is associated
with a type specifier that matches OBJECT.  The function is chosen by
finding all of the type specifiers in TABLE that match the OBJECT and
selecting the highest priority function associated with any of these
type specifiers.  If there is more than one highest priority function,
an arbitrary choice is made.  If no type specifiers match the OBJECT, a
function is returned that prints OBJECT using ‘print-object’.

The secondary value, FOUND-P, is true if a matching type specifier was
found in TABLE, or false otherwise.

If TABLE is ‘nil’, retrieval is done in the initial pprint dispatch
table.

Affected By:
............

The state of the TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if table is neither a
pprint-dispatch-table nor ‘nil’.

Notes:
......

(let ((*print-pretty* t))
  (write object :stream s))
≡ (funcall (pprint-dispatch object) s object)


File: ansicl,  Node: pprint-exit-if-list-exhausted,  Next: pprint-fill; pprint-linear; pprint-tabular,  Prev: pprint-dispatch,  Up: Printer

pprint-exit-if-list-exhausted (Local Macro)
===========================================

Syntax:
.......

 -- Macro: pprint-exit-if-list-exhausted <no arguments> → ‘nil’

Description:
............

Tests whether or not the LIST passed to the lexically current logical
block has been exhausted; see *note Section 22.2.1.1 (Dynamic Control
of the Arrangement of Output): DynamicControlofOutput.  If this LIST
has been reduced to ‘nil’, ‘pprint-exit-if-list-exhausted’ terminates
the execution of the lexically current logical block except for the
printing of the suffix.  Otherwise ‘pprint-exit-if-list-exhausted’
returns ‘nil’.

Whether or not ‘pprint-exit-if-list-exhausted’ is fbound in the global
environment is implementation-dependent; however, the restrictions on
redefinition and shadowing of ‘pprint-exit-if-list-exhausted’ are the
same as for symbols in the ‘COMMON-LISP’ package which are fbound in
the global environment.  The consequences of attempting to use
‘pprint-exit-if-list-exhausted’ outside of ‘pprint-logical-block’ are
undefined.

Exceptional Situations:
.......................

An error is signaled (at macro expansion time or at run time) if
‘pprint-exit-if-list-exhausted’ is used anywhere other than lexically
within a call on ‘pprint-logical-block’.  Also, the consequences of
executing ‘pprint-if-list-exhausted’ outside of the dynamic extent of
the ‘pprint-logical-block’ which lexically contains it are undefined.

See Also:
.........

*note pprint-logical-block::, *note pprint-pop::.


File: ansicl,  Node: pprint-fill; pprint-linear; pprint-tabular,  Next: pprint-indent,  Prev: pprint-exit-if-list-exhausted,  Up: Printer

pprint-fill, pprint-linear, pprint-tabular (Function)
=====================================================

Syntax:
.......

 -- Function: pprint-fill stream object &optional colon-p at-sign-p →
          ‘nil’

 -- Function: pprint-linear stream object &optional colon-p at-sign-p →
          ‘nil’

 -- Function: pprint-tabular stream object &optional colon-p at-sign-p
          tabsize → ‘nil’

Arguments and Values:
.....................

STREAM--an output stream designator.

OBJECT--an object.

COLON-P--a generalized boolean.  The default is true.

AT-SIGN-P--a generalized boolean.  The default is
implementation-dependent.

TABSIZE--a non-negative integer.  The default is ‘16’.

Description:
............

The functions ‘pprint-fill’, ‘pprint-linear’, and ‘pprint-tabular’
specify particular ways of pretty printing a list to STREAM.  Each
function prints parentheses around the output if and only if COLON-P is
true.  Each function ignores its AT-SIGN-P argument.  (Both arguments
are included even though only one is needed so that these functions can
be used via `~/.../' and as ‘set-pprint-dispatch’ functions, as well as
directly.)  Each function handles abbreviation and the detection of
circularity and sharing correctly, and uses ‘write’ to print OBJECT
when it is a non-list.

If OBJECT is a list and if the value of ‘*print-pretty*’ is false, each
of these functions prints OBJECT using a minimum of whitespace, as
described in *note Section 22.1.3.5 (Printing Lists and Conses):
PrintingListsAndConses.  Otherwise (if OBJECT is a list and if the
value of ‘*print-pretty*’ is true):

   * The function ‘pprint-linear’ prints a list either all on one line,
     or with each element on a separate line.

   * The function ‘pprint-fill’ prints a list with as many elements as
     possible on each line.

   * The function ‘pprint-tabular’ is the same as ‘pprint-fill’ except
     that it prints the elements so that they line up in columns.  The
     TABSIZE specifies the column spacing in ems, which is the total
     spacing from the leading edge of one column to the leading edge of
     the next.

Examples:
.........

Evaluating the following with a line length of ‘25’ produces the output
shown.

(progn (princ "Roads ")
       (pprint-tabular *standard-output* '(elm main maple center) nil nil 8))
Roads ELM     MAIN
      MAPLE   CENTER

Side Effects:
.............

Performs output to the indicated stream.

Affected By:
............

The cursor position on the indicated stream, if it can be determined.

Notes:
......

The function ‘pprint-tabular’ could be defined as follows:

(defun pprint-tabular (s list &optional (colon-p t) at-sign-p (tabsize nil))
  (declare (ignore at-sign-p))
  (when (null tabsize) (setq tabsize 16))
  (pprint-logical-block (s list :prefix (if colon-p "(" "")
                                :suffix (if colon-p ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write (pprint-pop) :stream s)
          (pprint-exit-if-list-exhausted)
          (write-char #\Space s)
          (pprint-tab :section-relative 0 tabsize s)
          (pprint-newline :fill s))))

Note that it would have been inconvenient to specify this function
using ‘format’, because of the need to pass its TABSIZE argument
through to a `~:T' format directive nested within an iteration over a
list.


File: ansicl,  Node: pprint-indent,  Next: pprint-logical-block,  Prev: pprint-fill; pprint-linear; pprint-tabular,  Up: Printer

pprint-indent (Function)
========================

Syntax:
.......

 -- Function: pprint-indent relative-to n &optional stream → ‘nil’

Arguments and Values:
.....................

RELATIVE-TO--either :block or :current.

N--a real.

STREAM--an output stream designator.  The default is standard output.

Description:
............

‘pprint-indent’ specifies the indentation to use in a logical block on
stream.  If STREAM is a pretty printing stream and the value of
‘*print-pretty*’ is true, ‘pprint-indent’ sets the indentation in the
innermost dynamically enclosing logical block; otherwise,
‘pprint-indent’ has no effect.

N specifies the indentation in ems.  If RELATIVE-TO is :block, the
indentation is set to the horizontal position of the first character in
the dynamically current logical block plus N ems. If RELATIVE-TO is
:current, the indentation is set to the current output position plus N
ems. (For robustness in the face of variable-width fonts, it is
advisable to use :current with an N of zero whenever possible.)

N can be negative; however, the total indentation cannot be moved left
of the beginning of the line or left of the end of the rightmost
per-line prefix--an attempt to move beyond one of these limits is
treated the same as an attempt to move to that limit.  Changes in
indentation caused by PPRINT-INDENT do not take effect until after the
next line break.  In addition, in miser mode all calls to
‘pprint-indent’ are ignored, forcing the lines corresponding to the
logical block to line up under the first character in the block.

Exceptional Situations:
.......................

An error is signaled if RELATIVE-TO is any object other than :block or
:current.

See Also:
.........

*note Section 22.3.5.3 (Tilde I. Indent): TildeI.


File: ansicl,  Node: pprint-logical-block,  Next: pprint-newline,  Prev: pprint-indent,  Up: Printer

pprint-logical-block (Macro)
============================

Syntax:
.......

 -- Macro: pprint-logical-block
          (stream-symbol object  &key prefix per-line-prefix suffix)
          {declaration}* {form}* → ‘nil’

Arguments and Values:
.....................

STREAM-SYMBOL--a stream variable designator.

OBJECT--an object; evaluated.

:prefix--a string; evaluated.  Complicated defaulting behavior; see
below.

:per-line-prefix--a string; evaluated.  Complicated defaulting
behavior; see below.

:suffix--a string; evaluated.  The default is the null string.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

Description:
............

Causes printing to be grouped into a logical block.

The logical block is printed to the stream that is the value of the
variable denoted by STREAM-SYMBOL.  During the execution of the forms,
that variable is bound to a pretty printing stream that supports
decisions about the arrangement of output and then forwards the output
to the destination stream.  All the standard printing functions (e.g.,
‘write’, ‘princ’, and ‘terpri’) can be used to print output to the
pretty printing stream.  All and only the output sent to this pretty
printing stream is treated as being in the logical block.

The PREFIX specifies a prefix to be printed before the beginning of the
logical block.  The PER-LINE-PREFIX specifies a prefix that is printed
before the block and at the beginning of each new line in the block.
The :prefix and :pre-line-prefix arguments are mutually exclusive.  If
neither :prefix nor :per-line-prefix is specified, a PREFIX of the null
string is assumed.

The SUFFIX specifies a suffix that is printed just after the logical
block.

The OBJECT is normally a list that the body FORMS are responsible for
printing.  If OBJECT is not a list, it is printed using ‘write’.  (This
makes it easier to write printing functions that are robust in the face
of malformed arguments.)  If ‘*print-circle*’ is non-nil and OBJECT is
a circular (or shared) reference to a cons, then an appropriate "‘#n#’"
marker is printed.  (This makes it easy to write printing functions
that provide full support for circularity and sharing abbreviation.)
If ‘*print-level*’ is not ‘nil’ and the logical block is at a dynamic
nesting depth of greater than ‘*print-level*’ in logical blocks, "‘#’"
is printed.  (This makes easy to write printing functions that provide
full support for depth abbreviation.)

If either of the three conditions above occurs, the indicated output is
printed on STREAM-SYMBOL and the body FORMS are skipped along with the
printing of the :prefix and :suffix.  (If the body FORMS are not to be
responsible for printing a list, then the first two tests above can be
turned off by supplying ‘nil’ for the OBJECT argument.)

In addition to the OBJECT argument of ‘pprint-logical-block’, the
arguments of the standard printing functions (such as ‘write’, ‘print’,
‘prin1’, and ‘pprint’, as well as the arguments of the standard format
directives such as `~A', `~S', (and `~W') are all checked (when
necessary) for circularity and sharing.  However, such checking is not
applied to the arguments of the functions ‘write-line’, ‘write-string’,
and ‘write-char’ or to the literal text output by ‘format’.  A
consequence of this is that you must use one of the latter functions if
you want to print some literal text in the output that is not supposed
to be checked for circularity or sharing.

The body FORMS of a ‘pprint-logical-block’ form must not perform any
side-effects on the surrounding environment; for example, no variables
must be assigned which have not been bound within its scope.

The ‘pprint-logical-block’ macro may be used regardless of the value of
‘*print-pretty*’.

Affected By:
............

‘*print-circle*’, ‘*print-level*’.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if any of the :suffix,
:prefix, or :per-line-prefix is supplied but does not evaluate to a
string.

An error is signaled if :prefix and :pre-line-prefix are both used.

‘pprint-logical-block’ and the pretty printing stream it creates have
dynamic extent.  The consequences are undefined if, outside of this
extent, output is attempted to the pretty printing stream it creates.

It is also unspecified what happens if, within this extent, any output
is sent directly to the underlying destination stream.

See Also:
.........

*note pprint-pop::, *note pprint-exit-if-list-exhausted::, *note
Section 22.3.5.2 (Tilde Less-Than-Sign. Logical Block):
TildeLessThanLogicalBlock.

Notes:
......

One reason for using the ‘pprint-logical-block’ macro when the value of
‘*print-pretty*’ is ‘nil’ would be to allow it to perform checking for
dotted lists, as well as (in conjunction with ‘pprint-pop’) checking
for ‘*print-level*’ or ‘*print-length*’ being exceeded.

Detection of circularity and sharing is supported by the pretty printer
by in essence performing requested output twice.  On the first pass,
circularities and sharing are detected and the actual outputting of
characters is suppressed.  On the second pass, the appropriate "‘#N=’"
and "‘#N#’" markers are inserted and characters are output.  This is
why the restriction on side-effects is necessary.  Obeying this
restriction is facilitated by using ‘pprint-pop’, instead of an
ordinary ‘pop’ when traversing a list being printed by the body FORMS
of the ‘pprint-logical-block’ form.)


File: ansicl,  Node: pprint-newline,  Next: pprint-pop,  Prev: pprint-logical-block,  Up: Printer

pprint-newline (Function)
=========================

Syntax:
.......

 -- Function: pprint-newline kind &optional stream → ‘nil’

Arguments and Values:
.....................

KIND--one of :linear, :fill, :miser, or :mandatory.

STREAM--a stream designator.  The default is standard output.

Description:
............

If STREAM is a pretty printing stream and the value of ‘*print-pretty*’
is true, a line break is inserted in the output when the appropriate
condition below is satisfied; otherwise, ‘pprint-newline’ has no effect.

KIND specifies the style of conditional newline.  This parameter is
treated as follows:

:linear
     This specifies a "linear-style" conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line.  The effect of this is that line
     breaks are either inserted at every linear-style conditional
     newline in a logical block or at none of them.

:miser
     This specifies a "miser-style" conditional newline.  A line break
     is inserted if and only if the immediately containing section
     cannot be printed on one line and miser style is in effect in the
     immediately containing logical block.  The effect of this is that
     miser-style conditional newlines act like linear-style conditional
     newlines, but only when miser style is in effect.  Miser style is
     in effect for a logical block if and only if the starting position
     of the logical block is less than or equal to
     ‘*print-miser-width*’ ems from the right margin.

:fill
     This specifies a "fill-style" conditional newline.  A line break
     is inserted if and only if either (a) the following section cannot
     be printed on the end of the current line, (b) the preceding
     section was not printed on a single line, or (c) the immediately
     containing section cannot be printed on one line and miser style
     is in effect in the immediately containing logical block.  If a
     logical block is broken up into a number of subsections by
     fill-style conditional newlines, the basic effect is that the
     logical block is printed with as many subsections as possible on
     each line.  However, if miser style is in effect, fill-style
     conditional newlines act like linear-style conditional newlines.

:mandatory
     This specifies a "mandatory-style" conditional newline.  A line
     break is always inserted.  This implies that  none of the
     containing sections can be printed on a single line and will
     therefore trigger the insertion of line breaks at linear-style
     conditional newlines in these sections.

When a line break is inserted by any type of conditional newline, any
blanks that immediately precede the conditional newline are omitted
from the output and indentation is introduced at the beginning of the
next line.  By default, the indentation causes the following line to
begin in the same horizontal position as the first character in the
immediately containing logical block.  (The indentation can be changed
via ‘pprint-indent’.)

There are a variety of ways unconditional newlines can be introduced
into the output (i.e., via ‘terpri’ or by printing a string containing
a newline character).  As with mandatory conditional newlines, this
prevents any of the containing sections from being printed on one line.
In general, when an unconditional newline is encountered, it is printed
out without suppression of the preceding blanks and without any
indentation following it.  However, if a per-line prefix has been
specified (see ‘pprint-logical-block’), this prefix will always be
printed no matter how a newline originates.

Examples:
.........

See *note Section 22.2.2 (Examples of using the Pretty Printer):
Examples of using the Pretty Printer.

Side Effects:
.............

Output to STREAM.

Affected By:
............

‘*print-pretty*’, ‘*print-miser*’.  The presence of containing logical
blocks.  The placement of newlines and conditional newlines.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if KIND is not one of
:linear, :fill, :miser, or :mandatory.

See Also:
.........

*note Section 22.3.5.1 (Tilde Underscore. Conditional Newline):
TildeUnderscore, *note Section 22.2.2 (Examples of using the Pretty
Printer): Examples of using the Pretty Printer.


File: ansicl,  Node: pprint-pop,  Next: pprint-tab,  Prev: pprint-newline,  Up: Printer

pprint-pop (Local Macro)
========================

Syntax:
.......

 -- Macro: pprint-pop <no arguments> → object

Arguments and Values:
.....................

OBJECT--an element of the list being printed in the lexically current
logical block, or ‘nil’.

Description:
............

Pops one element from the list being printed in the lexically current
logical block, obeying ‘*print-length*’ and ‘*print-circle*’ as
described below.

Each time ‘pprint-pop’ is called, it pops the next value off the list
passed to the lexically current logical block and returns it.  However,
before doing this, it performs three tests:

   * If the remaining `list' is not a list, "‘. ’" is printed followed
     by the remaining `list.'  (This makes it easier to write printing
     functions that are robust in the face of malformed arguments.)

   * If ‘*print-length*’ is non-nil, and ‘pprint-pop’ has already been
     called ‘*print-length*’ times within the immediately containing
     logical block, "‘...’" is printed.  (This makes it easy to write
     printing functions that properly handle ‘*print-length*’.)

   * If ‘*print-circle*’ is non-nil, and the remaining list is a
     circular (or shared) reference, then "‘. ’" is printed followed by
     an appropriate "‘#n#’" marker.  (This catches instances of cdr
     circularity and sharing in lists.)

If either of the three conditions above occurs, the indicated output is
printed on the pretty printing stream created by the immediately
containing ‘pprint-logical-block’ and the execution of the immediately
containing ‘pprint-logical-block’ is terminated except for the printing
of the suffix.

If ‘pprint-logical-block’ is given a `list' argument of ‘nil’--because
it is not processing a list--‘pprint-pop’ can still be used to obtain
support for ‘*print-length*’.  In this situation, the first and third
tests above are disabled and ‘pprint-pop’ always returns ‘nil’.  See
*note Section 22.2.2 (Examples of using the Pretty Printer): Examples
of using the Pretty Printer.--specifically, the ‘pprint-vector’ example.

Whether or not ‘pprint-pop’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘pprint-pop’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘pprint-pop’ outside of
‘pprint-logical-block’ are undefined.

Side Effects:
.............

Might cause output to the pretty printing stream associated with the
lexically current logical block.

Affected By:
............

‘*print-length*’, ‘*print-circle*’.

Exceptional Situations:
.......................

An error is signaled (either at macro expansion time or at run time) if
a usage of ‘pprint-pop’ occurs where there is no lexically containing
‘pprint-logical-block’ form.

The consequences are undefined if ‘pprint-pop’ is executed outside of
the dynamic extent of this ‘pprint-logical-block’.

See Also:
.........

*note pprint-exit-if-list-exhausted::, *note pprint-logical-block::.

Notes:
......

It is frequently a good idea to call ‘pprint-exit-if-list-exhausted’
before calling ‘pprint-pop’.


File: ansicl,  Node: pprint-tab,  Next: print-object,  Prev: pprint-pop,  Up: Printer

pprint-tab (Function)
=====================

Syntax:
.......

 -- Function: pprint-tab kind colnum colinc &optional stream → ‘nil’

Arguments and Values:
.....................

KIND--one of :line, :section, :line-relative, or :section-relative.

COLNUM--a non-negative integer.

COLINC--a non-negative integer.

STREAM--an output stream designator.

Description:
............

Specifies tabbing to STREAM as performed by the standard `~T' format
directive.  If STREAM is a pretty printing stream and the value of
‘*print-pretty*’ is true, tabbing is performed; otherwise, ‘pprint-tab’
has no effect.

The arguments COLNUM and COLINC correspond to the two PARAMETERS to
`~T' and are in terms of ems.  The KIND argument specifies the style of
tabbing.  It must be one of :line (tab as by `~T'), :section (tab as by
`~:T', but measuring horizontal positions relative to the start of the
dynamically enclosing section), :line-relative (tab as by `~@T'), or
:section-relative (tab as by `~:@T', but measuring horizontal positions
relative to the start of the dynamically enclosing section).

Exceptional Situations:
.......................

An error is signaled if KIND is not one of :line, :section,
:line-relative, or :section-relative.

See Also:
.........

*note pprint-logical-block::


File: ansicl,  Node: print-object,  Next: print-unreadable-object,  Prev: pprint-tab,  Up: Printer

print-object (Standard Generic Function)
========================================

Syntax:
.......

 -- Generic Function: print-object object stream → object

Method Signatures:
..................

print-object (OBJECT standard-object) STREAM  print-object (OBJECT
structure-object) STREAM

Arguments and Values:
.....................

OBJECT--an object.

STREAM--a stream.

Description:
............

The generic function ‘print-object’ writes the printed representation
of OBJECT to STREAM.  The function ‘print-object’ is called by the Lisp
printer; it should not be called by the user.

Each implementation is required to provide a method on the class
‘standard-object’ and on the class ‘structure-object’.  In addition,
each implementation must provide methods on enough other classes so as
to ensure that there is always an applicable method.  Implementations
are free to add methods for other classes.  Users may write methods for
‘print-object’ for their own classes if they do not wish to inherit an
implementation-dependent method.

The method on the class ‘structure-object’ prints the object in the
default ‘#S’ notation; see *note Section 22.1.3.12 (Printing
Structures): PrintingStructures.

Methods on ‘print-object’ are responsible for implementing their part
of the semantics of the printer control variables, as follows:

‘*print-readably*’
     All methods for ‘print-object’ must obey ‘*print-readably*’.  This
     includes both user-defined methods and implementation-defined
     methods.  Readable printing of structures and standard objects is
     controlled by their ‘print-object’ method, not by their
     ‘make-load-form’ method.  Similarity for these objects is
     application dependent and hence is defined to be whatever these
     methods do; see *note Section 3.2.4.2 (Similarity of Literal
     Objects): Similarity.

‘*print-escape*’
     Each method must implement ‘*print-escape*’.

‘*print-pretty*’
     The method may wish to perform specialized line breaking or other
     output conditional on the value of ‘*print-pretty*’.  For further
     information, see (for example) the macro ‘pprint-fill’.  See also
     *note Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

‘*print-length*’
     Methods that produce output of indefinite length must obey
     ‘*print-length*’.  For further information, see (for example) the
     macros ‘pprint-logical-block’ and ‘pprint-pop’.  See also *note
     Section 22.2.1.4 (Pretty Print Dispatch Tables):
     PPrintDispatchTables. and *note Section 22.2.2 (Examples of using
     the Pretty Printer): Examples of using the Pretty Printer.

‘*print-level*’
     The printer takes care of ‘*print-level*’ automatically, provided
     that each method handles exactly one level of structure and calls
     ‘write’ (or an equivalent function) recursively if there are more
     structural levels.  The printer's decision of whether an object
     has components (and therefore should not be printed when the
     printing depth is not less than ‘*print-level*’) is
     implementation-dependent.  In some implementations its
     ‘print-object’ method is not called; in others the method is
     called, and the determination that the object has components is
     based on what it tries to write to the STREAM.

‘*print-circle*’
     When the value of ‘*print-circle*’ is true, a user-defined
     ‘print-object’ method can print objects to the supplied stream
     using ‘write’, ‘prin1’, ‘princ’, or ‘format’ and expect
     circularities to be detected and printed using the ‘#n#’ syntax.
     If a user-defined ‘print-object’ method prints to a stream other
     than the one that was supplied, then circularity detection starts
     over for that stream.  See ‘*print-circle*’.

‘*print-base*’, ‘*print-radix*’, ‘*print-case*’,  ‘*print-gensym*’, and ‘*print-array*’
     These printer control variables apply to specific types of objects
     and are handled by the methods for those objects.

If these rules are not obeyed, the results are undefined.

In general, the printer and the ‘print-object’ methods should not
rebind the print control variables as they operate recursively through
the structure, but this is implementation-dependent.

In some implementations the STREAM argument passed to a ‘print-object’
method is not the original stream, but is an intermediate stream that
implements part of the printer.  methods should therefore not depend on
the identity of this stream.

See Also:
.........

*note pprint-fill::, *note pprint-logical-block::, *note pprint-pop::,
*note write::, *note *print-readably*::, *note *print-escape*::, *note
*print-pretty*::, *note *print-length*::, *note Section 22.1.3 (Default
Print-Object Methods): Default Print-Object Methods, *note Section
22.1.3.12 (Printing Structures): PrintingStructures, *note Section
22.2.1.4 (Pretty Print Dispatch Tables): PPrintDispatchTables, *note
Section 22.2.2 (Examples of using the Pretty Printer): Examples of
using the Pretty Printer.


File: ansicl,  Node: print-unreadable-object,  Next: set-pprint-dispatch,  Prev: print-object,  Up: Printer

print-unreadable-object (Macro)
===============================

Syntax:
.......

 -- Macro: print-unreadable-object (object stream &key type identity)
          {form}* → ‘nil’

Arguments and Values:
.....................

OBJECT--an object; evaluated.

STREAM-- a stream designator; evaluated.

TYPE--a generalized boolean; evaluated.

IDENTITY--a generalized boolean; evaluated.

FORMS--an implicit progn.

Description:
............

Outputs a printed representation of OBJECT on STREAM, beginning with
"‘#<’" and ending with "‘>’".  Everything output to STREAM by the body
FORMS is enclosed in the the angle brackets.  If TYPE is true, the
output from FORMS is preceded by a brief description of the OBJECT's
type and a space character.  If IDENTITY is true, the output from FORMS
is followed by a space character and a representation of the OBJECT's
identity, typically a storage address.

If either TYPE or IDENTITY is not supplied, its value is false.  It is
valid to omit the body FORMS.  If TYPE and IDENTITY are both true and
there are no body FORMS, only one space character separates the type
and the identity.

Examples:
.........

;; Note that in this example, the precise form of the output ;; is
implementation-dependent.

 (defmethod print-object ((obj airplane) stream)
   (print-unreadable-object (obj stream :type t :identity t)
     (princ (tail-number obj) stream)))

 (prin1-to-string my-airplane)
→ "#<Airplane NW0773 36000123135>"
or→ "#<FAA:AIRPLANE NW0773 17>"

Exceptional Situations:
.......................

If ‘*print-readably*’ is true, ‘print-unreadable-object’ signals an
error of type ‘print-not-readable’ without printing anything.


File: ansicl,  Node: set-pprint-dispatch,  Next: write; prin1; print; pprint; princ,  Prev: print-unreadable-object,  Up: Printer

set-pprint-dispatch (Function)
==============================

Syntax:
.......

 -- Function: set-pprint-dispatch type-specifier function &optional
          priority table → ‘nil’

Arguments and Values:
.....................

TYPE-SPECIFIER--a type specifier.

FUNCTION--a function, a function name, or ‘nil’.

PRIORITY--a real.  The default is ‘0’.

TABLE--a pprint dispatch table.  The default is the value of
‘*print-pprint-dispatch*’.

Description:
............

Installs an entry into the pprint dispatch table which is TABLE.

TYPE-SPECIFIER is the key of the entry.  The first action of
‘set-pprint-dispatch’ is to remove any pre-existing entry associated
with TYPE-SPECIFIER.  This guarantees that there will never be two
entries associated with the same type specifier in a given pprint
dispatch table.  Equality of type specifiers is tested by ‘equal’.

Two values are associated with each type specifier in a pprint dispatch
table: a FUNCTION and a PRIORITY.  The FUNCTION must accept two
arguments: the stream to which output is sent and the object to be
printed.  The FUNCTION should pretty print the object to the STREAM.
The FUNCTION can assume that object satisfies the type given by
type-specifier.  The FUNCTION must obey ‘*print-readably*’.  Any values
returned by the FUNCTION are ignored.

PRIORITY is a priority to resolve conflicts when an object matches more
than one entry.

It is permissible for FUNCTION to be ‘nil’.  In this situation, there
will be no TYPE-SPECIFIER entry in TABLE after ‘set-pprint-dispatch’
returns.

Exceptional Situations:
.......................

An error is signaled if PRIORITY is not a real.

Notes:
......

Since pprint dispatch tables are often used to control the pretty
printing of Lisp code, it is common for the TYPE-SPECIFIER to be an
expression of the form

 (cons CAR-TYPE CDR-TYPE)

This signifies that the corresponding object must be a cons cell whose
car matches the type specifier CAR-TYPE and whose cdr matches the type
specifier CDR-TYPE.  The CDR-TYPE can be omitted in which case it
defaults to t.


File: ansicl,  Node: write; prin1; print; pprint; princ,  Next: write-to-string; prin1-to-string; princ-to-string,  Prev: set-pprint-dispatch,  Up: Printer

write, prin1, print, pprint, princ (Function)
=============================================

Syntax:
.......

 -- Function: write OBJECT &key array base case circle escape gensym
          length level lines miser-width pprint-dispatch
          pretty radix readably right-margin stream
          → object

 -- Function: prin1 object &optional output-stream → object

 -- Function: princ object &optional output-stream → object

 -- Function: print object &optional output-stream → object

 -- Function: pprint object &optional output-stream → <no values>

Arguments and Values:
.....................

OBJECT--an object.

OUTPUT-STREAM--an output stream designator.  The default is standard
output.

ARRAY--a generalized boolean.

BASE--a radix.

CASE--a symbol of type ‘(member :upcase :downcase :capitalize)’.

CIRCLE--a generalized boolean.

ESCAPE--a generalized boolean.

GENSYM--a generalized boolean.

LENGTH--a non-negative integer, or ‘nil’.

LEVEL--a non-negative integer, or ‘nil’.

LINES--a non-negative integer, or ‘nil’.

MISER-WIDTH--a non-negative integer, or ‘nil’.

PPRINT-DISPATCH--a pprint dispatch table.

PRETTY--a generalized boolean.

RADIX--a generalized boolean.

READABLY--a generalized boolean.

RIGHT-MARGIN--a non-negative integer, or ‘nil’.

STREAM--an output stream designator.  The default is standard output.

Description:
............

‘write’, ‘prin1’, ‘princ’, ‘print’, and ‘pprint’ write the printed
representation of OBJECT to OUTPUT-STREAM.

‘write’ is the general entry point to the Lisp printer.  For each
explicitly supplied keyword parameter named in the next figure, the
corresponding printer control variable is dynamically bound to its value
while printing goes on; for each keyword parameter in the next
figure that is not explicitly supplied, the value of the corresponding
printer control variable is the same as it was at the time ‘write’ was
invoked.  Once the appropriate bindings are established, the object is
output by the Lisp printer.

Parameter         Corresponding Dynamic
                  Variable
---------------------------------------------- 
ARRAY             ‘*print-array*’
BASE              ‘*print-base*’
CASE              ‘*print-case*’
CIRCLE            ‘*print-circle*’
ESCAPE            ‘*print-escape*’
GENSYM            ‘*print-gensym*’
LENGTH            ‘*print-length*’
LEVEL             ‘*print-level*’
LINES             ‘*print-lines*’
MISER-WIDTH       ‘*print-miser-width*’
PPRINT-DISPATCH   ‘*print-pprint-dispatch*’
PRETTY            ‘*print-pretty*’
RADIX             ‘*print-radix*’
READABLY          ‘*print-readably*’
RIGHT-MARGIN      ‘*print-right-margin*’

Figure 22.7: Argument correspondences for the WRITE function.

‘prin1’, ‘princ’, ‘print’, and ‘pprint’ implicitly bind certain print
parameters to particular values.  The remaining parameter values are
taken from ‘*print-array*’, ‘*print-base*’, ‘*print-case*’,
‘*print-circle*’, ‘*print-escape*’, ‘*print-gensym*’, ‘*print-length*’,
‘*print-level*’, ‘*print-lines*’, ‘*print-miser-width*’,
‘*print-pprint-dispatch*’, ‘*print-pretty*’, ‘*print-radix*’, and
‘*print-right-margin*’.

‘prin1’ produces output suitable for input to ‘read’.  It binds
‘*print-escape*’ to true.

‘princ’ is just like ‘prin1’ except that the output has no escape
characters.  It binds ‘*print-escape*’   to false and
‘*print-readably*’ to false.  The general rule is that output from
‘princ’ is intended to look good to people, while output from ‘prin1’
is intended to be acceptable to ‘read’.

‘print’ is just like ‘prin1’ except that the printed representation of
OBJECT is preceded by a newline and followed by a space.

‘pprint’ is just like ‘print’ except that the trailing space is omitted
and OBJECT is printed with the ‘*print-pretty*’ flag non-nil to produce
pretty output.

OUTPUT-STREAM specifies the stream to which output is to be sent.

Affected By:
............

‘*standard-output*’, ‘*terminal-io*’, ‘*print-escape*’, ‘*print-radix*’,
‘*print-base*’, ‘*print-circle*’, ‘*print-pretty*’, ‘*print-level*’,
‘*print-length*’, ‘*print-case*’, ‘*print-gensym*’, ‘*print-array*’,
‘*read-default-float-format*’.

See Also:
.........

*note readtable-case::, *note Section 22.3.4 (FORMAT Printer
Operations): FORMAT Printer Operations.

Notes:
......

The functions ‘prin1’ and ‘print’ do not bind ‘*print-readably*’.

 (prin1 object output-stream)
≡ (write object :stream output-stream :escape t)

 (princ object output-stream)
≡ (write object stream output-stream :escape nil :readably nil)

 (print object output-stream)
≡ (progn (terpri output-stream)
           (write object :stream output-stream
                         :escape t)
           (write-char #\space output-stream))

 (pprint object output-stream)
≡ (write object :stream output-stream :escape t :pretty t)


File: ansicl,  Node: write-to-string; prin1-to-string; princ-to-string,  Next: *print-array*,  Prev: write; prin1; print; pprint; princ,  Up: Printer

write-to-string, prin1-to-string, princ-to-string (Function)
============================================================

Syntax:
.......

 -- Function: write-to-string object &key array base case circle escape
          gensym
          length level lines miser-width pprint-dispatch
          pretty radix readably right-margin
          → string

 -- Function: prin1-to-string object → string

 -- Function: princ-to-string object → string

Arguments and Values:
.....................

OBJECT--an object.

ARRAY--a generalized boolean.

BASE--a radix.

CASE--a symbol of type ‘(member :upcase :downcase :capitalize)’.

CIRCLE--a generalized boolean.

ESCAPE--a generalized boolean.

GENSYM--a generalized boolean.

LENGTH--a non-negative integer, or ‘nil’.

LEVEL--a non-negative integer, or ‘nil’.

LINES--a non-negative integer, or ‘nil’.

MISER-WIDTH--a non-negative integer, or ‘nil’.

PPRINT-DISPATCH--a pprint dispatch table.

PRETTY--a generalized boolean.

RADIX--a generalized boolean.

READABLY--a generalized boolean.

RIGHT-MARGIN--a non-negative integer, or ‘nil’.

STRING--a string.

Description:
............

‘write-to-string’, ‘prin1-to-string’, and ‘princ-to-string’ are used to
create a string consisting of the printed representation of OBJECT.
OBJECT is effectively printed as if by ‘write’, ‘prin1’, or ‘princ’,
respectively, and the characters that would be output are made into a
string.

‘write-to-string’ is the general output function.  It has the ability
to specify all the parameters applicable to the printing of OBJECT.

‘prin1-to-string’ acts like ‘write-to-string’ with ‘:escape t’, that
is, escape characters are written where appropriate.

‘princ-to-string’ acts like ‘write-to-string’ with ‘:escape nil
:readably nil’.  Thus no escape characters are written.

All other keywords that would be specified to ‘write-to-string’ are
default values when ‘prin1-to-string’ or ‘princ-to-string’ is invoked.

The meanings and defaults for the keyword arguments to ‘write-to-string’
are the same as those for ‘write’.

Examples:
.........

 (prin1-to-string "abc") → "\"abc\""
 (princ-to-string "abc") → "abc"

Affected By:
............

‘*print-escape*’, ‘*print-radix*’, ‘*print-base*’, ‘*print-circle*’,
‘*print-pretty*’, ‘*print-level*’, ‘*print-length*’, ‘*print-case*’,
‘*print-gensym*’, ‘*print-array*’, ‘*read-default-float-format*’.

See Also:
.........

*note write::

Notes:
......

 (write-to-string OBJECT {KEY ARGUMENT}*)
≡ (with-output-to-string (#1=#:string-stream)
     (write object :stream #1# {KEY ARGUMENT}*))

 (princ-to-string OBJECT)
≡ (with-output-to-string (string-stream)
     (princ OBJECT string-stream))

 (prin1-to-string OBJECT)
≡ (with-output-to-string (string-stream)
     (prin1 OBJECT string-stream))


File: ansicl,  Node: *print-array*,  Next: *print-base*; *print-radix*,  Prev: write-to-string; prin1-to-string; princ-to-string,  Up: Printer

*print-array* (Variable)
========================

Value Type:
...........

a generalized boolean.

Initial Value:
..............

implementation-dependent.

Description:
............

Controls the format in which arrays are printed.  If it is false, the
contents of arrays other than strings are never printed.  Instead,
arrays are printed in a concise form using ‘#<’ that gives enough
information for the user to be able to identify the array, but does not
include the entire array contents.  If it is true, non-string arrays
are printed using ‘#(...)’, ‘#*’, or ‘#nA’ syntax.

Affected By:
............

The implementation.

See Also:
.........

*note Section 2.4.8.3 (Sharpsign Left-Parenthesis): SharpsignLeftParen,
*note Section 2.4.8.20 (Sharpsign Less-Than-Sign): SharpsignLeftAngle.


File: ansicl,  Node: *print-base*; *print-radix*,  Next: *print-case*,  Prev: *print-array*,  Up: Printer

*print-base*, *print-radix* (Variable)
======================================

Value Type:
...........

‘*print-base*’--a radix.  ‘*print-radix*’--a generalized boolean.

Initial Value:
..............

The initial value of ‘*print-base*’ is ‘10’.  The initial value of
‘*print-radix*’ is false.

Description:
............

‘*print-base*’ and ‘*print-radix*’ control the printing of rationals.
The value of ‘*print-base*’ is called the "current output base".

The value of ‘*print-base*’ is the radix in which the printer will
print rationals.   For radices above ‘10’, letters of the alphabet are
used to represent digits above ‘9’.

If the value of ‘*print-radix*’ is true, the printer will print a radix
specifier to indicate the radix in which it is printing a rational
number.  The radix specifier is always printed using lowercase letters.
If ‘*print-base*’ is ‘2’, ‘8’, or ‘16’, then the radix specifier used
is ‘#b’, ‘#o’, or ‘#x’, respectively.  For integers, base ten is
indicated by a trailing decimal point instead of a leading radix
specifier; for ratios, ‘#10r’ is used.

Examples:
.........

 (let ((*print-base* 24.) (*print-radix* t))
   (print 23.))
▷ #24rN
→ 23
 (setq *print-base* 10) → 10
 (setq *print-radix* nil) → NIL
 (dotimes (i 35)
    (let ((*print-base* (+ i 2)))           ;print the decimal number 40
      (write 40)                            ;in each base from 2 to 36
      (if (zerop (mod i 10)) (terpri) (format t " "))))
▷ 101000
▷ 1111 220 130 104 55 50 44 40 37 34
▷ 31 2C 2A 28 26 24 22 20 1J 1I
▷ 1H 1G 1F 1E 1D 1C 1B 1A 19 18
▷ 17 16 15 14
→ NIL
 (dolist (pb '(2 3 8 10 16))
    (let ((*print-radix* t)                 ;print the integer 10 and
          (*print-base* pb))                ;the ratio 1/10 in bases 2,
     (format t "~&~S  ~S~%" 10 1/10)))        ;3, 8, 10, 16
▷ #b1010  #b1/1010
▷ #3r101  #3r1/101
▷ #o12  #o1/12
▷ 10.  #10r1/10
▷ #xA  #x1/A
→ NIL

Affected By:
............

Might be bound by ‘format’, and ‘write’, ‘write-to-string’.

See Also:
.........

*note format::, *note write::, *note write-to-string::


File: ansicl,  Node: *print-case*,  Next: *print-circle*,  Prev: *print-base*; *print-radix*,  Up: Printer

*print-case* (Variable)
=======================

Value Type:
...........

One of the symbols :upcase, :downcase, or :capitalize.

Initial Value:
..............

The symbol :upcase.

Description:
............

The value of ‘*print-case*’ controls the case (upper, lower, or mixed)
in which to print any uppercase characters in the names of symbols when
vertical-bar syntax is not used.

‘*print-case*’ has an effect at all times when the value of
‘*print-escape*’ is false. ‘*print-case*’ also has an effect when the
value of ‘*print-escape*’ is true unless inside an escape context
(i.e., unless between vertical-bars or after a slash).

Examples:
.........

 (defun test-print-case ()
   (dolist (*print-case* '(:upcase :downcase :capitalize))
     (format t "~&~S ~S~%" 'this-and-that '|And-something-elSE|)))
→ TEST-PC
;; Although the choice of which characters to escape is specified by
;; *PRINT-CASE*, the choice of how to escape those characters
;; (i.e., whether single escapes or multiple escapes are used)
;; is implementation-dependent.  The examples here show two of the
;; many valid ways in which escaping might appear.
 (test-print-case) ;Implementation A
▷ THIS-AND-THAT |And-something-elSE|
▷ this-and-that a\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
▷ This-And-That A\n\d-\s\o\m\e\t\h\i\n\g-\e\lse
→ NIL
 (test-print-case) ;Implementation B
▷ THIS-AND-THAT |And-something-elSE|
▷ this-and-that a|nd-something-el|se
▷ This-And-That A|nd-something-el|se
→ NIL

See Also:
.........

*note write::

Notes:
......

‘read’ normally converts lowercase characters appearing in symbols to
corresponding uppercase characters, so that internally print names
normally contain only uppercase characters.

If ‘*print-escape*’ is true, lowercase characters in the name of a
symbol are always printed in lowercase, and are preceded by a single
escape character or enclosed by multiple escape characters; uppercase
characters in the name of a symbol are printed in upper case, in lower
case, or in mixed case so as to capitalize words, according to the
value of ‘*print-case*’.  The convention for what constitutes a "word"
is the same as for ‘string-capitalize’.



Local Variables:
coding: utf-8
End:
