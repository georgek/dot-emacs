This is ansicl, produced by makeinfo version 4.13 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: package,  Next: export,  Prev: Package Concepts,  Up: Packages

package (System Class)
======================

Class Precedence List:
......................

‘package’, ‘t’

Description:
............

A package is a namespace that maps symbol names to symbols; see *note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*note Section 11.1 (Package Concepts): Package Concepts, *note Section
22.1.3.13 (Printing Other Objects): PrintingOtherObjects, *note Section
2.3.4 (Symbols as Tokens): Symbols as Tokens.


File: ansicl,  Node: export,  Next: find-symbol,  Prev: package,  Up: Packages

export (Function)
=================

Syntax:
.......

 -- Function: export symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

‘export’ makes one or more SYMBOLS that are accessible in PACKAGE
(whether directly or by inheritance) be external symbols of that
PACKAGE.

If any of the SYMBOLS is already accessible as an external symbol of
PACKAGE, ‘export’ has no effect on that symbol.  If the SYMBOL is
present in PACKAGE as an internal symbol, it is simply changed to
external status.  If it is accessible as an internal symbol via
‘use-package’, it is first imported into PACKAGE, then exported.  (The
SYMBOL is then present in the PACKAGE whether or not PACKAGE continues
to use the package through which the symbol was originally inherited.)

‘export’ makes each SYMBOL accessible to all the packages that use
PACKAGE.  All of these packages are checked for name conflicts:
‘(export s p)’ does ‘(find-symbol (symbol-name s) q)’ for each package q
in ‘(package-used-by-list p)’.  Note that in the usual case of an
‘export’ during the initial definition of a package, the result of
‘package-used-by-list’ is ‘nil’ and the name-conflict checking takes
negligible time.  When multiple changes are to be made, for example
when ‘export’ is given a LIST of SYMBOLS, it is permissible for the
implementation to process each change separately, so that aborting from
a name conflict caused by any but the first SYMBOL in the list does not
unexport the first SYMBOL in the LIST.  However, aborting from a
name-conflict error caused by ‘export’ of one of SYMBOLS does not leave
that symbol accessible to some packages and inaccessible to others;
with respect to each of SYMBOLS processed, ‘export’ behaves as if it
were as an atomic operation.

A name conflict in ‘export’ between one of SYMBOLS being exported and a
symbol already present in a package that would inherit the
newly-exported symbol may be resolved in favor of the exported symbol
by uninterning the other one, or in favor of the already-present symbol
by making it a shadowing symbol.

Examples:
.........

 (make-package 'temp :use nil) → #<PACKAGE "TEMP">
 (use-package 'temp) → T
 (intern "TEMP-SYM" 'temp) → TEMP::TEMP-SYM, NIL
 (find-symbol "TEMP-SYM") → NIL, NIL
 (export (find-symbol "TEMP-SYM" 'temp) 'temp) → T
 (find-symbol "TEMP-SYM") → TEMP-SYM, :INHERITED

Side Effects:
.............

The package system is modified.

Affected By:
............

Accessible symbols.

Exceptional Situations:
.......................

If any of the SYMBOLS is not accessible at all in PACKAGE, an error of
type ‘package-error’ is signaled that is correctable by permitting the
user to interactively specify whether that symbol should be imported.

See Also:
.........

*note import::, *note unexport::, *note Section 11.1 (Package
Concepts): Package Concepts.


File: ansicl,  Node: find-symbol,  Next: find-package,  Prev: export,  Up: Packages

find-symbol (Function)
======================

Syntax:
.......

 -- Function: find-symbol string &optional package → symbol, status

Arguments and Values:
.....................

STRING--a string.

PACKAGE--a package designator.  The default is the current package.

SYMBOL--a symbol accessible in the PACKAGE, or ‘nil’.

STATUS--one of :inherited, :external, :internal, or ‘nil’.

Description:
............

‘find-symbol’ locates a symbol whose name is STRING in a package.  If a
symbol named STRING is found in PACKAGE, directly or by inheritance,
the symbol found is returned as the first value; the second value is as
follows:

:internal
     If the symbol is present in PACKAGE as an internal symbol.

:external
     If the symbol is present in PACKAGE as an external symbol.

:inherited
     If the symbol is inherited by PACKAGE through ‘use-package’, but
     is not present in PACKAGE.

If no such symbol is accessible in PACKAGE, both values are ‘nil’.

Examples:
.........

 (find-symbol "NEVER-BEFORE-USED") → NIL, NIL
 (find-symbol "NEVER-BEFORE-USED") → NIL, NIL
 (intern "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, NIL
 (intern "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, :INTERNAL
 (find-symbol "NEVER-BEFORE-USED") → NEVER-BEFORE-USED, :INTERNAL
 (find-symbol "never-before-used") → NIL, NIL
 (find-symbol "CAR" 'common-lisp-user) → CAR, :INHERITED
 (find-symbol "CAR" 'common-lisp) → CAR, :EXTERNAL
 (find-symbol "NIL" 'common-lisp-user) → NIL, :INHERITED
 (find-symbol "NIL" 'common-lisp) → NIL, :EXTERNAL
 (find-symbol "NIL" (prog1 (make-package "JUST-TESTING" :use '())
                           (intern "NIL" "JUST-TESTING")))
→ JUST-TESTING::NIL, :INTERNAL
 (export 'just-testing::nil 'just-testing)
 (find-symbol "NIL" 'just-testing) → JUST-TESTING:NIL, :EXTERNAL
 (find-symbol "NIL" "KEYWORD")
→ NIL, NIL
or→ :NIL, :EXTERNAL
 (find-symbol (symbol-name :nil) "KEYWORD") → :NIL, :EXTERNAL

Affected By:
............

‘intern’, ‘import’, ‘export’, ‘use-package’, ‘unintern’, ‘unexport’,
‘unuse-package’

See Also:
.........

*note intern::, *note find-all-symbols::

Notes:
......

‘find-symbol’ is operationally equivalent to ‘intern’, except that it
never creates a new symbol.


File: ansicl,  Node: find-package,  Next: find-all-symbols,  Prev: find-symbol,  Up: Packages

find-package (Function)
=======================

Syntax:
.......

 -- Function: find-package name → package

Arguments and Values:
.....................

NAME--a string designator or a package object.

PACKAGE--a package object or ‘nil’.

Description:
............

If NAME is a string designator, ‘find-package’ locates and returns the
package whose name or nickname is NAME.  This search is case sensitive.
If there is no such package, ‘find-package’ returns ‘nil’.

If NAME is a package object, that package object is returned.

Examples:
.........

 (find-package 'common-lisp) → #<PACKAGE "COMMON-LISP">
 (find-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (find-package 'not-there) → NIL

Affected By:
............

The set of packages created by the implementation.

‘defpackage’, ‘delete-package’, ‘make-package’, ‘rename-package’

See Also:
.........

*note make-package::


File: ansicl,  Node: find-all-symbols,  Next: import,  Prev: find-package,  Up: Packages

find-all-symbols (Function)
===========================

Syntax:
.......

 -- Function: find-all-symbols string → symbols

Arguments and Values:
.....................

STRING--a string designator.

SYMBOLS--a list of symbols.

Description:
............

‘find-all-symbols’ searches name that is the same (under ‘string=’) as
STRING.  A list of all such symbols is returned.  Whether or how the
list is ordered is implementation-dependent.

Examples:
.........

 (find-all-symbols 'car)
→ (CAR)
or→ (CAR VEHICLES:CAR)
or→ (VEHICLES:CAR CAR)
 (intern "CAR" (make-package 'temp :use nil)) → TEMP::CAR, NIL
 (find-all-symbols 'car)
→ (TEMP::CAR CAR)
or→ (CAR TEMP::CAR)
or→ (TEMP::CAR CAR VEHICLES:CAR)
or→ (CAR TEMP::CAR VEHICLES:CAR)

See Also:
.........

*note find-symbol::


File: ansicl,  Node: import,  Next: list-all-packages,  Prev: find-all-symbols,  Up: Packages

import (Function)
=================

Syntax:
.......

 -- Function: import symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

‘import’ adds SYMBOL or SYMBOLS to the internals of PACKAGE, checking
for name conflicts with existing symbols either present in PACKAGE or
accessible to it.  Once the SYMBOLS have been imported, they may be
referenced in the importing PACKAGE without the use of a package prefix
when using the Lisp reader.

A name conflict in ‘import’ between the SYMBOL being imported and a
symbol inherited from some other package can be resolved in favor of the
SYMBOL being imported by making it a shadowing symbol, or in favor of
the symbol already accessible by not doing the ‘import’.  A name
conflict in ‘import’ with a symbol already present in the PACKAGE may
be resolved by uninterning that symbol, or by not doing the ‘import’.

The imported symbol is not automatically exported from the current
package, but if it is already present and external, then the fact that
it is external is not changed.  If any symbol to be imported has no home
package (i.e., ‘(symbol-package SYMBOL) → nil’), ‘import’ sets the home
package of the SYMBOL to PACKAGE.

If the SYMBOL is already present in the importing PACKAGE, ‘import’ has
no effect.

Examples:
.........

 (import 'common-lisp::car (make-package 'temp :use nil)) → T
 (find-symbol "CAR" 'temp) → CAR, :INTERNAL
 (find-symbol "CDR" 'temp) → NIL, NIL

The form ‘(import 'editor:buffer)’ takes the external symbol named
‘buffer’ in the ‘EDITOR’ package (this symbol was located when the form
was read by the Lisp reader) and adds it to the current package as an
internal symbol. The symbol ‘buffer’ is then present in the current
package.

Side Effects:
.............

The package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

‘import’ signals a correctable error of type ‘package-error’ if any of
the SYMBOLS to be imported has the same name (under ‘string=’) as some
distinct symbol (under ‘eql’) already accessible in the PACKAGE, even
if the conflict is with a shadowing symbol of the PACKAGE.

See Also:
.........

*note shadow::, *note export::


File: ansicl,  Node: list-all-packages,  Next: rename-package,  Prev: import,  Up: Packages

list-all-packages (Function)
============================

Syntax:
.......

 -- Function: list-all-packages <no arguments> → packages

Arguments and Values:
.....................

PACKAGES--a list of package objects.

Description:
............

‘list-all-packages’ returns a fresh list of all registered packages.

Examples:
.........

 (let ((before (list-all-packages)))
    (make-package 'temp)
    (set-difference (list-all-packages) before)) → (#<PACKAGE "TEMP">)

Affected By:
............

‘defpackage’, ‘delete-package’, ‘make-package’


File: ansicl,  Node: rename-package,  Next: shadow,  Prev: list-all-packages,  Up: Packages

rename-package (Function)
=========================

Syntax:
.......

 -- Function: rename-package package new-name &optional new-nicknames →
          package-object

Arguments and Values:
.....................

PACKAGE--a package designator.

NEW-NAME--a package designator.

NEW-NICKNAMES--a list of string designators.  The default is the empty
list.

PACKAGE-OBJECT--the renamed PACKAGE object.

Description:
............

Replaces the name and nicknames of PACKAGE.  The old name and all of
the old nicknames of PACKAGE are eliminated and are replaced by
NEW-NAME and NEW-NICKNAMES.

The consequences are undefined if NEW-NAME or any NEW-NICKNAME
conflicts with any existing package names.

Examples:
.........

 (make-package 'temporary :nicknames '("TEMP")) → #<PACKAGE "TEMPORARY">
 (rename-package 'temp 'ephemeral) → #<PACKAGE "EPHEMERAL">
 (package-nicknames (find-package 'ephemeral)) → ()
 (find-package 'temporary) → NIL
 (rename-package 'ephemeral 'temporary '(temp fleeting))
→ #<PACKAGE "TEMPORARY">
 (package-nicknames (find-package 'temp)) → ("TEMP" "FLEETING")

See Also:
.........

*note make-package::


File: ansicl,  Node: shadow,  Next: shadowing-import,  Prev: rename-package,  Up: Packages

shadow (Function)
=================

Syntax:
.......

 -- Function: shadow symbol-names &optional package → ‘t’

Arguments and Values:
.....................

SYMBOL-NAMES--a designator for a list of string designators.

PACKAGE--a package designator.  The default is the current package.

Description:
............

‘shadow’ assures that symbols with names given by SYMBOL-NAMES are
present in the PACKAGE.

Specifically, PACKAGE is searched for symbols with the names supplied
by SYMBOL-NAMES.  For each such name, if a corresponding symbol is not
present in PACKAGE (directly, not by inheritance), then a corresponding
symbol is created with that name, and inserted into PACKAGE as an
internal symbol.  The corresponding symbol, whether pre-existing or
newly created, is then added, if not already present, to the shadowing
symbols list of PACKAGE.

Examples:
.........

 (package-shadowing-symbols (make-package 'temp)) → NIL
 (find-symbol 'car 'temp) → CAR, :INHERITED
 (shadow 'car 'temp) → T
 (find-symbol 'car 'temp) → TEMP::CAR, :INTERNAL
 (package-shadowing-symbols 'temp) → (TEMP::CAR)

 (make-package 'test-1) → #<PACKAGE "TEST-1">
 (intern "TEST" (find-package 'test-1)) → TEST-1::TEST, NIL
 (shadow 'test-1::test (find-package 'test-1)) → T
 (shadow 'TEST (find-package 'test-1)) → T
 (assert (not (null (member 'test-1::test (package-shadowing-symbols
                                            (find-package 'test-1))))))

 (make-package 'test-2) → #<PACKAGE "TEST-2">
 (intern "TEST" (find-package 'test-2)) → TEST-2::TEST, NIL
 (export 'test-2::test (find-package 'test-2)) → T
 (use-package 'test-2 (find-package 'test-1))    ;should not error

Side Effects:
.............

‘shadow’ changes the state of the package system in such a way that the
package consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

See Also:
.........

*note package-shadowing-symbols::, *note Section 11.1 (Package
Concepts): Package Concepts.

Notes:
......

If a symbol with a name in SYMBOL-NAMES already exists in PACKAGE, but
by inheritance, the inherited symbol becomes shadowed₃ by a newly
created internal symbol.


File: ansicl,  Node: shadowing-import,  Next: delete-package,  Prev: shadow,  Up: Packages

shadowing-import (Function)
===========================

Syntax:
.......

 -- Function: shadowing-import symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE --a package designator.  The default is the current package.

Description:
............

‘shadowing-import’ is like ‘import’, but it does not signal an error
even if the importation of a symbol would shadow some symbol already
accessible in PACKAGE.

‘shadowing-import’ inserts each of SYMBOLS into PACKAGE as an internal
symbol, regardless of whether another symbol of the same name is
shadowed by this action.  If a different symbol of the same name is
already present in PACKAGE, that symbol is first uninterned from
PACKAGE.  The new symbol is added to PACKAGE's shadowing-symbols list.

‘shadowing-import’ does name-conflict checking to the extent that it
checks whether a distinct existing symbol with the same name is
accessible; if so, it is shadowed by the new symbol, which implies that
it must be uninterned if it was present in PACKAGE.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (setq sym (intern "CONFLICT")) → CONFLICT
 (intern "CONFLICT" (make-package 'temp)) → TEMP::CONFLICT, NIL
 (package-shadowing-symbols 'temp) → NIL
 (shadowing-import sym 'temp) → T
 (package-shadowing-symbols 'temp) → (CONFLICT)

Side Effects:
.............

‘shadowing-import’ changes the state of the package system in such a
way that the consistency rules do not hold across the change.

PACKAGE's shadowing-symbols list is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*note import::, *note unintern::, *note package-shadowing-symbols::


File: ansicl,  Node: delete-package,  Next: make-package,  Prev: shadowing-import,  Up: Packages

delete-package (Function)
=========================

Syntax:
.......

 -- Function: delete-package package → generalized-boolean

Arguments and Values:
.....................

PACKAGE--a package designator.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘delete-package’ deletes PACKAGE from all package system data
structures.  If the operation is successful, ‘delete-package’ returns
true, otherwise ‘nil’.  The effect of ‘delete-package’ is that the name
and nicknames of PACKAGE cease to be recognized package names.  The
package object is still a package (i.e., ‘packagep’ is true of it) but
‘package-name’ returns ‘nil’.  The consequences of deleting the
‘COMMON-LISP’ package or the ‘KEYWORD’ package are undefined.  The
consequences of invoking any other package operation on PACKAGE once it
has been deleted are unspecified.  In particular, the consequences of
invoking ‘find-symbol’, ‘intern’ and other functions that look for a
symbol name in a package are unspecified if they are called with
‘*package*’ bound to the deleted PACKAGE or with the deleted PACKAGE as
an argument.

If PACKAGE is a package object that has already been deleted,
‘delete-package’ immediately returns ‘nil’.

After this operation completes, the home package of any symbol whose
home package had previously been PACKAGE is implementation-dependent.
Except for this, symbols accessible in PACKAGE are not modified in any
other way; symbols whose home package is not PACKAGE remain unchanged.

Examples:
.........

 (setq *foo-package* (make-package "FOO" :use nil))
 (setq *foo-symbol*  (intern "FOO" *foo-package*))
 (export *foo-symbol* *foo-package*)

 (setq *bar-package* (make-package "BAR" :use '("FOO")))
 (setq *bar-symbol*  (intern "BAR" *bar-package*))
 (export *foo-symbol* *bar-package*)
 (export *bar-symbol* *bar-package*)

 (setq *baz-package* (make-package "BAZ" :use '("BAR")))

 (symbol-package *foo-symbol*) → #<PACKAGE "FOO">
 (symbol-package *bar-symbol*) → #<PACKAGE "BAR">

 (prin1-to-string *foo-symbol*) → "FOO:FOO"
 (prin1-to-string *bar-symbol*) → "BAR:BAR"

 (find-symbol "FOO" *bar-package*) → FOO:FOO, :EXTERNAL

 (find-symbol "FOO" *baz-package*) → FOO:FOO, :INHERITED
 (find-symbol "BAR" *baz-package*) → BAR:BAR, :INHERITED

 (packagep *foo-package*) → true
 (packagep *bar-package*) → true
 (packagep *baz-package*) → true

 (package-name *foo-package*) → "FOO"
 (package-name *bar-package*) → "BAR"
 (package-name *baz-package*) → "BAZ"

 (package-use-list *foo-package*) → ()
 (package-use-list *bar-package*) → (#<PACKAGE "FOO">)
 (package-use-list *baz-package*) → (#<PACKAGE "BAR">)

 (package-used-by-list *foo-package*) → (#<PACKAGE "BAR">)
 (package-used-by-list *bar-package*) → (#<PACKAGE "BAZ">)
 (package-used-by-list *baz-package*) → ()

 (delete-package *bar-package*)
▷ Error: Package BAZ uses package BAR.
▷ If continued, BAZ will be made to unuse-package BAR,
▷ and then BAR will be deleted.
▷ Type :CONTINUE to continue.
▷ Debug> :CONTINUE
→ T

 (symbol-package *foo-symbol*) → #<PACKAGE "FOO">
 (symbol-package *bar-symbol*) is unspecified

 (prin1-to-string *foo-symbol*) → "FOO:FOO"
 (prin1-to-string *bar-symbol*) is unspecified

 (find-symbol "FOO" *bar-package*) is unspecified

 (find-symbol "FOO" *baz-package*) → NIL, NIL
 (find-symbol "BAR" *baz-package*) → NIL, NIL

 (packagep *foo-package*) → T
 (packagep *bar-package*) → T
 (packagep *baz-package*) → T

 (package-name *foo-package*) → "FOO"
 (package-name *bar-package*) → NIL
 (package-name *baz-package*) → "BAZ"

 (package-use-list *foo-package*) → ()
 (package-use-list *bar-package*) is unspecified
 (package-use-list *baz-package*) → ()

 (package-used-by-list *foo-package*) → ()
 (package-used-by-list *bar-package*) is unspecified
 (package-used-by-list *baz-package*) → ()

Exceptional Situations:
.......................

If the PACKAGE designator is a name that does not currently name a
package, a correctable error of type ‘package-error’ is signaled.  If
correction is attempted, no deletion action is attempted; instead,
‘delete-package’ immediately returns ‘nil’.

If PACKAGE is used by other packages, a correctable error of type
‘package-error’ is signaled.  If correction is attempted,
‘unuse-package’ is effectively called to remove any dependencies,
causing PACKAGE's external symbols to cease being accessible to those
packages that use PACKAGE.  ‘delete-package’ then deletes PACKAGE just
as it would have had there been no packages that used it.

See Also:
.........

*note unuse-package::


File: ansicl,  Node: make-package,  Next: with-package-iterator,  Prev: delete-package,  Up: Packages

make-package (Function)
=======================

Syntax:
.......

 -- Function: make-package package-name &key nicknames use → package

Arguments and Values:
.....................

PACKAGE-NAME--a string designator.

NICKNAMES--a list of string designators.  The default is the empty list.

USE-- a list of package designators.  The default is
implementation-defined.

PACKAGE--a package.

Description:
............

Creates a new package with the name PACKAGE-NAME.

NICKNAMES are additional names which may be used to refer to the new
package.

USE specifies zero or more packages the external symbols of which are
to be inherited by the new package.  See the function *note
use-package::.

Examples:
.........

 (make-package 'temporary :nicknames '("TEMP" "temp")) → #<PACKAGE "TEMPORARY">
 (make-package "OWNER" :use '("temp")) → #<PACKAGE "OWNER">
 (package-used-by-list 'temp) → (#<PACKAGE "OWNER">)
 (package-use-list 'owner) → (#<PACKAGE "TEMPORARY">)

Affected By:
............

The existence of other packages in the system.

Exceptional Situations:
.......................

The consequences are unspecified if packages denoted by USE do not
exist.

A correctable error is signaled if the PACKAGE-NAME or any of the
NICKNAMES is already the name or nickname of an existing package.

See Also:
.........

*note defpackage::, *note use-package::

Notes:
......

In situations where the packages to be used contain symbols which would
conflict, it is necessary to first create the package with ‘:use '()’,
then to use ‘shadow’ or ‘shadowing-import’ to address the conflicts,
and then after that to use ‘use-package’ once the conflicts have been
addressed.

When packages are being created as part of the static definition of a
program rather than dynamically by the program, it is generally
considered more stylistically appropriate to use ‘defpackage’ rather
than ‘make-package’.


File: ansicl,  Node: with-package-iterator,  Next: unexport,  Prev: make-package,  Up: Packages

with-package-iterator (Macro)
=============================

Syntax:
.......

 -- Macro: with-package-iterator (name package-list-form &rest
          symbol-types) {declaration}* {form}* → {result}*

Arguments and Values:
.....................

NAME--a symbol.

PACKAGE-LIST-FORM--a form; evaluated once to produce a PACKAGE-LIST.

PACKAGE-LIST--a designator for a list of package designators.

SYMBOL-TYPE--one of the symbols :internal, :external, or :inherited.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values of the FORMS.

Description:
............

Within the lexical scope of the body FORMS, the NAME is defined via
‘macrolet’ such that successive invocations of ‘(NAME)’ will return the
symbols, one by one, from the packages in PACKAGE-LIST.

It is unspecified whether symbols inherited from multiple packages are
returned more than once.  The order of symbols returned does not
necessarily reflect the order of packages in PACKAGE-LIST.  When
PACKAGE-LIST has more than one element, it is unspecified whether
duplicate symbols are returned once or more than once.

SYMBOL-TYPES controls which symbols that are accessible in a package
are returned as follows:

:internal
     The symbols that are present in the package, but that are not
     exported.

:external
     The symbols that are present in the package and are exported.

:inherited
     The symbols that are exported by used packages and that are not
     shadowed.

When more than one argument is supplied for SYMBOL-TYPES, a symbol is
returned if its accessibility matches any one of the SYMBOL-TYPES
supplied.  Implementations may extend this syntax by recognizing
additional symbol accessibility types.

An invocation of ‘(NAME)’ returns four values as follows:

  1. A flag that indicates whether a symbol is returned (true means
     that a symbol is returned).

  2. A symbol that is accessible in one the indicated packages.

  3. The accessibility type for that symbol; i.e., one of the symbols
     :internal, :external, or :inherited.

  4. The package from which the symbol was obtained.  The package is
     one of the packages present or named in PACKAGE-LIST.

After all symbols have been returned by successive invocations of
‘(NAME)’, then only one value is returned, namely ‘nil’.

The meaning of the second, third, and fourth values is that the returned
symbol is accessible in the returned package in the way indicated by
the second return value as follows:

:internal
     Means present and not exported.

:external
     Means present and exported.

:inherited
     Means not present (thus not shadowed) but inherited from some used
     package.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
‘with-package-iterator’ form such as by returning some closure over the
invocation form.

Any number of invocations of ‘with-package-iterator’ can be nested, and
the body of the innermost one can invoke all of the locally established
macros, provided all those macros have distinct names.

Examples:
.........

The following function should return ‘t’ on any package, and signal an
error if the usage of ‘with-package-iterator’ does not agree with the
corresponding usage of ‘do-symbols’.

 (defun test-package-iterator (package)
   (unless (packagep package)
     (setq package (find-package package)))
   (let ((all-entries '())
         (generated-entries '()))
     (do-symbols (x package)
       (multiple-value-bind (symbol accessibility)
           (find-symbol (symbol-name x) package)
         (push (list symbol accessibility) all-entries)))
     (with-package-iterator (generator-fn package
                             :internal :external :inherited)
       (loop
         (multiple-value-bind (more? symbol accessibility pkg)
             (generator-fn)
           (unless more? (return))
           (let ((l (multiple-value-list (find-symbol (symbol-name symbol)
                                                      package))))
             (unless (equal l (list symbol accessibility))
               (error "Symbol ~S not found as ~S in package ~A [~S]"
                      symbol accessibility (package-name package) l))
             (push l generated-entries)))))
     (unless (and (subsetp all-entries generated-entries :test #'equal)
                  (subsetp generated-entries all-entries :test #'equal))
      (error "Generated entries and Do-Symbols entries don't correspond"))
     t))

The following function prints out every present symbol (possibly more
than once):

 (defun print-all-symbols ()
   (with-package-iterator (next-symbol (list-all-packages)
                           :internal :external)
     (loop
       (multiple-value-bind (more? symbol) (next-symbol)
         (if more?
            (print symbol)
            (return))))))

Exceptional Situations:
.......................

‘with-package-iterator’ signals an error of type ‘program-error’ if no
SYMBOL-TYPES are supplied or if a SYMBOL-TYPE is not recognized  by the
implementation is supplied.

The consequences are undefined if the local function named NAME
established by ‘with-package-iterator’ is called after it has returned
false as its primary value.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: unexport,  Next: unintern,  Prev: with-package-iterator,  Up: Packages

unexport (Function)
===================

Syntax:
.......

 -- Function: unexport symbols &optional package → ‘t’

Arguments and Values:
.....................

SYMBOLS--a designator for a list of symbols.

PACKAGE--a package designator.  The default is the current package.

Description:
............

‘unexport’ reverts external SYMBOLS in PACKAGE to internal status; it
undoes the effect of ‘export’.

‘unexport’ works only on symbols present in PACKAGE, switching them
back to internal status.  If ‘unexport’ is given a symbol that is
already accessible as an internal symbol in PACKAGE, it does nothing.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (export (intern "CONTRABAND" (make-package 'temp)) 'temp) → T
 (find-symbol "CONTRABAND") → NIL, NIL
 (use-package 'temp) → T
 (find-symbol "CONTRABAND") → CONTRABAND, :INHERITED
 (unexport 'contraband 'temp) → T
 (find-symbol "CONTRABAND") → NIL, NIL

Side Effects:
.............

Package system is modified.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

If ‘unexport’ is given a symbol not accessible in PACKAGE at all, an
error of type ‘package-error’ is signaled.

The consequences are undefined if PACKAGE is the ‘KEYWORD’ package or
the ‘COMMON-LISP’ package.

See Also:
.........

*note export::, *note Section 11.1 (Package Concepts): Package Concepts.


File: ansicl,  Node: unintern,  Next: in-package,  Prev: unexport,  Up: Packages

unintern (Function)
===================

Syntax:
.......

 -- Function: unintern symbol &optional package → generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

PACKAGE--a package designator.  The default is the current package.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘unintern’ removes SYMBOL from PACKAGE.  If SYMBOL is present in
PACKAGE, it is removed from PACKAGE and also from PACKAGE's shadowing
symbols list if it is present there.  If PACKAGE is the home package
for SYMBOL, SYMBOL is made to have no home package.  SYMBOL may
continue to be accessible in PACKAGE by inheritance.

Use of ‘unintern’ can result in a symbol that has no recorded home
package, but that in fact is accessible in some package.  Common
Lisp does not check for this pathological case, and such symbols are
always printed preceded by ‘#:’.

‘unintern’ returns true if it removes SYMBOL, and ‘nil’ otherwise.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (setq temps-unpack (intern "UNPACK" (make-package 'temp))) → TEMP::UNPACK
 (unintern temps-unpack 'temp) → T
 (find-symbol "UNPACK" 'temp) → NIL, NIL
 temps-unpack → #:UNPACK

Side Effects:
.............

‘unintern’ changes the state of the package system in such a way that
the consistency rules do not hold across the change.

Affected By:
............

Current state of the package system.

Exceptional Situations:
.......................

Giving a shadowing symbol to ‘unintern’ can uncover a name conflict
that had previously been resolved by the shadowing.  If package A uses
packages B and C, A contains a shadowing symbol ‘x’, and B and C each
contain external symbols named ‘x’, then removing the shadowing symbol
‘x’ from A will reveal a name conflict between ‘b:x’ and ‘c:x’ if those
two symbols are distinct.  In this case ‘unintern’ will signal an error.

See Also:
.........

*note Section 11.1 (Package Concepts): Package Concepts.


File: ansicl,  Node: in-package,  Next: unuse-package,  Prev: unintern,  Up: Packages

in-package (Macro)
==================

Syntax:
.......

 -- Macro: in-package name → package

Arguments and Values:
.....................

NAME--a string designator; not evaluated.

PACKAGE--the package named by NAME.

Description:
............

Causes the the package named by NAME to become the current
package--that is, the value of ‘*package*’.  If no such package already
exists, an error of type ‘package-error’ is signaled.

Everything ‘in-package’ does is also performed at compile time if the
call appears as a top level form.

Side Effects:
.............

The variable ‘*package*’ is assigned.  If the ‘in-package’ form is a
top level form, this assignment also occurs at compile time.

Exceptional Situations:
.......................

An error of type ‘package-error’ is signaled if the specified package
does not exist.

See Also:
.........

*note *package*::


File: ansicl,  Node: unuse-package,  Next: use-package,  Prev: in-package,  Up: Packages

unuse-package (Function)
========================

Syntax:
.......

 -- Function: unuse-package packages-to-unuse &optional package → ‘t’

Arguments and Values:
.....................

PACKAGES-TO-UNUSE--a designator for a list of package designators.

PACKAGE--a package designator.  The default is the current package.

Description:
............

‘unuse-package’ causes PACKAGE to cease inheriting all the external
symbols of PACKAGES-TO-UNUSE; ‘unuse-package’ undoes the effects of
‘use-package’.   The PACKAGES-TO-UNUSE are removed from the use list of
PACKAGE.

Any symbols that have been imported into PACKAGE continue to be present
in PACKAGE.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (export (intern "SHOES" (make-package 'temp)) 'temp) → T
 (find-symbol "SHOES") → NIL, NIL
 (use-package 'temp) → T
 (find-symbol "SHOES") → SHOES, :INHERITED
 (find (find-package 'temp) (package-use-list 'common-lisp-user)) → #<PACKAGE "TEMP">
 (unuse-package 'temp) → T
 (find-symbol "SHOES") → NIL, NIL

Side Effects:
.............

The use list of PACKAGE is modified.

Affected By:
............

Current state of the package system.

See Also:
.........

*note use-package::, *note package-use-list::


File: ansicl,  Node: use-package,  Next: defpackage,  Prev: unuse-package,  Up: Packages

use-package (Function)
======================

Syntax:
.......

 -- Function: use-package packages-to-use &optional package → ‘t’

Arguments and Values:
.....................

PACKAGES-TO-USE--a designator for a list of package designators.  The
‘KEYWORD’ package may not be supplied.

PACKAGE--a package designator.  The default is the current package.
The PACKAGE cannot be the ‘KEYWORD’ package.

Description:
............

‘use-package’ causes PACKAGE to inherit all the external symbols of
PACKAGES-TO-USE.  The inherited symbols become accessible as internal
symbols of PACKAGE.

PACKAGES-TO-USE are added to the use list of PACKAGE if they are not
there already.  All external symbols in PACKAGES-TO-USE become
accessible in PACKAGE as internal symbols.  ‘use-package’ does not
cause any new symbols to be present in PACKAGE but only makes them
accessible by inheritance.

‘use-package’ checks for name conflicts between the newly imported
symbols and those already accessible in PACKAGE.  A name conflict in
‘use-package’ between two external symbols inherited by PACKAGE from
PACKAGES-TO-USE may be resolved in favor of either symbol by importing
one of them into PACKAGE and making it a shadowing symbol.

Examples:
.........

 (export (intern "LAND-FILL" (make-package 'trash)) 'trash) → T
 (find-symbol "LAND-FILL" (make-package 'temp)) → NIL, NIL
 (package-use-list 'temp) → (#<PACKAGE "TEMP">)
 (use-package 'trash 'temp) → T
 (package-use-list 'temp) → (#<PACKAGE "TEMP"> #<PACKAGE "TRASH">)
 (find-symbol "LAND-FILL" 'temp) → TRASH:LAND-FILL, :INHERITED

Side Effects:
.............

The use list of PACKAGE may be modified.

See Also:
.........

*note unuse-package::, *note package-use-list::, *note Section 11.1
(Package Concepts): Package Concepts.

Notes:
......

It is permissible for a package P₁ to use a package P₂ even if P₂
already uses P₁.  The using of packages is not transitive, so no
problem results from the apparent circularity.


File: ansicl,  Node: defpackage,  Next: do-symbols; do-external-symbols; do-all-symbols,  Prev: use-package,  Up: Packages

defpackage (Macro)
==================

Syntax:
.......

 -- Macro: defpackage defined-package-name 〚↓option〛 → package

OPTION::=
     {(:nicknames {nickname}*)}* |
     (:documentation string) |
     {(:use {package-name}*)}* |
     {(:shadow {↓symbol-name}*)}* |
     {(:shadowing-import-from PACKAGE-NAME {↓symbol-name}*)}* |
     {(:import-from PACKAGE-NAME {↓symbol-name}*)}* |
     {(:export {↓symbol-name}*)}* |
     {(:intern {↓symbol-name}*)}* |
     (:size integer)

Arguments and Values:
.....................

DEFINED-PACKAGE-NAME--a string designator.

PACKAGE-NAME--a package designator.

NICKNAME--a string designator.

SYMBOL-NAME--a string designator.

PACKAGE--the package named PACKAGE-NAME.

Description:
............

‘defpackage’ creates a package as specified and returns the package.

If DEFINED-PACKAGE-NAME already refers to an existing package, the
name-to-package mapping for that name is not changed.  If the new
definition is at variance with the current state of that package, the
consequences are undefined;  an implementation might choose to modify
the existing package to reflect the new definition.  If
DEFINED-PACKAGE-NAME is a symbol, its name is used.

The standard options are described below.

:nicknames
     The arguments to :nicknames set the package's nicknames to the
     supplied names.

:documentation
     The argument to :documentation specifies a documentation string;
     it is attached as a documentation string to the package.  At most
     one :documentation option can appear in a single ‘defpackage’ form.

:use
     The arguments to :use set the packages that the package named by
     PACKAGE-NAME will inherit from. If :use is not supplied, it
     defaults to the same implementation-dependent value as the :use
     argument to ‘make-package’.

:shadow
     The arguments to :shadow, SYMBOL-NAMES, name symbols that are to
     be created in the package being defined.  These symbols are added
     to the list of shadowing symbols effectively as if by ‘shadow’.

:shadowing-import-from
     The symbols named by the argument SYMBOL-NAMES are found
     (involving a lookup as if by ‘find-symbol’) in the specified
     PACKAGE-NAME.  The resulting symbols are imported into the package
     being defined, and placed on the shadowing symbols list as if by
     ‘shadowing-import’.  In no case are symbols created in any package
     other than the one being defined.

:import-from
     The symbols named by the argument SYMBOL-NAMES are found in the
     package named by PACKAGE-NAME and they are imported into the
     package being defined.  In no case are symbols created in any
     package other than the one being defined.

:export
     The symbols named by the argument SYMBOL-NAMES  are found or
     created in the package being defined and exported.  The :export
     option interacts with the :use option, since inherited symbols can
     be used rather than new ones created.  The :export option interacts
     with the :import-from and :shadowing-import-from options, since
     imported symbols can be used rather than new ones created.  If an
     argument to the :export option is accessible as an (inherited)
     internal symbol via ‘use-package’, that the symbol named by
     SYMBOL-NAME is first imported into the package being defined, and
     is then exported from that package.

:intern
     The symbols named by the argument SYMBOL-NAMES are found or
     created in the package being defined.  The :intern option
     interacts with the :use option, since inherited symbols can be
     used rather than new ones created.

:size
     The argument to the :size option declares the approximate number
     of symbols expected in the package.  This is an efficiency hint
     only and might be ignored by an implementation.

The order in which the options appear in a ‘defpackage’ form is
irrelevant.  The order in which they are executed is as follows:

  1. :shadow and :shadowing-import-from.

  2. :use.

  3. :import-from and :intern.

  4. :export.

Shadows are established first, since they might  be necessary to block
spurious name conflicts when the :use option is processed. The :use
option is executed next so that :intern and :export options can refer
to normally inherited symbols.  The :export option is executed last so
that it can refer to symbols created by any of the other options; in
particular, shadowing symbols and imported symbols can be made external.

If a defpackage form appears as a top level form, all of the actions
normally performed by this macro at load time must also be performed at
compile time.

Examples:
.........

 (defpackage "MY-PACKAGE"
   (:nicknames "MYPKG" "MY-PKG")
   (:use "COMMON-LISP")
   (:shadow "CAR" "CDR")
   (:shadowing-import-from "VENDOR-COMMON-LISP"  "CONS")
   (:import-from "VENDOR-COMMON-LISP"  "GC")
   (:export "EQ" "CONS" "FROBOLA")
   )


 (defpackage my-package
   (:nicknames mypkg :MY-PKG)  ; remember Common Lisp conventions for case
   (:use common-lisp)          ; conversion on symbols
   (:shadow CAR :cdr #:cons)
   (:export "CONS")            ; this is the shadowed one.
   )

Affected By:
............

Existing packages.

Exceptional Situations:
.......................

If one of the supplied :nicknames already refers to an existing package,
an error of type ‘package-error’ is signaled.

An error of type ‘program-error’ should be signaled if :size or
:documentation appears more than once.

Since implementations might allow extended options an error of type
‘program-error’ should be signaled if an option is present that is not
actually supported in the host implementation.

The collection of SYMBOL-NAME arguments given to the options :shadow,
:intern, :import-from, and :shadowing-import-from must all be disjoint;
additionally, the SYMBOL-NAME arguments given to :export and :intern
must be disjoint.  Disjoint in this context is defined as no two of the
SYMBOL-NAMES being ‘string=’ with each other. If either condition is
violated, an error of type ‘program-error’ should be signaled.

For the :shadowing-import-from and :import-from options, a correctable
error of type ‘package-error’ is signaled if no symbol is accessible in
the package named by PACKAGE-NAME for one of the argument SYMBOL-NAMES.

Name conflict errors are handled by the underlying calls to
‘make-package’, ‘use-package’, ‘import’, and ‘export’. See *note
Section 11.1 (Package Concepts): Package Concepts.

See Also:
.........

*note documentation::, *note Section 11.1 (Package Concepts): Package
Concepts, *note Section 3.2 (Compilation): Compilation.

Notes:
......

The :intern option is useful if an :import-from or a
:shadowing-import-from option in a subsequent call to ‘defpackage’ (for
some other package) expects to find these symbols accessible but not
necessarily external.

It is recommended that the entire package definition is put in a single
place, and that all the package definitions of a program are in a
single file.  This file can be loaded before loading or compiling
anything else that depends on those packages. Such a file can be read
in the ‘COMMON-LISP-USER’ package, avoiding any initial state issues.

‘defpackage’ cannot be used to create two "mutually recursive"
packages, such as:

 (defpackage my-package
   (:use common-lisp your-package)    ;requires your-package to exist first
   (:export "MY-FUN"))
 (defpackage your-package
   (:use common-lisp)
   (:import-from my-package "MY-FUN") ;requires my-package to exist first
   (:export "MY-FUN"))

However, nothing prevents the user from using the package-affecting
functions such as ‘use-package’, ‘import’, and ‘export’ to establish
such links after a more standard use of ‘defpackage’.

The macroexpansion of ‘defpackage’ could usefully canonicalize the names
into strings, so that even if a source file has random symbols in the
‘defpackage’ form, the compiled file would only contain strings.

Frequently additional implementation-dependent options take the form of
a keyword standing by itself as an abbreviation for a list ‘(keyword
T)’; this syntax should be properly reported as an unrecognized option
in implementations that do not support it.


File: ansicl,  Node: do-symbols; do-external-symbols; do-all-symbols,  Next: intern,  Prev: defpackage,  Up: Packages

do-symbols, do-external-symbols, do-all-symbols (Macro)
=======================================================

Syntax:
.......

 -- Macro: do-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* → {result}*

 -- Macro: do-external-symbols (var [package [result-form]])
          {declaration}* {tag | statement}* → {result}*

 -- Macro: do-all-symbols (var [result-form])
          {declaration}* {tag | statement}* → {result}*

Arguments and Values:
.....................

VAR--a variable name; not evaluated.

PACKAGE--a package designator; evaluated.  The defaults in ‘do-symbols’
and ‘do-external-symbols’ is the current package.

RESULT-FORM--a form; evaluated as described below.  The default is
‘nil’.

DECLARATION--a declare expression; not evaluated.

TAG--a go tag; not evaluated.

STATEMENT--a compound form; evaluated as described below.

RESULTS--the values returned by the RESULT-FORM if a normal return
occurs, or else, if an explicit return occurs, the values that were
transferred.

Description:
............

‘do-symbols’, ‘do-external-symbols’, and ‘do-all-symbols’ iterate over
the symbols of packages.  For each symbol in the set of packages chosen,
the VAR is bound to the symbol, and the STATEMENTS in the body are
executed.  When all the symbols have been processed, RESULT-FORM is
evaluated and returned as the value of the macro.

‘do-symbols’ iterates over the symbols accessible in PACKAGE.
STATEMENTS may execute more than once for symbols that are inherited
from multiple packages.

‘do-all-symbols’ iterates on every registered package.
‘do-all-symbols’ will not process every symbol whatsoever, because a
symbol not accessible in any registered package will not be processed.
‘do-all-symbols’ may cause a symbol that is present in several packages
to be processed more than once.

‘do-external-symbols’ iterates on the external symbols of PACKAGE.

When RESULT-FORM is evaluated, VAR is bound and has the value ‘nil’.

An implicit block named ‘nil’ surrounds the entire ‘do-symbols’,
‘do-external-symbols’, or ‘do-all-symbols’ form.  ‘return’ or
‘return-from’ may be used to terminate the iteration prematurely.

If execution of the body affects which symbols are contained in the set
of packages over which iteration is occurring, other than to remove the
symbol currently the value of VAR by using ‘unintern’, the consequences
are undefined.

For each of these macros, the scope of the name binding does not
include any initial value form, but the optional result forms are
included.

Any TAG in the body is treated as with ‘tagbody’.

Examples:
.........

 (make-package 'temp :use nil) → #<PACKAGE "TEMP">
 (intern "SHY" 'temp) → TEMP::SHY, NIL ;SHY will be an internal symbol
                                         ;in the package TEMP
 (export (intern "BOLD" 'temp) 'temp)  → T  ;BOLD will be external
 (let ((lst ()))
   (do-symbols (s (find-package 'temp)) (push s lst))
   lst)
→ (TEMP::SHY TEMP:BOLD)
or→ (TEMP:BOLD TEMP::SHY)
 (let ((lst ()))
   (do-external-symbols (s (find-package 'temp) lst) (push s lst))
   lst)
→ (TEMP:BOLD)
 (let ((lst ()))
   (do-all-symbols (s lst)
     (when (eq (find-package 'temp) (symbol-package s)) (push s lst)))
   lst)
→ (TEMP::SHY TEMP:BOLD)
or→ (TEMP:BOLD TEMP::SHY)

See Also:
.........

*note intern::, *note export::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: intern,  Next: package-name,  Prev: do-symbols; do-external-symbols; do-all-symbols,  Up: Packages

intern (Function)
=================

Syntax:
.......

 -- Function: intern string &optional package → symbol, status

Arguments and Values:
.....................

STRING--a string.

PACKAGE--a package designator.  The default is the current package.

SYMBOL--a symbol.

STATUS--one of :inherited, :external, :internal, or ‘nil’.

Description:
............

‘intern’ enters a symbol named STRING into PACKAGE.  If a symbol whose
name is the same as STRING is already accessible in PACKAGE, it is
returned.  If no such symbol is accessible in PACKAGE, a new symbol
with the given name is created and entered into PACKAGE as an internal
symbol, or as an external symbol if the PACKAGE is the ‘KEYWORD’
package; PACKAGE becomes the home package of the created symbol.

The first value returned by ‘intern’, SYMBOL, is the symbol that was
found or created.  The meaning of the secondary value, STATUS, is as
follows:

:internal
     The symbol was found and is present in PACKAGE as an internal
     symbol.

:external
     The symbol was found and is present as an external symbol.

:inherited
     The symbol was found and is inherited via ‘use-package’ (which
     implies that the symbol is internal).

‘nil’
     No pre-existing symbol was found, so one was created.

     It is implementation-dependent whether the string that becomes the
     new symbol's name is the given STRING or a copy of it.  Once a
     string has been given as the STRING argument to intern in this
     situation where a new symbol is created, the consequences are
     undefined if a subsequent attempt is made to alter that string.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (intern "Never-Before") → |Never-Before|, NIL
 (intern "Never-Before") → |Never-Before|, :INTERNAL
 (intern "NEVER-BEFORE" "KEYWORD") → :NEVER-BEFORE, NIL
 (intern "NEVER-BEFORE" "KEYWORD") → :NEVER-BEFORE, :EXTERNAL

See Also:
.........

*note find-symbol::, *note read::, *note symbol::, *note unintern::,
*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens.

Notes:
......

‘intern’ does not need to do any name conflict checking because it
never creates a new symbol if there is already an accessible symbol
with the name given.


File: ansicl,  Node: package-name,  Next: package-nicknames,  Prev: intern,  Up: Packages

package-name (Function)
=======================

Syntax:
.......

 -- Function: package-name package → name

Arguments and Values:
.....................

PACKAGE--a package designator.

NAME--a string or ‘nil’.

Description:
............

‘package-name’ returns the string that names PACKAGE, or ‘nil’ if the
PACKAGE designator is a package object that has no name (see the
function *note delete-package::).

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 (package-name *package*) → "COMMON-LISP-USER"
 (package-name (symbol-package :test)) → "KEYWORD"
 (package-name (find-package 'common-lisp)) → "COMMON-LISP"

 (defvar *foo-package* (make-package "FOO"))
 (rename-package "FOO" "FOO0")
 (package-name *foo-package*) → "FOO0"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.


File: ansicl,  Node: package-nicknames,  Next: package-shadowing-symbols,  Prev: package-name,  Up: Packages

package-nicknames (Function)
============================

Syntax:
.......

 -- Function: package-nicknames package → nicknames

Arguments and Values:
.....................

PACKAGE--a package designator.

NICKNAMES--a list of strings.

Description:
............

Returns the list of nickname strings for PACKAGE, not including the
name of PACKAGE.

Examples:
.........

 (package-nicknames (make-package 'temporary
                                   :nicknames '("TEMP" "temp")))
→ ("temp" "TEMP")

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.


File: ansicl,  Node: package-shadowing-symbols,  Next: package-use-list,  Prev: package-nicknames,  Up: Packages

package-shadowing-symbols (Function)
====================================

Syntax:
.......

 -- Function: package-shadowing-symbols package → symbols

Arguments and Values:
.....................

PACKAGE--a package designator.

SYMBOLS--a list of symbols.

Description:
............

Returns a list of symbols that have been declared as shadowing symbols
in PACKAGE by ‘shadow’ or ‘shadowing-import’ (or the equivalent
‘defpackage’ options).  All symbols on this list are present in PACKAGE.

Examples:
.........

 (package-shadowing-symbols (make-package 'temp)) → ()
 (shadow 'cdr 'temp) → T
 (package-shadowing-symbols 'temp) → (TEMP::CDR)
 (intern "PILL" 'temp) → TEMP::PILL, NIL
 (shadowing-import 'pill 'temp) → T
 (package-shadowing-symbols 'temp) → (PILL TEMP::CDR)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note shadow::, *note shadowing-import::

Notes:
......

Whether the list of SYMBOLS is fresh is implementation-dependent.


File: ansicl,  Node: package-use-list,  Next: package-used-by-list,  Prev: package-shadowing-symbols,  Up: Packages

package-use-list (Function)
===========================

Syntax:
.......

 -- Function: package-use-list package → use-list

Arguments and Values:
.....................

PACKAGE--a package designator.

USE-LIST--a list of package objects.

Description:
............

Returns a list of other packages used by PACKAGE.

Examples:
.........

 (package-use-list (make-package 'temp)) → (#<PACKAGE "COMMON-LISP">)
 (use-package 'common-lisp-user 'temp) → T
 (package-use-list 'temp) → (#<PACKAGE "COMMON-LISP"> #<PACKAGE "COMMON-LISP-USER">)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note use-package::, *note unuse-package::


File: ansicl,  Node: package-used-by-list,  Next: packagep,  Prev: package-use-list,  Up: Packages

package-used-by-list (Function)
===============================

Syntax:
.......

 -- Function: package-used-by-list package → used-by-list

Arguments and Values:
.....................

PACKAGE--a package designator.

USED-BY-LIST--a list of package objects.

Description:
............

‘package-used-by-list’ returns a list of other packages that use
PACKAGE.

Examples:
.........

 (package-used-by-list (make-package 'temp)) → ()
 (make-package 'trash :use '(temp)) → #<PACKAGE "TRASH">
 (package-used-by-list 'temp) → (#<PACKAGE "TRASH">)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PACKAGE is not a package.

See Also:
.........

*note use-package::, *note unuse-package::


File: ansicl,  Node: packagep,  Next: *package*,  Prev: package-used-by-list,  Up: Packages

packagep (Function)
===================

Syntax:
.......

 -- Function: packagep object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘package’; otherwise, returns false.

Examples:
.........

 (packagep *package*) → true
 (packagep 'common-lisp) → false
 (packagep (find-package 'common-lisp)) → true

Notes:
......

 (packagep OBJECT) ≡ (typep OBJECT 'package)


File: ansicl,  Node: *package*,  Next: package-error,  Prev: packagep,  Up: Packages

*package* (Variable)
====================

Value Type:
...........

a package object.

Initial Value:
..............

the ‘COMMON-LISP-USER’ package.

Description:
............

Whatever package object is currently the value of ‘*package*’ is
referred to as the current package.

Examples:
.........

 (in-package "COMMON-LISP-USER") → #<PACKAGE "COMMON-LISP-USER">
 *package* → #<PACKAGE "COMMON-LISP-USER">
 (make-package "SAMPLE-PACKAGE" :use '("COMMON-LISP"))
→ #<PACKAGE "SAMPLE-PACKAGE">
 (list
   (symbol-package
     (let ((*package* (find-package 'sample-package)))
       (setq *some-symbol* (read-from-string "just-testing"))))
   *package*)
→ (#<PACKAGE "SAMPLE-PACKAGE"> #<PACKAGE "COMMON-LISP-USER">)
 (list (symbol-package (read-from-string "just-testing"))
       *package*)
→ (#<PACKAGE "COMMON-LISP-USER"> #<PACKAGE "COMMON-LISP-USER">)
 (eq 'foo (intern "FOO")) → true
 (eq 'foo (let ((*package* (find-package 'sample-package)))
            (intern "FOO")))
→ false

Affected By:
............

‘load’, ‘compile-file’, ‘in-package’

See Also:
.........

*note compile-file::, *note in-package::, *note load::, *note package::


File: ansicl,  Node: package-error,  Next: package-error-package,  Prev: *package*,  Up: Packages

package-error (Condition Type)
==============================

Class Precedence List:
......................

‘package-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘package-error’ consists of error conditions related to
operations on packages.  The offending package (or package name) is
initialized by the :package initialization argument to ‘make-condition’,
and is accessed by the function ‘package-error-package’.

See Also:
.........

*note package-error-package::, *note Chapter 9 (Conditions): Conditions.


File: ansicl,  Node: package-error-package,  Prev: package-error,  Up: Packages

package-error-package (Function)
================================

Syntax:
.......

 -- Function: package-error-package condition → package

Arguments and Values:
.....................

CONDITION--a condition of type ‘package-error’.

PACKAGE--a package designator.

Description:
............

Returns a designator for the offending package in the situation
represented by the CONDITION.

Examples:
.........

 (package-error-package
   (make-condition 'package-error
     :package (find-package "COMMON-LISP")))
→ #<Package "COMMON-LISP">

See Also:
.........

*note package-error::


File: ansicl,  Node: Numbers,  Next: Characters,  Prev: Packages,  Up: Top

12 Numbers
**********

* Menu:

* Number Concepts::

Dictionary

* number::
* complex (System Class)::
* real::
* float (System Class)::
* short-float; single-float; double-float; long-float::
* rational (System Class)::
* ratio::
* integer::
* signed-byte::
* unsigned-byte::
* mod (Type Specifier)::
* bit (Type)::
* fixnum::
* bignum::
* =; /=; <; >; <=; >=::
* max; min::
* minusp; plusp::
* zerop::
* floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround::
* sin; cos; tan::
* asin; acos; atan::
* pi::
* sinh; cosh; tanh; asinh; acosh; atanh::
* * (Function)::
* + (Function)::
* - (Function)::
* / (Function)::
* 1+; 1-::
* abs::
* evenp; oddp::
* exp; expt::
* gcd::
* incf; decf::
* lcm::
* log::
* mod; rem::
* signum::
* sqrt; isqrt::
* random-state::
* make-random-state::
* random::
* random-state-p::
* *random-state*::
* numberp::
* cis::
* complex (Function)::
* complexp::
* conjugate::
* phase::
* realpart; imagpart::
* upgraded-complex-part-type::
* realp::
* numerator; denominator::
* rational; rationalize::
* rationalp::
* ash::
* integer-length::
* integerp::
* parse-integer::
* boole::
* boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+::
* logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+::
* logbitp::
* logcount::
* logtest::
* byte; byte-size; byte-position::
* deposit-field::
* dpb::
* ldb::
* ldb-test::
* mask-field::
* most-positive-fixnum; most-negative-fixnum::
* decode-float; scale-float; float-radix; float-sign; float-digits; float+::
* float (Function)::
* floatp::
* most-positive-short-float; least-positive-short-float; least-positive-n+::
* short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+::
* arithmetic-error::
* arithmetic-error-operands; arithmetic-error-operation::
* division-by-zero::
* floating-point-invalid-operation::
* floating-point-inexact::
* floating-point-overflow::
* floating-point-underflow::


File: ansicl,  Node: Number Concepts,  Next: number,  Up: Numbers

12.1 Number Concepts
====================

* Menu:

* Numeric Operations::
* Implementation-Dependent Numeric Constants::
* Rational Computations::
* Floating-point Computations::
* Complex Computations::
* Interval Designators::
* Random-State Operations::


File: ansicl,  Node: Numeric Operations,  Next: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.1 Numeric Operations
-------------------------

Common Lisp provides a large variety of operations related to numbers.
This section provides an overview of those operations by grouping them
into categories that emphasize some of the relationships among them.

The next figure shows operators relating to arithmetic operations.

*   1+          gcd
+   1-          incf
-   conjugate   lcm
/   decf        

Figure 12.1: Operators relating to Arithmetic.

The next figure shows defined names relating to exponential,
logarithmic, and trigonometric operations.

abs     cos     signum
acos    cosh    sin
acosh   exp     sinh
asin    expt    sqrt
asinh   isqrt   tan
atan    log     tanh
atanh   phase   
cis     pi      

Figure 12.2: Defined names relating to Exponentials, Logarithms, and
Trigonometry.

The next figure shows operators relating to numeric comparison and
predication.

/=   >=       oddp
<    evenp    plusp
<=   max      zerop
=    min      
>    minusp   

Figure 12.3: Operators for numeric comparison and predication.

The next figure shows defined names relating to numeric type
manipulation and coercion.

ceiling           float-radix            rational
complex           float-sign             rationalize
decode-float      floor                  realpart
denominator       fround                 rem
fceiling          ftruncate              round
ffloor            imagpart               scale-float
float             integer-decode-float   truncate
float-digits      mod                    
float-precision   numerator              

Figure 12.4: Defined names relating to numeric type manipulation and
coercion.

12.1.1.1 Associativity and Commutativity in Numeric Operations
..............................................................

For functions that are mathematically associative (and possibly
commutative), a conforming implementation may process the arguments in
any manner consistent with associative (and possibly commutative)
rearrangement.  This does not affect the order in which the argument
forms are evaluated; for a discussion of evaluation order, see *note
Section 3.1.2.1.2.3 (Function Forms): FunctionForms.  What is
unspecified is only the order in which the parameter values are
processed.  This implies that implementations may differ in which
automatic coercions are applied; see *note Section 12.1.1.2 (Contagion
in Numeric Operations): NumericContagionRules.

A conforming program can control the order of processing explicitly by
separating the operations into separate (possibly nested) function
forms, or by writing explicit calls to functions that perform coercions.

12.1.1.1.1 Examples of Associativity and Commutativity in Numeric Operations
............................................................................

Consider the following expression, in which we assume that ‘1.0’ and
‘1.0e-15’ both denote single floats:

 (+ 1/3 2/3 1.0d0 1.0 1.0e-15)

One conforming implementation might process the arguments from left to
right, first adding ‘1/3’ and ‘2/3’ to get ‘1’, then converting that to
a double float for combination with ‘1.0d0’, then successively
converting and adding ‘1.0’ and ‘1.0e-15’.

Another conforming implementation might process the arguments from
right to left, first performing a single float addition of ‘1.0’ and
‘1.0e-15’ (perhaps losing accuracy in the process), then converting the
sum to a double float and adding ‘1.0d0’, then converting ‘2/3’ to a
double float and adding it, and then converting ‘1/3’ and adding that.

A third conforming implementation might first scan all the arguments,
process all the rationals first to keep that part of the computation
exact, then find an argument of the largest floating-point format among
all the arguments and add that, and then add in all other arguments,
converting each in turn (all in a perhaps misguided attempt to make the
computation as accurate as possible).

In any case, all three strategies are legitimate.

A conforming program could control the order by writing, for example,

 (+ (+ 1/3 2/3) (+ 1.0d0 1.0e-15) 1.0)

12.1.1.2 Contagion in Numeric Operations
........................................

For information about the contagion rules for implicit coercions of
arguments in numeric operations, see *note Section 12.1.4.4 (Rule of
Float Precision Contagion): RuleOfFloatPrecisionContagion, *note
Section 12.1.4.1 (Rule of Float and Rational Contagion):
RuleOfFloatAndRationalContagion, and *note Section 12.1.5.2 (Rule of
Complex Contagion): RuleOfComplexContagion.

12.1.1.3 Viewing Integers as Bits and Bytes
...........................................

12.1.1.3.1 Logical Operations on Integers
.........................................

Logical operations require integers as arguments; an error of type
‘type-error’ should be signaled if an argument is supplied that is not
an integer.  Integer arguments to logical operations are treated as if
they were represented in two's-complement notation.

The next figure shows defined names relating to logical operations on
numbers.

ash           boole-ior        logbitp
boole         boole-nand       logcount
boole-1       boole-nor        logeqv
boole-2       boole-orc1       logior
boole-and     boole-orc2       lognand
boole-andc1   boole-set        lognor
boole-andc2   boole-xor        lognot
boole-c1      integer-length   logorc1
boole-c2      logand           logorc2
boole-clr     logandc1         logtest
boole-eqv     logandc2         logxor

Figure 12.5: Defined names relating to logical operations on numbers.

12.1.1.3.2 Byte Operations on Integers
......................................

The byte-manipulation functions use objects called byte specifiers to
designate the size and position of a specific byte within an integer.
The representation of a byte specifier is implementation-dependent; it
might or might not be a number.  The function ‘byte’ will construct a
byte specifier, which various other byte-manipulation functions will
accept.

The next figure shows defined names relating to manipulating bytes of
numbers.

byte            deposit-field   ldb-test
byte-position   dpb             mask-field
byte-size       ldb             

Figure 12.6: Defined names relating to byte manipulation.


File: ansicl,  Node: Implementation-Dependent Numeric Constants,  Next: Rational Computations,  Prev: Numeric Operations,  Up: Number Concepts

12.1.2 Implementation-Dependent Numeric Constants
-------------------------------------------------

The next figure shows defined names relating to
implementation-dependent details about numbers.

double-float-epsilon            most-negative-fixnum
double-float-negative-epsilon   most-negative-long-float
least-negative-double-float     most-negative-short-float
least-negative-long-float       most-negative-single-float
least-negative-short-float      most-positive-double-float
least-negative-single-float     most-positive-fixnum
least-positive-double-float     most-positive-long-float
least-positive-long-float       most-positive-short-float
least-positive-short-float      most-positive-single-float
least-positive-single-float     short-float-epsilon
long-float-epsilon              short-float-negative-epsilon
long-float-negative-epsilon     single-float-epsilon
most-negative-double-float      single-float-negative-epsilon

Figure 12.7: Defined names relating to implementation-dependent details
about numbers.


File: ansicl,  Node: Rational Computations,  Next: Floating-point Computations,  Prev: Implementation-Dependent Numeric Constants,  Up: Number Concepts

12.1.3 Rational Computations
----------------------------

The rules in this section apply to rational computations.

12.1.3.1 Rule of Unbounded Rational Precision
.............................................

Rational computations cannot overflow in the usual sense (though there
may not be enough storage to represent a result), since integers and
ratios may in principle be of any magnitude.

12.1.3.2 Rule of Canonical Representation for Rationals
.......................................................

If any computation produces a result that is a mathematical ratio of
two integers such that the denominator evenly divides the numerator,
then the result is converted to the equivalent integer.

If the denominator does not evenly divide the numerator, the canonical
representation of a rational number is as the ratio that numerator and
that denominator, where the greatest common divisor of the numerator
and denominator is one, and where the denominator is positive and
greater than one.

When used as input (in the default syntax), the notation ‘-0’ always
denotes the integer ‘0’.  A conforming implementation must not have a
representation of "minus zero" for integers that is distinct from its
representation of zero for integers.  However, such a distinction is
possible for floats; see the type ‘float’.

12.1.3.3 Rule of Float Substitutability
.......................................

When the arguments to an irrational mathematical function

are all rational and the true mathematical result is also
(mathematically) rational, then unless otherwise noted an
implementation is free to return either an accurate rational result or
a single float approximation.  If the arguments are all rational but
the result cannot be expressed as a rational number, then a single float
approximation is always returned.

If the arguments to an irrational mathematical function are all of type
‘(or rational (complex rational))’ and the true mathematical result is
(mathematically) a complex number with rational real and imaginary
parts, then unless otherwise noted an implementation is free to return
either an accurate result of type ‘(or rational (complex rational))’ or
a single float (permissible only if the imaginary part of the true
mathematical result is zero) or ‘(complex single-float)’. If the
arguments are all of type ‘(or rational (complex rational))’ but the
result cannot be expressed as a rational or complex rational, then the
returned value will be of type ‘single-float’ (permissible only if the
imaginary part of the true mathematical result is zero) or ‘(complex
single-float)’.

Float substitutability applies neither to the rational functions ‘+’,
‘-’, ‘*’, and ‘/’ nor to the related operators ‘1+’, ‘1-’, ‘incf’,
‘decf’, and ‘conjugate’.  For rational functions, if all arguments are
rational, then the result is rational; if all arguments are of type
‘(or rational (complex rational))’, then the result is of type ‘(or
rational (complex rational))’.

Function   Sample Results
------------------------------------------------------------- 
‘abs’      ‘(abs #c(3 4)) → 5 or 5.0’
‘acos’     ‘(acos 1) → 0 or 0.0’
‘acosh’    ‘(acosh 1) → 0 or 0.0’
‘asin’     ‘(asin 0) → 0 or 0.0’
‘asinh’    ‘(asinh 0) → 0 or 0.0’
‘atan’     ‘(atan 0) → 0 or 0.0’
‘atanh’    ‘(atanh 0) → 0 or 0.0’
‘cis’      ‘(cis 0) → 1 or #c(1.0 0.0)’
‘cos’      ‘(cos 0) → 1 or 1.0’
‘cosh’     ‘(cosh 0) → 1 or 1.0’
‘exp’      ‘(exp 0) → 1 or 1.0’
‘expt’     ‘(expt 8 1/3) → 2 or 2.0’
‘log’      ‘(log 1) → 0 or 0.0’
           ‘(log 8 2) → 3 or 3.0’
‘phase’    ‘(phase 7) → 0 or 0.0’
‘signum’   ‘(signum #c(3 4)) → #c(3/5 4/5) or #c(0.6 0.8)’
‘sin’      ‘(sin 0) → 0 or 0.0’
‘sinh’     ‘(sinh 0) → 0 or 0.0’
‘sqrt’     ‘(sqrt 4) → 2 or 2.0’
           ‘(sqrt 9/16) → 3/4 or 0.75’
‘tan’      ‘(tan 0) → 0 or 0.0’
‘tanh’     ‘(tanh 0) → 0 or 0.0’

Figure 12.8: Functions Affected by Rule of Float Substitutability


File: ansicl,  Node: Floating-point Computations,  Next: Complex Computations,  Prev: Rational Computations,  Up: Number Concepts

12.1.4 Floating-point Computations
----------------------------------

The following rules apply to floating point computations.

12.1.4.1 Rule of Float and Rational Contagion
.............................................

When rationals and floats are combined by a numerical function, the
rational is first converted to a float of the same format.  For
functions such as ‘+’ that take more than two arguments, it is
permitted that part of the operation be carried out exactly using
rationals and the rest be done using floating-point arithmetic.

When rationals and floats are compared by a numerical function, the
function ‘rational’ is effectively called to convert the float to a
rational and then an exact comparison is performed. In the case of
complex numbers, the real and imaginary parts are effectively handled
individually.

12.1.4.1.1 Examples of Rule of Float and Rational Contagion
...........................................................

 ;;;; Combining rationals with floats.
 ;;; This example assumes an implementation in which
 ;;; (float-radix 0.5) is 2 (as in IEEE) or 16 (as in IBM/360),
 ;;; or else some other implementation in which 1/2 has an exact
 ;;;  representation in floating point.
 (+ 1/2 0.5) → 1.0
 (- 1/2 0.5d0) → 0.0d0
 (+ 0.5 -0.5 1/2) → 0.5

 ;;;; Comparing rationals with floats.
 ;;; This example assumes an implementation in which the default float
 ;;; format is IEEE single-float, IEEE double-float, or some other format
 ;;; in which 5/7 is rounded upwards by FLOAT.
 (< 5/7 (float 5/7)) → true
 (< 5/7 (rational (float 5/7))) → true
 (< (float 5/7) (float 5/7)) → false

12.1.4.2 Rule of Float Approximation
....................................

Computations with floats are only approximate, although they are
described as if the results were mathematically accurate.  Two
mathematically identical expressions may be computationally different
because of errors inherent in the floating-point approximation process.
The precision of a float is not necessarily correlated with the
accuracy of that number.  For instance, 3.142857142857142857 is a more
precise approximation to π than 3.14159, but the latter is more
accurate.  The precision refers to the number of bits retained in the
representation.  When an operation combines a short float with a long
float, the result will be a long float.  Common Lisp functions assume
that the accuracy of arguments to them does not exceed their precision.
Therefore when two small floats are combined, the result is a small
float.  Common Lisp functions never convert automatically from a larger
size to a smaller one.

12.1.4.3 Rule of Float Underflow and Overflow
.............................................

An error of type ‘floating-point-overflow’ or
‘floating-point-underflow’ should be signaled if a floating-point
computation causes exponent overflow or underflow, respectively.

12.1.4.4 Rule of Float Precision Contagion
..........................................

The result of a numerical function is a float of the largest format
among all the floating-point arguments to the function.


File: ansicl,  Node: Complex Computations,  Next: Interval Designators,  Prev: Floating-point Computations,  Up: Number Concepts

12.1.5 Complex Computations
---------------------------

The following rules apply to complex computations:

12.1.5.1 Rule of Complex Substitutability
.........................................

Except during the execution of irrational and transcendental functions,
no numerical function ever yields a complex unless one or more of its
arguments is a complex.

12.1.5.2 Rule of Complex Contagion
..................................

When a real and a complex are both part of a computation, the real is
first converted to a complex by providing an imaginary part of ‘0’.

12.1.5.3 Rule of Canonical Representation for Complex Rationals
...............................................................

If the result of any computation would be a complex number whose real
part is of type ‘rational’ and whose imaginary part is zero, the result
is converted to the rational which is the real part.  This rule does
not apply to complex numbers whose parts are floats.  For example,
‘#C(5 0)’ and ‘5’ are not different objects in Common Lisp (they are
always the same under ‘eql’); ‘#C(5.0 0.0)’ and ‘5.0’ are always
different objects in Common Lisp (they are never the same under ‘eql’,
although they are the same under ‘equalp’ and ‘=’).

12.1.5.3.1 Examples of Rule of Canonical Representation for Complex Rationals
.............................................................................

 #c(1.0 1.0) → #C(1.0 1.0)
 #c(0.0 0.0) → #C(0.0 0.0)
 #c(1.0 1) → #C(1.0 1.0)
 #c(0.0 0) → #C(0.0 0.0)
 #c(1 1) → #C(1 1)
 #c(0 0) → 0
 (typep #c(1 1) '(complex (eql 1))) → true
 (typep #c(0 0) '(complex (eql 0))) → false

12.1.5.4 Principal Values and Branch Cuts
.........................................

Many of the irrational and transcendental functions are multiply defined
in the complex domain; for example, there are in general an infinite
number of complex values for the logarithm function.  In each such
case, a principal value must be chosen for the function to return.  In
general, such values cannot be chosen so as to make the range
continuous; lines in the domain called branch cuts must be defined,
which in turn define the discontinuities in the range.  Common
Lisp defines the branch cuts, principal values, and boundary conditions
for the complex functions following "Principal Values and Branch Cuts
in Complex APL." The branch cut rules that apply to each function are
located with the description of that function.

The next figure lists the identities that are obeyed throughout the
applicable portion of the complex domain, even on the branch cuts:

sin i z = i sinh z   sinh i z = i sin z         arctan  i z = i arctanh z
cos i z = cosh z     cosh i z = cos z           arcsinh i z = i arcsin z
tan i z = i tanh z   arcsin i z = i arcsinh z   arctanh i z = i arctan z

Figure 12.9: Trigonometric Identities for Complex Domain

The quadrant numbers referred to in the discussions of branch cuts are
as illustrated in the next figure.

                               Positive
                            Imaginary Axis

                                   :
                               II  :  I
                                   :
    Negative Real Axis .......................  Positive Real Axis
                                   :
                              III  :  IV
                                   :

                               Negative
                            Imaginary Axis

Figure 12.10: Quadrant Numbering for Branch Cuts


File: ansicl,  Node: Interval Designators,  Next: Random-State Operations,  Prev: Complex Computations,  Up: Number Concepts

12.1.6 Interval Designators
---------------------------

The compound type specifier form of the numeric type specifiers permit
the user to specify an interval on the real number line which describe
a subtype of the type which would be described by the corresponding
atomic type specifier.  A subtype of some type T is specified using an
ordered pair of objects called interval designators for type T.

The first of the two interval designators for type T can be any of the
following:

a number N of type T
     This denotes a lower inclusive bound of N.  That is, elements of
     the subtype of T will be greater than or equal to N.

a singleton list whose element is a number M of type T
     This denotes a lower exclusive bound of M.  That is, elements of
     the subtype of T will be greater than M.

the symbol *
     This denotes the absence of a lower bound on the interval.

The second of the two interval designators for type T can be any of the
following:

a number N of type T
     This denotes an upper inclusive bound of N.  That is, elements of
     the subtype of T will be less than or equal to N.

a singleton list whose element is a number M of type T
     This denotes an upper exclusive bound of M.  That is, elements of
     the subtype of T will be less than M.

the symbol *
     This denotes the absence of an upper bound on the interval.


File: ansicl,  Node: Random-State Operations,  Prev: Interval Designators,  Up: Number Concepts

12.1.7 Random-State Operations
------------------------------

The next figure lists some defined names that are applicable to random
states.

*random-state*      random           
make-random-state   random-state-p   

Figure 12.11: Random-state defined names


File: ansicl,  Node: number,  Next: complex (System Class),  Prev: Number Concepts,  Up: Numbers

number (System Class)
=====================

Class Precedence List:
......................

‘number’, ‘t’

Description:
............

The type ‘number’ contains objects which represent mathematical numbers.
The types ‘real’ and ‘complex’ are disjoint subtypes of ‘number’.

The function ‘=’ tests for numerical equality.  The function ‘eql’,
when its arguments are both numbers, tests that they have both the same
type and numerical value.  Two numbers that are the same under ‘eql’ or
‘=’ are not necessarily the same under ‘eq’.

Notes:
......

Common Lisp differs from mathematics on some naming issues.  In
mathematics, the set of real numbers is traditionally described as a
subset of the complex numbers, but in Common Lisp, the type ‘real’ and
the type ‘complex’ are disjoint.  The Common Lisp type which includes
all mathematical complex numbers is called ‘number’.  The reasons for
these differences include historical precedent, compatibility with most
other popular computer languages, and various issues of time and space
efficiency.


File: ansicl,  Node: complex (System Class),  Next: real,  Prev: number,  Up: Numbers

complex (System Class)
======================

Class Precedence List:
......................

‘complex’, ‘number’, ‘t’

Description:
............

The type ‘complex’ includes all mathematical complex numbers other than
those included in the type ‘rational’.  Complexes are expressed in
Cartesian form with a real part and an imaginary part, each of which is
a real.  The real part and imaginary part are either both rational or
both of the same float type.  The imaginary part can be a float zero,
but can never be a rational zero, for such a number is always
represented by Common Lisp as a rational rather than a complex.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(complex [typespec | *])

Compound Type Specifier Arguments:
..................................

TYPESPEC--a type specifier that denotes a subtype of type ‘real’.

Compound Type Specifier Description:
....................................

Every element of this type is a complex whose real part and imaginary
part are each of type ‘(upgraded-complex-part-type TYPESPEC)’.  This
type encompasses those complexes that can result by giving numbers of
type TYPESPEC to ‘complex’.

‘(complex TYPE-SPECIFIER)’ refers to all complexes that can result from
giving numbers of TYPE TYPE-SPECIFIER to the function ‘complex’, plus
all other complexes of the same specialized representation.

See Also:
.........

*note Section 12.1.5.3 (Rule of Canonical Representation for Complex
Rationals): RuleOfCanonRepForComplexRationals, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.4 (Printing Complexes): PrintingComplexes.

Notes:
......

The input syntax for a complex with real part r and imaginary part i is
‘#C(r i)’.  For further details, see *note Section 2.4 (Standard Macro
Characters): Standard Macro Characters.

For every float, n, there is a complex which represents the same
mathematical number and which can be obtained by ‘(COERCE n 'COMPLEX)’.


File: ansicl,  Node: real,  Next: float (System Class),  Prev: complex (System Class),  Up: Numbers

real (System Class)
===================

Class Precedence List:
......................

‘real’, ‘number’, ‘t’

Description:
............

The type ‘real’ includes all numbers that represent mathematical real
numbers, though there are mathematical real numbers (e.g., irrational
numbers) that do not have an exact representation in Common Lisp.  Only
reals can be ordered using the ‘<’, ‘>’, ‘<=’, and ‘>=’ functions.

The types ‘rational’ and ‘float’ are disjoint subtypes of type ‘real’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(real [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ‘real’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the reals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: ansicl,  Node: float (System Class),  Next: short-float; single-float; double-float; long-float,  Prev: real,  Up: Numbers

float (System Class)
====================

Class Precedence List:
......................

‘float’, ‘real’, ‘number’, ‘t’

Description:
............

A float is a mathematical rational (but not a Common Lisp rational) of
the form s· f· b^e-p, where s is +1 or -1, the sign; b is an integer
greater than 1, the base or radix of the representation; p is a
positive integer, the precision (in base-b digits) of the float; f is a
positive integer between b^p-1 and b^p-1 (inclusive), the significand;
and e is an integer, the exponent.  The value of p and the range of e
depends on the implementation and on the type of float within that
implementation. In addition, there is a floating-point zero; depending
on the implementation, there can also be a "minus zero". If there is no
minus zero, then 0.0 and -0.0 are both interpreted as simply a
floating-point zero.  ‘(= 0.0 -0.0)’ is always true.  If there is a
minus zero, ‘(eql -0.0 0.0)’ is false, otherwise it is true.

The types ‘short-float’, ‘single-float’, ‘double-float’, and
‘long-float’ are subtypes of type ‘float’.  Any two of them must be
either disjoint types or the same type; if the same type, then any
other types between them in the above ordering must also be the same
type.  For example, if the type ‘single-float’ and the type
‘long-float’ are the same type, then the type ‘double-float’ must be
the same type also.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(float [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ‘float’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the floats on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.3 (Printing Floats): PrintingFloats.

Notes:
......

Note that all mathematical integers are representable not only as
Common Lisp reals, but also as complex floats.  For example, possible
representations of the mathematical number 1 include the integer ‘1’,
the float ‘1.0’, or the complex ‘#C(1.0 0.0)’.


File: ansicl,  Node: short-float; single-float; double-float; long-float,  Next: rational (System Class),  Prev: float (System Class),  Up: Numbers

short-float, single-float, double-float, long-float (Type)
==========================================================

Supertypes:
...........

‘short-float’: ‘short-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘single-float’: ‘single-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘double-float’: ‘double-float’, ‘float’, ‘real’, ‘number’, ‘t’

‘long-float’: ‘long-float’, ‘float’, ‘real’, ‘number’, ‘t’

Description:
............

For the four defined subtypes of type ‘float’, it is true that
intermediate between the type ‘short-float’ and the type ‘long-float’
are the type ‘single-float’ and the type ‘double-float’.  The precise
definition of these categories is implementation-defined.  The
precision (measured in "bits", computed as plog₂b) and the exponent
size (also measured in "bits," computed as log₂(n+1), where n is the
maximum exponent value) is recommended to be at least as great as the
values in the next figure.  Each of the defined subtypes of type
‘float’ might or might not have a minus zero.

Format   Minimum Precision   Minimum Exponent Size
Short    13 bits             5 bits
Single   24 bits             8 bits
Double   50 bits             8 bits
Long     50 bits             8 bits

Figure 12.12: Recommended Minimum Floating-Point Precision and Exponent
Size

There can be fewer than four internal representations for floats.  If
there are fewer distinct representations, the following rules apply:

   - If there is only one, it is the type ‘single-float’.  In this
     representation, an object is simultaneously of types
     ‘single-float’, ‘double-float’, ‘short-float’, and ‘long-float’.

   - Two internal representations can be arranged in either of the
     following ways:

        * Two types are provided: ‘single-float’ and ‘short-float’.  An
          object is simultaneously of types ‘single-float’,
          ‘double-float’, and ‘long-float’.

        * Two types are provided: ‘single-float’ and ‘double-float’. An
          object is simultaneously of types ‘single-float’ and
          ‘short-float’, or ‘double-float’ and ‘long-float’.

   - Three internal representations can be arranged in either of the
     following ways:

        * Three types are provided: ‘short-float’, ‘single-float’, and
          ‘double-float’.  An object can simultaneously be of type
          ‘double-float’ and ‘long-float’.

        * Three types are provided: ‘single-float’, ‘double-float’, and
          ‘long-float’. An object can simultaneously be of types
          ‘single-float’ and ‘short-float’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(short-float [short-lower-limit   [short-upper-limit]]) (single-float
[single-lower-limit [single-upper-limit]]) (double-float
[double-lower-limit [double-upper-limit]]) (long-float
[long-lower-limit     [long-upper-limit]])

Compound Type Specifier Arguments:
..................................

SHORT-LOWER-LIMIT, SHORT-UPPER-LIMIT--interval designators for type
‘short-float’.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT is
the symbol *.

SINGLE-LOWER-LIMIT, SINGLE-UPPER-LIMIT--interval designators for type
‘single-float’.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT
is the symbol *.

DOUBLE-LOWER-LIMIT, DOUBLE-UPPER-LIMIT--interval designators for type
‘double-float’.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT
is the symbol *.

LONG-LOWER-LIMIT, LONG-UPPER-LIMIT--interval designators for type
‘long-float’.  The defaults for each of LOWER-LIMIT and UPPER-LIMIT is
the symbol *.

Compound Type Specifier Description:
....................................

Each of these denotes the set of floats of the indicated type that are
on the interval specified by the interval designators.


File: ansicl,  Node: rational (System Class),  Next: ratio,  Prev: short-float; single-float; double-float; long-float,  Up: Numbers

rational (System Class)
=======================

Class Precedence List:
......................

‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The canonical representation of a rational is as an integer if its
value is integral, and otherwise as a ratio.

The types ‘integer’ and ‘ratio’ are disjoint subtypes of type
‘rational’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(rational [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ‘rational’.
The defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the rationals on the interval described by LOWER-LIMIT and
UPPER-LIMIT.


File: ansicl,  Node: ratio,  Next: integer,  Prev: rational (System Class),  Up: Numbers

ratio (System Class)
====================

Class Precedence List:
......................

‘ratio’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

A ratio is a number representing the mathematical ratio of two non-zero
integers, the numerator and denominator, whose greatest common divisor
is one, and of which the denominator is positive and greater than one.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.2 (Printing Ratios): PrintingRatios.


File: ansicl,  Node: integer,  Next: signed-byte,  Prev: ratio,  Up: Numbers

integer (System Class)
======================

Class Precedence List:
......................

‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

An integer is a mathematical integer. There is no limit on the
magnitude of an integer.

The types ‘fixnum’ and ‘bignum’ form an exhaustive partition of type
‘integer’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(integer [lower-limit [upper-limit]])

Compound Type Specifier Arguments:
..................................

LOWER-LIMIT, UPPER-LIMIT--interval designators for type ‘integer’.  The
defaults for each of LOWER-LIMIT and UPPER-LIMIT is the symbol ‘*’.

Compound Type Specifier Description:
....................................

This denotes the integers on the interval described by LOWER-LIMIT and
UPPER-LIMIT.

See Also:
.........

*note Figure 2.9: SyntaxForNumericTokens, *note Section 2.3.2
(Constructing Numbers from Tokens): Constructing Numbers from Tokens,
*note Section 22.1.3.1.1 (Printing Integers): PrintingIntegers.

Notes:
......

The type ‘(integer lower upper)’, where lower and upper are
‘most-negative-fixnum’ and ‘most-positive-fixnum’, respectively, is
also called ‘fixnum’.

The type ‘(integer 0 1)’ is also called ‘bit’.  The type ‘(integer 0
*)’ is also called ‘unsigned-byte’.


File: ansicl,  Node: signed-byte,  Next: unsigned-byte,  Prev: integer,  Up: Numbers

signed-byte (Type)
==================

Supertypes:
...........

‘signed-byte’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The atomic type specifier ‘signed-byte’ denotes the same type as is
denoted by the type specifier ‘integer’; however, the list forms of
these two type specifiers have different semantics.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(signed-byte [s | *])

Compound Type Specifier Arguments:
..................................

S--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of integers that can be represented in
two's-complement form in a byte of S bits.  This is equivalent to
‘(integer -2^s-1 2^s-1-1)’.  The type ‘signed-byte’ or the type
‘(signed-byte *)’ is the same as the type ‘integer’.


File: ansicl,  Node: unsigned-byte,  Next: mod (Type Specifier),  Prev: signed-byte,  Up: Numbers

unsigned-byte (Type)
====================

Supertypes:
...........

‘unsigned-byte’, ‘signed-byte’, ‘integer’, ‘rational’, ‘real’, ‘number’,
‘t’

Description:
............

The atomic type specifier ‘unsigned-byte’ denotes the same type as is
denoted by the type specifier ‘(integer 0 *)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(unsigned-byte [S | *])

Compound Type Specifier Arguments:
..................................

S--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers that can be represented
in a byte of size S (bits).  This is equivalent to ‘(mod M)’ for M=2^s,
or to ‘(integer 0 N)’ for N=2^s-1.  The type ‘unsigned-byte’ or the
type ‘(unsigned-byte *)’ is the same as the type ‘(integer 0 *)’, the
set of non-negative integers.

Notes:
......

The type ‘(unsigned-byte 1)’ is also called ‘bit’.


File: ansicl,  Node: mod (Type Specifier),  Next: bit (Type),  Prev: unsigned-byte,  Up: Numbers

mod (Type Specifier)
====================

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(mod n)

Compound Type Specifier Arguments:
..................................

N--a positive integer.

Compound Type Specifier Description:
....................................

This denotes the set of non-negative integers less than N.  This is
equivalent to ‘(integer 0 (N))’ or to ‘(integer 0 M)’, where M=N-1.

The argument is required, and cannot be *.

The symbol ‘mod’ is not valid as a type specifier.


File: ansicl,  Node: bit (Type),  Next: fixnum,  Prev: mod (Type Specifier),  Up: Numbers

bit (Type)
==========

Supertypes:
...........

‘bit’, ‘unsigned-byte’, ‘signed-byte’, ‘integer’, ‘rational’, ‘real’,
‘number’, ‘t’

Description:
............

The type ‘bit’ is equivalent to the type ‘(integer 0 1)’ and
‘(unsigned-byte 1)’.


File: ansicl,  Node: fixnum,  Next: bignum,  Prev: bit (Type),  Up: Numbers

fixnum (Type)
=============

Supertypes:
...........

‘fixnum’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

A fixnum is an integer whose value is between ‘most-negative-fixnum’
and ‘most-positive-fixnum’ inclusive.  Exactly which integers are
fixnums is implementation-defined.  The type ‘fixnum’ is required to be
a supertype of ‘(signed-byte 16)’.


File: ansicl,  Node: bignum,  Next: =; /=; <; >; <=; >=,  Prev: fixnum,  Up: Numbers

bignum (Type)
=============

Supertypes:
...........

‘bignum’, ‘integer’, ‘rational’, ‘real’, ‘number’, ‘t’

Description:
............

The type ‘bignum’ is defined to be exactly ‘(and integer (not fixnum))’.


File: ansicl,  Node: =; /=; <; >; <=; >=,  Next: max; min,  Prev: bignum,  Up: Numbers

=, /=, <, >, <=, >= (Function)
==============================

Syntax:
.......

 -- Function: = &rest numbers+ → generalized-boolean

 -- Function: /= &rest numbers+ → generalized-boolean

 -- Function: < &rest numbers+ → generalized-boolean

 -- Function: > &rest numbers+ → generalized-boolean

 -- Function: <= &rest numbers+ → generalized-boolean

 -- Function: >= &rest numbers+ → generalized-boolean

Arguments and Values:
.....................

NUMBER--for ‘<’, ‘>’, ‘<=’, ‘>=’: a real; for ‘=’, ‘/=’: a number.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘=’, ‘/=’, ‘<’, ‘>’, ‘<=’, and ‘>=’ perform arithmetic comparisons on
their arguments as follows:

‘=’
     The value of ‘=’ is true if all NUMBERS are the same in value;
     otherwise it is false.  Two complexes are considered equal by ‘=’
     if their real and imaginary parts are equal according to ‘=’.

‘/=’
     The value of ‘/=’ is true if no two NUMBERS are the same in value;
     otherwise it is false.

‘<’
     The value of ‘<’ is true if the NUMBERS are in monotonically
     increasing order; otherwise it is false.

‘>’
     The value of ‘>’ is true if the NUMBERS are in monotonically
     decreasing order; otherwise it is false.

‘<=’
     The value of ‘<=’ is true if the NUMBERS are in monotonically
     nondecreasing order; otherwise it is false.

‘>=’
     The value of ‘>=’ is true if the NUMBERS are in monotonically
     nonincreasing order; otherwise it is false.

‘=’, ‘/=’, ‘<’, ‘>’, ‘<=’, and ‘>=’ perform necessary type conversions.

Examples:
.........

The uses of these functions are illustrated in the next figure.

‘(= 3 3)’ is true.               ‘(/= 3 3)’ is false.
‘(= 3 5)’ is false.              ‘(/= 3 5)’ is true.
‘(= 3 3 3 3)’ is true.           ‘(/= 3 3 3 3)’ is false.
‘(= 3 3 5 3)’ is false.          ‘(/= 3 3 5 3)’ is false.
‘(= 3 6 5 2)’ is false.          ‘(/= 3 6 5 2)’ is true.
‘(= 3 2 3)’ is false.            ‘(/= 3 2 3)’ is false.
‘(< 3 5)’ is true.               ‘(<= 3 5)’ is true.
‘(< 3 -5)’ is false.             ‘(<= 3 -5)’ is false.
‘(< 3 3)’ is false.              ‘(<= 3 3)’ is true.
‘(< 0 3 4 6 7)’ is true.         ‘(<= 0 3 4 6 7)’ is true.
‘(< 0 3 4 4 6)’ is false.        ‘(<= 0 3 4 4 6)’ is true.
‘(> 4 3)’ is true.               ‘(>= 4 3)’ is true.
‘(> 4 3 2 1 0)’ is true.         ‘(>= 4 3 2 1 0)’ is true.
‘(> 4 3 3 2 0)’ is false.        ‘(>= 4 3 3 2 0)’ is true.
‘(> 4 3 1 2 0)’ is false.        ‘(>= 4 3 1 2 0)’ is false.
‘(= 3)’ is true.                 ‘(/= 3)’ is true.
‘(< 3)’ is true.                 ‘(<= 3)’ is true.
‘(= 3.0 #c(3.0 0.0))’ is true.   ‘(/= 3.0 #c(3.0 1.0))’ is true.
‘(= 3 3.0)’ is true.             ‘(= 3.0s0 3.0d0)’ is true.
‘(= 0.0 -0.0)’ is true.          ‘(= 5/2 2.5)’ is true.
‘(> 0.0 -0.0)’ is false.         ‘(= 0 -0.0)’ is true.

Figure 12.13: Uses of /=, =, <, >, <=, and >=

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a real.  Might signal
‘arithmetic-error’ if otherwise unable to fulfill its contract.

Notes:
......

‘=’ differs from ‘eql’ in that ‘(= 0.0 -0.0)’ is always true, because
‘=’ compares the mathematical values of its operands, whereas ‘eql’
compares the representational values, so to speak.


File: ansicl,  Node: max; min,  Next: minusp; plusp,  Prev: =; /=; <; >; <=; >=,  Up: Numbers

max, min (Function)
===================

Syntax:
.......

 -- Function: max &rest reals+ → max-real

 -- Function: min &rest reals+ → min-real

Arguments and Values:
.....................

REAL--a real.

MAX-REAL, MIN-REAL--a real.

Description:
............

‘max’ returns the REAL that is greatest (closest to positive infinity).
‘min’ returns the REAL that is least (closest to negative infinity).

For ‘max’, the implementation has the choice of returning the largest
argument as is or applying the rules of floating-point contagion,
taking all the arguments into consideration for contagion purposes.
Also, if one or more of the arguments are ‘=’, then any one of them may
be chosen as the value to return.  For example, if the REALS are a
mixture of rationals and floats, and the largest argument is a rational,
then the implementation is free to produce either that rational or its
float approximation; if the largest argument is a float of a smaller
format than the largest format of any float argument, then the
implementation is free to return the argument in its given format or
expanded to the larger format.  Similar remarks apply to ‘min’
(replacing "largest argument" by "smallest argument").

Examples:
.........

 (max 3) → 3
 (min 3) → 3
 (max 6 12) → 12
 (min 6 12) → 6
 (max -6 -12) → -6
 (min -6 -12) → -12
 (max 1 3 2 -7) → 3
 (min 1 3 2 -7) → -7
 (max -2 3 0 7) → 7
 (min -2 3 0 7) → -2
 (max 5.0 2) → 5.0
 (min 5.0 2)
→ 2
or→ 2.0
 (max 3.0 7 1)
→ 7
or→ 7.0
 (min 3.0 7 1)
→ 1
or→ 1.0
 (max 1.0s0 7.0d0) → 7.0d0
 (min 1.0s0 7.0d0)
→ 1.0s0
or→ 1.0d0
 (max 3 1 1.0s0 1.0d0)
→ 3
or→ 3.0d0
 (min 3 1 1.0s0 1.0d0)
→ 1
or→ 1.0s0
or→ 1.0d0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a real.


File: ansicl,  Node: minusp; plusp,  Next: zerop,  Prev: max; min,  Up: Numbers

minusp, plusp (Function)
========================

Syntax:
.......

 -- Function: minusp real → generalized-boolean

 -- Function: plusp real → generalized-boolean

Arguments and Values:
.....................

REAL--a real.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘minusp’ returns true if REAL is less than zero; otherwise, returns
false.

‘plusp’ returns true if REAL is greater than zero; otherwise, returns
false.

Regardless of whether an implementation provides distinct
representations for positive and negative float zeros, ‘(minusp -0.0)’
always returns false.

Examples:
.........

 (minusp -1) → true
 (plusp 0) → false
 (plusp least-positive-single-float) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if REAL is not a real.


File: ansicl,  Node: zerop,  Next: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Prev: minusp; plusp,  Up: Numbers

zerop (Function)
================

Syntax:
.......

 -- Function: zerop number → generalized-boolean

Pronunciation:
..............

[ˈzē(ˌ)rō(ˌ)pē]

Arguments and Values:
.....................

NUMBER--a number.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if NUMBER is zero (integer, float, or complex); otherwise,
returns false.

Regardless of whether an implementation provides distinct
representations for positive and negative floating-point zeros, ‘(zerop
-0.0)’ always returns true.

Examples:
.........

 (zerop 0) → true
 (zerop 1) → false
 (zerop -0.0) → true
 (zerop 0/100) → true
 (zerop #c(0 0.0)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.

Notes:
......

 (zerop NUMBER) ≡ (= NUMBER 0)


File: ansicl,  Node: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Next: sin; cos; tan,  Prev: zerop,  Up: Numbers

floor, ffloor, ceiling, fceiling, truncate, ftruncate, round, fround (Function)
===============================================================================

Syntax:
.......

 -- Function: floor number &optional divisor → quotient, remainder

 -- Function: ffloor number &optional divisor → quotient, remainder

 -- Function: ceiling number &optional divisor → quotient, remainder

 -- Function: fceiling number &optional divisor → quotient, remainder

 -- Function: truncate number &optional divisor → quotient, remainder

 -- Function: ftruncate number &optional divisor → quotient, remainder

 -- Function: round number &optional divisor → quotient, remainder

 -- Function: fround number &optional divisor → quotient, remainder

Arguments and Values:
.....................

NUMBER--a real.

DIVISOR--a non-zero real.  The default is the integer ‘1’.

QUOTIENT--for ‘floor’, ‘ceiling’, ‘truncate’, and ‘round’: an integer;
for ‘ffloor’, ‘fceiling’, ‘ftruncate’, and ‘fround’: a float.

REMAINDER--a real.

Description:
............

These functions divide NUMBER by DIVISOR, returning a QUOTIENT and
REMAINDER, such that

QUOTIENT· DIVISOR+REMAINDER=NUMBER

The QUOTIENT always represents a mathematical integer.  When more than
one mathematical integer might be possible (i.e., when the remainder is
not zero), the kind of rounding or truncation depends on the operator:

‘floor’, ‘ffloor’
     ‘floor’ and ‘ffloor’ produce a QUOTIENT that has been truncated
     toward negative infinity; that is, the QUOTIENT represents the
     largest mathematical integer that is not larger than the
     mathematical quotient.

‘ceiling’, ‘fceiling’
     ‘ceiling’ and ‘fceiling’ produce a QUOTIENT that has been
     truncated toward positive infinity; that is, the QUOTIENT
     represents the smallest mathematical integer that is not smaller
     than the mathematical result.

‘truncate’, ‘ftruncate’
     ‘truncate’ and ‘ftruncate’ produce a QUOTIENT that has been
     truncated towards zero; that is, the QUOTIENT represents the
     mathematical integer of the same sign as the mathematical
     quotient, and that has the greatest integral magnitude not greater
     than that of the mathematical quotient.

‘round’, ‘fround’
     ‘round’ and ‘fround’ produce a QUOTIENT that has been rounded to
     the nearest mathematical integer; if the mathematical quotient is
     exactly halfway between two integers, (that is, it has the form
     integer+1/2), then the QUOTIENT has been rounded to the even
     (divisible by two) integer.

All of these functions perform type conversion operations on NUMBERS.

The REMAINDER is an integer  if both   ‘x’ and ‘y’ are integers, is a
rational if both   ‘x’ and ‘y’ are rationals, and is a  float    if
either ‘x’ or  ‘y’ is  a float.

‘ffloor’, ‘fceiling’, ‘ftruncate’, and ‘fround’ handle arguments of
different types in the following way: If  NUMBER  is     a float, and
DIVISOR is not a float of longer format, then the first result is a
float of the same type as NUMBER.  Otherwise, the first result is of
the type determined by contagion rules; see *note Section 12.1.1.2
(Contagion in Numeric Operations): NumericContagionRules.

Examples:
.........

 (floor 3/2) → 1, 1/2
 (ceiling 3 2) → 2, -1
 (ffloor 3 2) → 1.0, 1
 (ffloor -4.7) → -5.0, 0.3
 (ffloor 3.5d0) → 3.0d0, 0.5d0
 (fceiling 3/2) → 2.0, -1/2
 (truncate 1) → 1, 0
 (truncate .5) → 0, 0.5
 (round .5) → 0, 0.5
 (ftruncate -7 2) → -3.0, -1
 (fround -7 2) → -4.0, 1
 (dolist (n '(2.6 2.5 2.4 0.7 0.3 -0.3 -0.7 -2.4 -2.5 -2.6))
   (format t "~&~4,1@F ~2,' D ~2,' D ~2,' D ~2,' D"
           n (floor n) (ceiling n) (truncate n) (round n)))
▷ +2.6  2  3  2  3
▷ +2.5  2  3  2  2
▷ +2.4  2  3  2  2
▷ +0.7  0  1  0  1
▷ +0.3  0  1  0  0
▷ -0.3 -1  0  0  0
▷ -0.7 -1  0  0 -1
▷ -2.4 -3 -2 -2 -2
▷ -2.5 -3 -2 -2 -2
▷ -2.6 -3 -2 -2 -3
→ NIL

Notes:
......

When only NUMBER is given, the two results are exact; the mathematical
sum of the two results is always equal to the mathematical value of
NUMBER.

‘(function NUMBER DIVISOR)’ and ‘(function (/ NUMBER DIVISOR))’ (where
function is any of one of ‘floor’, ‘ceiling’, ‘ffloor’, ‘fceiling’,
‘truncate’, ‘round’, ‘ftruncate’, and ‘fround’) return the same first
value, but they return different remainders as the second value. For
example:

 (floor 5 2) → 2, 1
 (floor (/ 5 2)) → 2, 1/2

If an effect is desired that is similar to ‘round’, but that always
rounds up or down (rather than toward the nearest even integer) if the
mathematical quotient is exactly halfway between two integers, the
programmer should consider a construction such as ‘(floor (+ x 1/2))’
or ‘(ceiling (- x 1/2))’.


File: ansicl,  Node: sin; cos; tan,  Next: asin; acos; atan,  Prev: floor; ffloor; ceiling; fceiling; truncate; ftruncate; round; fround,  Up: Numbers

sin, cos, tan (Function)
========================

Syntax:
.......

 -- Function: sin radians → number

 -- Function: cos radians → number

 -- Function: tan radians → number

Arguments and Values:
.....................

RADIANS--a number given in radians.

NUMBER--a number.

Description:
............

‘sin’, ‘cos’, and ‘tan’ return the sine, cosine, and tangent,
respectively, of RADIANS.

Examples:
.........

 (sin 0) → 0.0
 (cos 0.7853982) → 0.707107
 (tan #c(0 1)) → #C(0.0 0.761594)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if RADIANS is not a number.
Might signal ‘arithmetic-error’.

See Also:
.........

*note asin::, *note acos::, *note atan::, *note Section 12.1.3.3 (Rule
of Float Substitutability): FloatSubstitutability.


File: ansicl,  Node: asin; acos; atan,  Next: pi,  Prev: sin; cos; tan,  Up: Numbers

asin, acos, atan (Function)
===========================

Syntax:
.......

 -- Function: asin number → radians

 -- Function: acos number → radians

 -- Function: atan number1 &optional number2 → radians

Arguments and Values:
.....................

NUMBER--a number.

NUMBER1--a number if NUMBER2 is not supplied, or a real   if NUMBER2 is
   supplied.

NUMBER2--a real.

RADIANS--a number (of radians).

Description:
............

‘asin’, ‘acos’, and ‘atan’ compute the arc sine, arc cosine, and arc
tangent respectively.

The arc sine, arc cosine, and arc tangent (with only NUMBER1 supplied)
functions can be defined mathematically for NUMBER or NUMBER1 specified
as x as in the next figure.

Function      Definition
-------------------------------------------------- 
Arc sine      -i log (ix+     sqrt(1-x^2)     )
Arc cosine    (π/2) - arcsin x
Arc tangent   -i log ((1+ix) sqrt(1/(1+x^2)) )

Figure 12.14: Mathematical definition of arc sine, arc cosine, and arc
tangent

These formulae are mathematically correct, assuming completely accurate
computation. They are not necessarily the simplest ones for real-valued
computations.

If both NUMBER1 and NUMBER2 are supplied for ‘atan’, the result is the
arc tangent of NUMBER1/NUMBER2.  The value of ‘atan’ is always between
-π (exclusive) and π (inclusive) when minus zero is not supported.  The
range of the two-argument arc tangent when minus zero is supported
includes -π.

For a real NUMBER1, the result is a real and lies between -π/2 and π/2
(both exclusive).  NUMBER1 can be a complex if NUMBER2 is not supplied.
If both are supplied, NUMBER2 can be zero provided NUMBER1 is not zero.

The following definition for arc sine determines the range and branch
cuts:

     arcsin z = -i log (iz+sqrt(1-z^2))

The branch cut for the arc sine function is in two pieces: one along
the negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV.  The range is that strip of
the complex plane containing numbers whose real part is between -π/2
and π/2.  A number with real part equal to -π/2 is in the range if and
only if its imaginary part is non-negative; a number with real part
equal to π/2 is in the range if and only if its imaginary part is
non-positive.

The following definition for arc cosine determines the range and branch
cuts:

     arccos z = π/2- arcsin z

or, which are equivalent,

     arccos z = -i log (z+i sqrt(1-z^2))

     arccos z = 2 log (sqrt((1+z)/2) + i sqrt((1-z)/2))/(i)

The branch cut for the arc cosine function is in two pieces: one along
the negative real axis to the left of -1 (inclusive), continuous with
quadrant II, and one along the positive real axis to the right of 1
(inclusive), continuous with quadrant IV.  This is the same branch cut
as for arc sine.  The range is that strip of the complex plane
containing numbers whose real part is between 0 and π.  A number with
real part equal to 0 is in the range if and only if its imaginary part
is non-negative; a number with real part equal to π is in the range if
and only if its imaginary part is non-positive.

The following definition for (one-argument) arc tangent determines the
range and branch cuts:

     arctan z = (log (1+iz) - log (1-iz))/2i

Beware of simplifying this formula; "obvious" simplifications are likely
to alter the branch cuts or the values on the branch cuts incorrectly.
The branch cut for the arc tangent function is in two pieces: one along
the positive imaginary axis above i (exclusive), continuous with
quadrant II, and one along the negative imaginary axis below -i
(exclusive), continuous with quadrant IV.  The points i and -i are
excluded from the domain.  The range is that strip of the complex plane
containing numbers whose real part is between -π/2 and π/2.  A number
with real part equal to -π/2 is in the range if and only if its
imaginary part is strictly positive; a number with real part equal to
π/2 is in the range if and only if its imaginary part is strictly
negative.  Thus the range of arc tangent is identical to that of arc
sine with the points -π/2 and π/2 excluded.

For ‘atan’, the signs of NUMBER1 (indicated as x) and NUMBER2
(indicated as y) are used to derive quadrant information. The next
figure details various special cases.  The asterisk (*) indicates that
the entry in the figure applies to implementations that support minus
zero.

 y Condition    x Condition   Cartesian locus   Range of result
-------------------------------------------------------------------- 
 y =  0         x >  0        Positive x-axis   0
*y = +0        x >  0        Positive x-axis   +0
*y = -0        x >  0        Positive x-axis   -0
 y >  0         x >  0        Quadrant I        0 < result < π/2
 y >  0         x =  0        Positive y-axis   π/2
 y >  0         x <  0        Quadrant II       π/2 < result < π
 y =  0         x <  0        Negative x-axis   π
*y = +0        x <  0        Negative x-axis   +π
*y = -0        x <  0        Negative x-axis   -π
 y <  0         x <  0        Quadrant III      -π < result < -π/2
 y <  0         x =  0        Negative y-axis   -π/2
 y <  0         x >  0        Quadrant IV       -π/2 < result < 0
 y =  0         x =  0        Origin            undefined
                                               consequences
*y = +0        x = +0        Origin            +0
*y = -0        x = +0        Origin            -0
*y = +0        x = -0        Origin            +π
*y = -0        x = -0        Origin            -π

Figure 12.15: Quadrant information for arc tangent

Examples:
.........

 (asin 0) → 0.0
 (acos #c(0 1))  → #C(1.5707963267948966 -0.8813735870195432)
 (/ (atan 1 (sqrt 3)) 6)  → 0.087266
 (atan #c(0 2)) → #C(-1.5707964 0.54930615)

Exceptional Situations:
.......................

‘acos’ and ‘asin’ should signal an error of type ‘type-error’ if NUMBER
is not a number.  ‘atan’ should signal ‘type-error’ if one argument is
supplied and that argument is not a number, or if two arguments are
supplied and both of those arguments are not reals.

‘acos’, ‘asin’, and ‘atan’ might signal ‘arithmetic-error’.

See Also:
.........

*note log::, *note sqrt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of either ‘asin’ or ‘acos’ can be a complex even if NUMBER
is not a complex; this occurs when the absolute value of NUMBER is
greater than one.


File: ansicl,  Node: pi,  Next: sinh; cosh; tanh; asinh; acosh; atanh,  Prev: asin; acos; atan,  Up: Numbers

pi (Constant Variable)
======================

Value:
......

an implementation-dependent long float.

Description:
............

The best long float approximation to the mathematical constant π.

Examples:
.........

 ;; In each of the following computations, the precision depends
 ;; on the implementation.  Also, if `long float' is treated by
 ;; the implementation as equivalent to some other float format
 ;; (e.g., `double float') the exponent marker might be the marker
 ;; for that equivalent (e.g., `D' instead of `L').
 pi → 3.141592653589793L0
 (cos pi) → -1.0L0

 (defun sin-of-degrees (degrees)
   (let ((x (if (floatp degrees) degrees (float degrees pi))))
     (sin (* x (/ (float pi x) 180)))))

Notes:
......

An approximation to π in some other precision can be obtained by
writing ‘(float pi x)’, where ‘x’ is a float of the desired precision,
or by writing ‘(coerce pi type)’, where type is the desired type, such
as ‘short-float’.


File: ansicl,  Node: sinh; cosh; tanh; asinh; acosh; atanh,  Next: * (Function),  Prev: pi,  Up: Numbers

sinh, cosh, tanh, asinh, acosh, atanh (Function)
================================================

Syntax:
.......

 -- Function: sinh number → result

 -- Function: cosh number → result

 -- Function: tanh number → result

 -- Function: asinh number → result

 -- Function: acosh number → result

 -- Function: atanh number → result

Arguments and Values:
.....................

NUMBER--a number.

RESULT--a number.

Description:
............

These functions compute the hyperbolic sine, cosine, tangent, arc sine,
arc cosine, and arc tangent functions, which are mathematically defined
for an argument x as given in the next figure.

Function                 Definition
------------------------------------------------------------------ 
Hyperbolic sine          (e^x-e^-x)/2
Hyperbolic cosine        (e^x+e^-x)/2
Hyperbolic tangent       (e^x-e^-x)/(e^x+e^-x)
Hyperbolic arc sine      log (x+sqrt(1+x^2))
Hyperbolic arc cosine    2 log (sqrt((x+1)/2) + sqrt((x-1)/2))
Hyperbolic arc tangent   (log (1+x) - log(1-x))/2

Figure 12.16: Mathematical definitions for hyperbolic functions

The following definition for the inverse hyperbolic cosine determines
the range and branch cuts:

     arccosh z = 2 log (sqrt((z+1)/2) + sqrt((z-1)/2)).

The branch cut for the inverse hyperbolic cosine function lies along
the real axis to the left of 1 (inclusive), extending indefinitely
along the negative real axis, continuous with quadrant II and (between
0 and 1) with quadrant I.  The range is that half-strip of the complex
plane containing numbers whose real part is non-negative and whose
imaginary part is between -π (exclusive) and π (inclusive).  A number
with real part zero is in the range if its imaginary part is between
zero (inclusive) and π (inclusive).

The following definition for the inverse hyperbolic sine determines the
range and branch cuts:

     arcsinh z = log (z+sqrt(1+z^2)).

The branch cut for the inverse hyperbolic sine function is in two
pieces: one along the positive imaginary axis above i (inclusive),
continuous with quadrant I, and one along the negative imaginary axis
below -i (inclusive), continuous with quadrant III.  The range is that
strip of the complex plane containing numbers whose imaginary part is
between -π/2 and π/2.  A number with imaginary part equal to -π/2 is in
the range if and only if its real part is non-positive; a number with
imaginary part equal to π/2 is in the range if and only if its
imaginary part is non-negative.

The following definition for the inverse hyperbolic tangent determines
the range and branch cuts:

     arctanh z = (log (1+z) - log (1-z))/2.

Note that:

     i arctan z = arctanh iz.

The branch cut for the inverse hyperbolic tangent function is in two
pieces: one along the negative real axis to the left of -1 (inclusive),
continuous with quadrant III, and one along the positive real axis to
the right of 1 (inclusive), continuous with quadrant I.  The points -1
and 1 are excluded from the domain.  The range is that strip of the
complex plane containing numbers whose imaginary part is between -π/2
and π/2.  A number with imaginary part equal to -π/2 is in the range if
and only if its real part is strictly negative; a number with imaginary
part equal to π/2 is in the range if and only if its imaginary part is
strictly positive.  Thus the range of the inverse hyperbolic tangent
function is identical to that of the inverse hyperbolic sine function
with the points -π i/2 and π i/2 excluded.

Examples:
.........

 (sinh 0) → 0.0
 (cosh (complex 0 -1)) → #C(0.540302 -0.0)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.
Might signal ‘arithmetic-error’.

See Also:
.........

*note log::, *note sqrt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

The result of ‘acosh’ may be a complex even if NUMBER is not a complex;
this occurs when NUMBER is less than one.  Also, the result of ‘atanh’
may be a complex even if NUMBER is not a complex; this occurs when the
absolute value of NUMBER is greater than one.

The branch cut formulae are mathematically correct, assuming completely
accurate computation.  Implementors should consult a good text on
numerical analysis.  The formulae given above are not necessarily the
simplest ones for real-valued computations; they are chosen to define
the branch cuts in desirable ways for the complex case.


File: ansicl,  Node: * (Function),  Next: + (Function),  Prev: sinh; cosh; tanh; asinh; acosh; atanh,  Up: Numbers

* (Function)
============

Syntax:
.......

 -- Function: * &rest numbers → product

Arguments and Values:
.....................

NUMBER--a number.

PRODUCT--a number.

Description:
............

Returns the product of NUMBERS, performing any necessary type
conversions in the process.  If no NUMBERS are supplied, ‘1’ is
returned.

Examples:
.........

 (*) → 1
 (* 3 5) → 15
 (* 1.0 #c(22 33) 55/98) → #C(12.346938775510203 18.520408163265305)

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: + (Function),  Next: - (Function),  Prev: * (Function),  Up: Numbers

+ (Function)
============

Syntax:
.......

 -- Function: + &rest numbers → sum

Arguments and Values:
.....................

NUMBER--a number.

SUM--a number.

Description:
............

Returns the sum of NUMBERS, performing any necessary type conversions
in the process.  If no NUMBERS are supplied, ‘0’ is returned.

Examples:
.........

 (+) → 0
 (+ 1) → 1
 (+ 31/100 69/100) → 1
 (+ 1/5 0.8) → 1.0

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: - (Function),  Next: / (Function),  Prev: + (Function),  Up: Numbers

- (Function)
============

Syntax:
.......

 -- Function: - number → negation

 -- Function: - minuend &rest subtrahends+ → difference

Arguments and Values:
.....................

NUMBER, MINUEND, SUBTRAHEND--a number.

NEGATION, DIFFERENCE--a number.

Description:
............

The function ‘-’ performs arithmetic subtraction and negation.

If only one NUMBER is supplied, the negation of that NUMBER is returned.

If more than one argument is given, it subtracts all of the SUBTRAHENDS
from the MINUEND and returns the result.

The function ‘-’ performs necessary type conversions.

Examples:
.........

 (- 55.55) → -55.55
 (- #c(3 -5)) → #C(-3 5)
 (- 0) → 0
 (eql (- 0.0) -0.0) → true
 (- #c(100 45) #c(0 45)) → 100
 (- 10 1 2 3 4) → 0

Exceptional Situations:
.......................

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.1 (Numeric Operations): Numeric Operations, *note
Section 12.1.3 (Rational Computations): Rational Computations, *note
Section 12.1.4 (Floating-point Computations): Floating-point
Computations, *note Section 12.1.5 (Complex Computations): Complex
Computations.


File: ansicl,  Node: / (Function),  Next: 1+; 1-,  Prev: - (Function),  Up: Numbers

/ (Function)
============

Syntax:
.......

 -- Function: / number → reciprocal

 -- Function: / numerator &rest denominators+ → quotient

Arguments and Values:
.....................

NUMBER, DENOMINATOR--a non-zero number.

NUMERATOR, QUOTIENT, RECIPROCAL--a number.

Description:
............

The function ‘/’ performs division or reciprocation.

If no DENOMINATORS are supplied, the function ‘/’ returns the
reciprocal of NUMBER.

If at least one DENOMINATOR is supplied, the function ‘/’ divides the
NUMERATOR by all of the DENOMINATORS and returns the resulting QUOTIENT.

If each argument is either an integer or a ratio, and the result is not
an integer, then it is a ratio.

The function ‘/’ performs necessary type conversions.

If any ARGUMENT is a float then the rules of floating-point contagion
apply; see *note Section 12.1.4 (Floating-point Computations):
Floating-point Computations.

Examples:
.........

 (/ 12 4) → 3
 (/ 13 4) → 13/4
 (/ -8) → -1/8
 (/ 3 4 5) → 3/20
 (/ 0.5) → 2.0
 (/ 20 5) → 4
 (/ 5 20) → 1/4
 (/ 60 -2 3 5.0) → -2.0
 (/ 2 #c(2 2)) → #C(1/2 -1/2)

Exceptional Situations:
.......................

The consequences are unspecified if any argument other than the first
is zero.  If there is only one argument, the consequences are
unspecified if it is zero.

Might signal ‘type-error’ if some argument is not a number.  Might
signal ‘division-by-zero’ if division by zero is attempted.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note floor::, *note ceiling::, *note truncate::, *note round::


File: ansicl,  Node: 1+; 1-,  Next: abs,  Prev: / (Function),  Up: Numbers

1+, 1- (Function)
=================

Syntax:
.......

 -- Function: 1+ number → successor

 -- Function: 1- number → predecessor

Arguments and Values:
.....................

NUMBER--a number.

SUCCESSOR, PREDECESSOR--a number.

Description:
............

‘1+’ returns a number that is one more than its argument NUMBER.  ‘1-’
returns a number that is one less than its argument NUMBER.

Examples:
.........

 (1+ 99) → 100
 (1- 100) → 99
 (1+ (complex 0.0)) → #C(1.0 0.0)
 (1- 5/3) → 2/3

Exceptional Situations:
.......................

Might signal ‘type-error’ if its argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note incf::, *note decf::

Notes:
......

 (1+ NUMBER) ≡ (+ NUMBER 1)
 (1- NUMBER) ≡ (- NUMBER 1)

Implementors are encouraged to make the performance of both the previous
expressions be the same.


File: ansicl,  Node: abs,  Next: evenp; oddp,  Prev: 1+; 1-,  Up: Numbers

abs (Function)
==============

Syntax:
.......

 -- Function: abs number → absolute-value

Arguments and Values:
.....................

NUMBER--a number.

ABSOLUTE-VALUE--a non-negative real.

Description:
............

‘abs’ returns the absolute value of NUMBER.

If NUMBER is a real, the result is  of the same type as NUMBER.

If NUMBER is a complex, the result is a positive real with the same
magnitude as NUMBER.  The result can be a float

even if NUMBER's components are rationals and an exact rational result
would have been possible.  Thus the result of ‘(abs #c(3 4))’ can be
either ‘5’ or ‘5.0’, depending on the implementation.

Examples:
.........

 (abs 0) → 0
 (abs 12/13) → 12/13
 (abs -1.09) → 1.09
 (abs #c(5.0 -5.0)) → 7.071068
 (abs #c(5 5)) → 7.071068
 (abs #c(3/5 4/5)) → 1 or approximately 1.0
 (eql (abs -0.0) -0.0) → true

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

If NUMBER is a complex, the result is equivalent to the following:

‘(sqrt (+ (expt (realpart NUMBER) 2)  (expt (imagpart NUMBER) 2)))’

An implementation should not use this formula directly for all complexes
but should handle very large or very small components specially to
avoid intermediate overflow or underflow.


File: ansicl,  Node: evenp; oddp,  Next: exp; expt,  Prev: abs,  Up: Numbers

evenp, oddp (Function)
======================

Syntax:
.......

 -- Function: evenp integer → generalized-boolean

 -- Function: oddp integer → generalized-boolean

Arguments and Values:
.....................

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘evenp’ returns true if INTEGER is even (divisible by two); otherwise,
returns false.

‘oddp’ returns true if INTEGER is odd (not divisible by two);
otherwise, returns false.

Examples:
.........

 (evenp 0) → true
 (oddp 10000000000000000000000) → false
 (oddp -1) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

Notes:
......

 (evenp INTEGER) ≡ (not (oddp INTEGER))
 (oddp INTEGER)  ≡ (not (evenp INTEGER))


File: ansicl,  Node: exp; expt,  Next: gcd,  Prev: evenp; oddp,  Up: Numbers

exp, expt (Function)
====================

Syntax:
.......

 -- Function: exp number → result

 -- Function: expt base-number power-number → result

Arguments and Values:
.....................

NUMBER--a number.

BASE-NUMBER--a number.

POWER-NUMBER--a number.

RESULT--a number.

Description:
............

‘exp’ and ‘expt’ perform exponentiation.

‘exp’ returns e raised to the power NUMBER, where e is the base of the
natural logarithms.  ‘exp’ has no branch cut.

‘expt’ returns BASE-NUMBER raised to the power POWER-NUMBER.  If the
BASE-NUMBER is a rational and POWER-NUMBER is an integer, the
calculation is exact and the result will be of type ‘rational’;
otherwise a floating-point approximation might result.  For ‘expt’ of a
complex rational to an integer power, the calculation must be exact and
the result is of type ‘(or rational (complex rational))’.

The result of ‘expt’ can be a complex, even when neither argument is a
complex, if BASE-NUMBER is negative and POWER-NUMBER is not an integer.
The result is always the principal complex value.  For example, ‘(expt
-8 1/3)’ is not permitted to return ‘-2’, even though ‘-2’ is one of
the cube roots of ‘-8’.  The principal cube root is a complex
approximately equal to ‘#C(1.0 1.73205)’, not ‘-2’.

‘expt’ is defined as b^x = e^x log b.  This defines the principal
values precisely.  The range of ‘expt’ is the entire complex plane.
Regarded as a function of x, with b fixed, there is no branch cut.
Regarded as a function of b, with x fixed, there is in general a branch
cut along the negative real axis, continuous with quadrant II.  The
domain excludes the origin.  By definition, 0^0=1.  If b=0 and the real
part of x is strictly positive, then b^x=0. For all other values of x,
0^x is an error.

When POWER-NUMBER is an integer ‘0’, then the result is always the
value one in the type of BASE-NUMBER, even if the BASE-NUMBER is zero
(of any type).  That is:

 (expt x 0) ≡ (coerce 1 (type-of x))

If POWER-NUMBER is a zero of any other type, then the result is also
the value one, in the type of the arguments after the application of
the contagion rules in *note Section 12.1.1.2 (Contagion in Numeric
Operations): NumericContagionRules, with one exception: the
consequences are undefined if BASE-NUMBER is zero when POWER-NUMBER is
zero and not of type ‘integer’.

Examples:
.........

 (exp 0) → 1.0
 (exp 1) → 2.718282
 (exp (log 5)) → 5.0
 (expt 2 8) → 256
 (expt 4 .5) → 2.0
 (expt #c(0 1) 2) → -1
 (expt #c(2 2) 3) → #C(-16 16)
 (expt #c(2 2) 4) → -64

See Also:
.........

*note log::, *note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

Implementations of ‘expt’ are permitted to use different algorithms for
the cases of a POWER-NUMBER of type ‘rational’ and a POWER-NUMBER of
type ‘float’.

Note that by the following logic, ‘(sqrt (expt x 3))’ is not equivalent
to ‘(expt x 3/2)’.

 (setq x (exp (/ (* 2 pi #c(0 1)) 3)))         ;exp(2.pi.i/3)
 (expt x 3) → 1 ;except for round-off error
 (sqrt (expt x 3)) → 1 ;except for round-off error
 (expt x 3/2) → -1 ;except for round-off error


File: ansicl,  Node: gcd,  Next: incf; decf,  Prev: exp; expt,  Up: Numbers

gcd (Function)
==============

Syntax:
.......

 -- Function: gcd &rest integers → greatest-common-denominator

Arguments and Values:
.....................

INTEGER--an integer.

GREATEST-COMMON-DENOMINATOR--a non-negative integer.

Description:
............

Returns the greatest common divisor of INTEGERS.  If only one INTEGER
is supplied, its absolute value is returned.  If no INTEGERS are given,
‘gcd’ returns ‘0’, which is an identity for this operation.

Examples:
.........

 (gcd) → 0
 (gcd 60 42) → 6
 (gcd 3333 -33 101) → 1
 (gcd 3333 -33 1002001) → 11
 (gcd 91 -49) → 7
 (gcd 63 -42 35) → 7
 (gcd 5) → 5
 (gcd -4) → 4

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

See Also:
.........

*note lcm::

Notes:
......

For three or more arguments,

 (gcd b c ... z) ≡ (gcd (gcd a b) c ... z)


File: ansicl,  Node: incf; decf,  Next: lcm,  Prev: gcd,  Up: Numbers

incf, decf (Macro)
==================

Syntax:
.......

 -- Macro: incf place [delta-form] → new-value

 -- Macro: decf place [delta-form] → new-value

Arguments and Values:
.....................

PLACE--a place.

DELTA-FORM--a form; evaluated to produce a DELTA.  The default is ‘1’.

DELTA--a number.

NEW-VALUE--a number.

Description:
............

‘incf’ and ‘decf’ are used for incrementing and decrementing the value
of PLACE, respectively.

The DELTA is added to        (in the case of ‘incf’) or subtracted from
(in the case of ‘decf’) the number in PLACE and the result is stored in
PLACE.

Any necessary type conversions are performed automatically.

For information about the evaluation of subforms of PLACES, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq n 0)
 (incf n) → 1
 n → 1
 (decf n 3) → -2
 n → -2
 (decf n -5) → 3
 (decf n) → 2
 (incf n 0.5) → 2.5
 (decf n) → 1.5
 n → 1.5

Side Effects:
.............

PLACE is modified.

See Also:
.........

*note + (Function)::, *note - (Function)::, *note 1+::, *note 1-
(Function)::, *note setf::


File: ansicl,  Node: lcm,  Next: log,  Prev: incf; decf,  Up: Numbers

lcm (Function)
==============

Syntax:
.......

 -- Function: lcm &rest integers → least-common-multiple

Arguments and Values:
.....................

INTEGER--an integer.

LEAST-COMMON-MULTIPLE--a non-negative integer.

Description:
............

‘lcm’ returns the least common multiple of the INTEGERS.

If no INTEGER is supplied, the integer ‘1’ is returned.

If only one INTEGER is supplied, the absolute value of that INTEGER is
returned.

For two arguments that are not both zero,

 (lcm a b) ≡ (/ (abs (* a b)) (gcd a b))

If one or both arguments are zero,

 (lcm a 0) ≡ (lcm 0 a) ≡ 0

For three or more arguments,

 (lcm a b c ... z) ≡ (lcm (lcm a b) c ... z)

Examples:
.........

 (lcm 10) → 10
 (lcm 25 30) → 150
 (lcm -24 18 10) → 360
 (lcm 14 35) → 70
 (lcm 0 5) → 0
 (lcm 1 2 3 4 5 6) → 60

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an integer.

See Also:
.........

*note gcd::


File: ansicl,  Node: log,  Next: mod; rem,  Prev: lcm,  Up: Numbers

log (Function)
==============

Syntax:
.......

 -- Function: log number &optional base → logarithm

Arguments and Values:
.....................

NUMBER--a non-zero number.

BASE--a number.

LOGARITHM--a number.

Description:
............

‘log’ returns the logarithm of NUMBER in base BASE.  If BASE is not
supplied its value is e, the base of the natural logarithms.

‘log’ may return a complex when given a real negative NUMBER.

 (log -1.0) ≡ (complex 0.0 (float pi 0.0))

If BASE is zero, ‘log’ returns zero.

The result of ‘(log 8 2)’ may be either ‘3’ or ‘3.0’, depending on the
implementation. An implementation can use floating-point calculations
even if an exact integer result is possible.

The branch cut for the logarithm function of one argument (natural
logarithm) lies along the negative real axis, continuous with quadrant
II.  The domain excludes the origin.

The mathematical definition of a complex logarithm is as follows,
whether or not minus zero is supported by the implementation:

(log x) ≡ (complex (log (abs x)) (phase x))

Therefore the range of the one-argument logarithm function is that strip
of the complex plane containing numbers with imaginary parts between -π
(exclusive) and π (inclusive) if minus zero is not supported, or -π
(inclusive) and π (inclusive) if minus zero is supported.

The two-argument logarithm function is defined as

 (log BASE NUMBER)
 ≡ (/ (log NUMBER) (log BASE))

This defines the principal values precisely.  The range of the
two-argument logarithm function is the entire complex plane.

Examples:
.........

 (log 100 10)
→ 2.0
→ 2
 (log 100.0 10) → 2.0
 (log #c(0 1) #c(0 -1))
→ #C(-1.0 0.0)
or→ #C(-1 0)
 (log 8.0 2) → 3.0

 (log #c(-16 16) #c(2 2)) → 3 or approximately #c(3.0 0.0)
                               or approximately 3.0 (unlikely)

Affected By:
............

The implementation.

See Also:
.........

*note exp::, *note expt::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.


File: ansicl,  Node: mod; rem,  Next: signum,  Prev: log,  Up: Numbers

mod, rem (Function)
===================

Syntax:
.......

 -- Function: mod number divisor → modulus

 -- Function: rem number divisor → remainder

Arguments and Values:
.....................

NUMBER--a real.

DIVISOR--a real.

MODULUS, REMAINDER--a real.

Description:
............

‘mod’ and ‘rem’ are generalizations of the modulus and remainder
functions respectively.

‘mod’ performs the operation ‘floor’ on NUMBER and DIVISOR and returns
the remainder of the ‘floor’ operation.

‘rem’ performs the operation ‘truncate’ on NUMBER and DIVISOR and
returns the remainder of the ‘truncate’ operation.

‘mod’ and ‘rem’ are the modulus and remainder functions when NUMBER and
DIVISOR are integers.

Examples:
.........

 (rem -1 5) → -1
 (mod -1 5) → 4
 (mod 13 4) → 1
 (rem 13 4) → 1
 (mod -13 4) → 3
 (rem -13 4) → -1
 (mod 13 -4) → -3
 (rem 13 -4) → 1
 (mod -13 -4) → -1
 (rem -13 -4) → -1
 (mod 13.4 1) → 0.4
 (rem 13.4 1) → 0.4
 (mod -13.4 1) → 0.6
 (rem -13.4 1) → -0.4

See Also:
.........

*note floor::, *note truncate::

Notes:
......

The result of ‘mod’ is either zero or a real with the same sign as
DIVISOR.


File: ansicl,  Node: signum,  Next: sqrt; isqrt,  Prev: mod; rem,  Up: Numbers

signum (Function)
=================

Syntax:
.......

 -- Function: signum number → signed-prototype

Arguments and Values:
.....................

NUMBER--a number.

SIGNED-PROTOTYPE--a number.

Description:
............

‘signum’ determines a numerical value that indicates whether NUMBER is
negative, zero, or positive.

For a rational, ‘signum’ returns one of ‘-1’, ‘0’, or ‘1’ according to
whether NUMBER is negative, zero, or positive.  For a float, the result
is a float of the same format whose value is minus one, zero, or one.
For a complex number ‘z’, ‘(signum z)’ is a complex number of the same
phase but with unit magnitude, unless ‘z’ is a complex zero, in which
case the result is ‘z’.

For rational arguments, ‘signum’ is a rational function, but it may be
irrational for complex arguments.

If NUMBER is a float, the result is a float.  If NUMBER is a rational,
the result is a rational.  If NUMBER is a complex float, the result is
a complex float.  If NUMBER is a complex rational, the result is a
complex, but it is implementation-dependent whether that result is a
complex rational or a complex float.

Examples:
.........

 (signum 0) → 0
 (signum 99) → 1
 (signum 4/5) → 1
 (signum -99/100) → -1
 (signum 0.0) → 0.0
 (signum #c(0 33)) → #C(0.0 1.0)
 (signum #c(7.5 10.0)) → #C(0.6 0.8)
 (signum #c(0.0 -14.7)) → #C(0.0 -1.0)
 (eql (signum -0.0) -0.0) → true

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.

Notes:
......

 (signum x) ≡ (if (zerop x) x (/ x (abs x)))


File: ansicl,  Node: sqrt; isqrt,  Next: random-state,  Prev: signum,  Up: Numbers

sqrt, isqrt (Function)
======================

Syntax:
.......

 -- Function: sqrt number → root

 -- Function: isqrt natural → natural-root

Arguments and Values:
.....................

NUMBER, ROOT--a number.

NATURAL, NATURAL-ROOT--a non-negative integer.

Description:
............

‘sqrt’ and ‘isqrt’ compute square roots.

‘sqrt’ returns the principal square root of NUMBER.  If the NUMBER is
not a complex but is negative, then the result is a complex.

‘isqrt’ returns the greatest integer less than or equal to the exact
positive square root of NATURAL.

If NUMBER is a positive rational, it is implementation-dependent
whether ROOT is a rational or a float.  If NUMBER is a negative
rational, it is implementation-dependent whether ROOT is a complex
rational or a complex float.

The mathematical definition of complex square root (whether or not
minus zero is supported) follows:

‘(sqrt x) = (exp (/ (log x) 2))’

The branch cut for square root lies along the negative real axis,
continuous with quadrant II.  The range consists of the right
half-plane, including the non-negative imaginary axis and excluding the
negative imaginary axis.

Examples:
.........

 (sqrt 9.0) → 3.0
 (sqrt -9.0) → #C(0.0 3.0)
 (isqrt 9) → 3
 (sqrt 12) → 3.4641016
 (isqrt 12) → 3
 (isqrt 300) → 17
 (isqrt 325) → 18
 (sqrt 25)
→ 5
or→ 5.0
 (isqrt 25) → 5
 (sqrt -1) → #C(0.0 1.0)
 (sqrt #c(0 2)) → #C(1.0 1.0)

Exceptional Situations:
.......................

The function ‘sqrt’ should signal ‘type-error’ if its argument is not a
number.

The function ‘isqrt’ should signal ‘type-error’ if its argument is not
a non-negative integer.

The functions ‘sqrt’ and ‘isqrt’ might signal ‘arithmetic-error’.

See Also:
.........

*note exp::, *note log::, *note Section 12.1.3.3 (Rule of Float
Substitutability): FloatSubstitutability.

Notes:
......

 (isqrt x) ≡ (values (floor (sqrt x)))

but it is potentially more efficient.


File: ansicl,  Node: random-state,  Next: make-random-state,  Prev: sqrt; isqrt,  Up: Numbers

random-state (System Class)
===========================

Class Precedence List:
......................

‘random-state’, ‘t’

Description:
............

A random state object contains state information used by the
pseudo-random number generator.  The nature of a random state object is
implementation-dependent.  It can be printed out and successfully read
back in by the same implementation, but might not function correctly as
a random state in another implementation.

Implementations are required to provide a read syntax for objects of
type ‘random-state’, but the specific nature of that syntax is
implementation-dependent.

See Also:
.........

*note *random-state*::, *note random::, *note Section 22.1.3.10
(Printing Random States): PrintingRandomStates.


File: ansicl,  Node: make-random-state,  Next: random,  Prev: random-state,  Up: Numbers

make-random-state (Function)
============================

Syntax:
.......

 -- Function: make-random-state &optional state → new-state

Arguments and Values:
.....................

STATE--a random state, or ‘nil’, or ‘t’.  The default is ‘nil’.

NEW-STATE--a random state object.

Description:
............

Creates a fresh object of type ‘random-state’ suitable for use as the
value of ‘*random-state*’.

If STATE is a random state object, the NEW-STATE is a copy₅ of that
object.  If STATE is ‘nil’, the NEW-STATE is a copy₅ of the current
random state.  If STATE is ‘t’, the NEW-STATE is a fresh random state
object that has been randomly initialized by some means.

Examples:
.........

 (let* ((rs1 (make-random-state nil))
        (rs2 (make-random-state t))
        (rs3 (make-random-state rs2))
        (rs4 nil))
   (list (loop for i from 1 to 10
               collect (random 100)
               when (= i 5)
                do (setq rs4 (make-random-state)))
         (loop for i from 1 to 10 collect (random 100 rs1))
         (loop for i from 1 to 10 collect (random 100 rs2))
         (loop for i from 1 to 10 collect (random 100 rs3))
         (loop for i from 1 to 10 collect (random 100 rs4))))
→ ((29 25 72 57 55 68 24 35 54 65)
    (29 25 72 57 55 68 24 35 54 65)
    (93 85 53 99 58 62 2 23 23 59)
    (93 85 53 99 58 62 2 23 23 59)
    (68 24 35 54 65 54 55 50 59 49))

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if STATE is not a random
state, or ‘nil’, or ‘t’.

See Also:
.........

*note random::, *note *random-state*::

Notes:
......

One important use of ‘make-random-state’ is to allow the same series of
pseudo-random numbers to be generated many times within a single
program.


File: ansicl,  Node: random,  Next: random-state-p,  Prev: make-random-state,  Up: Numbers

random (Function)
=================

Syntax:
.......

 -- Function: random limit &optional random-state → random-number

Arguments and Values:
.....................

LIMIT--a positive integer, or a positive float.

RANDOM-STATE--a random state.  The default is the current random state.

RANDOM-NUMBER--a non-negative number less than LIMIT and of the same
type as LIMIT.

Description:
............

Returns a pseudo-random number that is a non-negative number less than
LIMIT and of the same type as LIMIT.

The RANDOM-STATE, which is modified by this function, encodes the
internal state maintained by the random number generator.

An approximately uniform choice distribution is used.  If LIMIT is an
integer, each of the possible results occurs with (approximate)
probability 1/LIMIT.

Examples:
.........

 (<= 0 (random 1000) 1000) → true
 (let ((state1 (make-random-state))
       (state2 (make-random-state)))
   (= (random 1000 state1) (random 1000 state2))) → true

Side Effects:
.............

The RANDOM-STATE is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIMIT is not a positive
integer or a positive real.

See Also:
.........

*note make-random-state::, *note *random-state*::

Notes:
......

See `Common Lisp: The Language' for information about generating random
numbers.


File: ansicl,  Node: random-state-p,  Next: *random-state*,  Prev: random,  Up: Numbers

random-state-p (Function)
=========================

Syntax:
.......

 -- Function: random-state-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘random-state’; otherwise, returns
false.

Examples:
.........

 (random-state-p *random-state*) → true
 (random-state-p (make-random-state)) → true
 (random-state-p 'test-function) → false

See Also:
.........

*note make-random-state::, *note *random-state*::

Notes:
......

 (random-state-p OBJECT) ≡ (typep OBJECT 'random-state)


File: ansicl,  Node: *random-state*,  Next: numberp,  Prev: random-state-p,  Up: Numbers

*random-state* (Variable)
=========================

Value Type:
...........

a random state.

Initial Value:
..............

implementation-dependent.

Description:
............

The current random state, which is used, for example, by the function
‘random’ when a random state is not explicitly supplied.

Examples:
.........

 (random-state-p *random-state*) → true
 (setq snap-shot (make-random-state))
 ;; The series from any given point is random,
 ;; but if you backtrack to that point, you get the same series.
 (list (loop for i from 1 to 10 collect (random))
       (let ((*random-state* snap-shot))
         (loop for i from 1 to 10 collect (random)))
       (loop for i from 1 to 10 collect (random))
       (let ((*random-state* snap-shot))
         (loop for i from 1 to 10 collect (random))))
→ ((19 16 44 19 96 15 76 96 13 61)
    (19 16 44 19 96 15 76 96 13 61)
    (16 67 0 43 70 79 58 5 63 50)
    (16 67 0 43 70 79 58 5 63 50))

Affected By:
............

The implementation.

‘random’.

See Also:
.........

*note make-random-state::, *note random::, *note random-state::

Notes:
......

Binding ‘*random-state*’ to a different random state object correctly
saves and restores the old random state object.


File: ansicl,  Node: numberp,  Next: cis,  Prev: *random-state*,  Up: Numbers

numberp (Function)
==================

Syntax:
.......

 -- Function: numberp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘number’; otherwise, returns false.

Examples:
.........

 (numberp 12) → true
 (numberp (expt 2 130)) → true
 (numberp #c(5/3 7.2)) → true
 (numberp nil) → false
 (numberp (cons 1 2)) → false

Notes:
......

 (numberp OBJECT) ≡ (typep OBJECT 'number)


File: ansicl,  Node: cis,  Next: complex (Function),  Prev: numberp,  Up: Numbers

cis (Function)
==============

Syntax:
.......

 -- Function: cis radians → number

Arguments and Values:
.....................

RADIANS--a real.

NUMBER--a complex.

Description:
............

‘cis’ returns the value of e^i· radians, which is a complex in which the
real part is equal to the cosine of RADIANS, and the imaginary part is
equal to the sine of RADIANS.

Examples:
.........

 (cis 0) → #C(1.0 0.0)

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: ansicl,  Node: complex (Function),  Next: complexp,  Prev: cis,  Up: Numbers

complex (Function)
==================

Syntax:
.......

 -- Function: complex realpart &optional imagpart → complex

Arguments and Values:
.....................

REALPART--a real.

IMAGPART--a real.

COMPLEX--a rational or a complex.

Description:
............

‘complex’ returns a number whose real      part is REALPART and whose
imaginary part is IMAGPART.

If REALPART is a rational and IMAGPART is the rational number zero, the
result of ‘complex’ is REALPART, a rational.  Otherwise, the result is
a complex.

If either REALPART or IMAGPART is a float, the non-float is converted
to a float before the complex is created.  If IMAGPART is not supplied,
the imaginary part is a zero of the same type as REALPART; i.e.,
‘(coerce 0 (type-of REALPART))’ is effectively used.

Type upgrading implies a movement upwards in the type hierarchy lattice.
In the case of complexes, the TYPE-SPECIFIER

must be a subtype of ‘(upgraded-complex-part-type TYPE-SPECIFIER)’.  If
TYPE-SPECIFIER1 is a subtype of TYPE-SPECIFIER2, then
‘(upgraded-complex-element-type 'TYPE-SPECIFIER1)’ must also be a
subtype of ‘(upgraded-complex-element-type 'TYPE-SPECIFIER2)’.  Two
disjoint types can be upgraded into the same thing.

Examples:
.........

 (complex 0) → 0
 (complex 0.0) → #C(0.0 0.0)
 (complex 1 1/2) → #C(1 1/2)
 (complex 1 .99) → #C(1.0 0.99)
 (complex 3/2 0.0) → #C(1.5 0.0)

See Also:
.........

*note realpart::, *note imagpart::, *note Section 2.4.8.11 (Sharpsign
C): SharpsignC.


File: ansicl,  Node: complexp,  Next: conjugate,  Prev: complex (Function),  Up: Numbers

complexp (Function)
===================

Syntax:
.......

 -- Function: complexp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘complex’; otherwise, returns false.

Examples:
.........

 (complexp 1.2d2) → false
 (complexp #c(5/3 7.2)) → true

See Also:
.........

*note complex (Function):: (function and type), *note typep::

Notes:
......

 (complexp OBJECT) ≡ (typep OBJECT 'complex)


File: ansicl,  Node: conjugate,  Next: phase,  Prev: complexp,  Up: Numbers

conjugate (Function)
====================

Syntax:
.......

 -- Function: conjugate number → conjugate

Arguments and Values:
.....................

NUMBER--a number.

CONJUGATE--a number.

Description:
............

Returns the complex conjugate of NUMBER.  The conjugate of a real
number is itself.

Examples:
.........

 (conjugate #c(0 -1)) → #C(0 1)
 (conjugate #c(1 1)) → #C(1 -1)
 (conjugate 1.5) → 1.5
 (conjugate #C(3/5 4/5)) → #C(3/5 -4/5)
 (conjugate #C(0.0D0 -1.0D0)) → #C(0.0D0 1.0D0)
 (conjugate 3.7) → 3.7

Notes:
......

For a complex number ‘z’,

 (conjugate z) ≡ (complex (realpart z) (- (imagpart z)))


File: ansicl,  Node: phase,  Next: realpart; imagpart,  Prev: conjugate,  Up: Numbers

phase (Function)
================

Syntax:
.......

 -- Function: phase number → phase

Arguments and Values:
.....................

NUMBER--a number.

PHASE--a number.

Description:
............

‘phase’ returns the phase of NUMBER (the angle part of its polar
representation) in radians, in the range -π (exclusive) if minus zero
is not supported, or -π (inclusive) if minus zero is supported, to π
(inclusive).  The phase of a positive real number is zero; that of a
negative real number is π.  The phase of zero is defined to be zero.

If NUMBER is a complex float, the result is a float of the same type as
the components of NUMBER.  If NUMBER is a float, the result is a float
of the same type.  If NUMBER is a rational or a complex rational, the
result is a single float.

The branch cut for ‘phase’ lies along the negative real axis,
continuous with quadrant II.  The range consists of that portion of the
real axis between -π (exclusive) and π (inclusive).

The mathematical definition of ‘phase’ is as follows:

‘(phase x) = (atan (imagpart x) (realpart x))’

Examples:
.........

 (phase 1) → 0.0s0
 (phase 0) → 0.0s0
 (phase (cis 30)) → -1.4159266
 (phase #c(0 1)) → 1.5707964

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not a number.  Might
signal ‘arithmetic-error’.

See Also:
.........

*note Section 12.1.3.3 (Rule of Float Substitutability):
FloatSubstitutability.


File: ansicl,  Node: realpart; imagpart,  Next: upgraded-complex-part-type,  Prev: phase,  Up: Numbers

realpart, imagpart (Function)
=============================

Syntax:
.......

 -- Function: realpart number → real

 -- Function: imagpart number → real

Arguments and Values:
.....................

NUMBER--a number.

REAL--a real.

Description:
............

‘realpart’ and ‘imagpart’ return the real and imaginary parts of NUMBER
respectively.  If NUMBER is real, then ‘realpart’ returns NUMBER and
‘imagpart’ returns ‘(* 0 NUMBER)’, which has the effect that the
imaginary part of a rational is ‘0’ and that of a float is a
floating-point zero of the same format.

Examples:
.........

 (realpart #c(23 41)) → 23
 (imagpart #c(23 41.0)) → 41.0
 (realpart #c(23 41.0)) → 23.0
 (imagpart 23.0) → 0.0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a number.

See Also:
.........

*note complex (Function)::


File: ansicl,  Node: upgraded-complex-part-type,  Next: realp,  Prev: realpart; imagpart,  Up: Numbers

upgraded-complex-part-type (Function)
=====================================

Syntax:
.......

 -- Function: upgraded-complex-part-type typespec &optional environment
          → upgraded-typespec

Arguments and Values:
.....................

TYPESPEC--a type specifier.

ENVIRONMENT--an environment object.  The default is ‘nil’, denoting the
null lexical environment and the and current global environment.

UPGRADED-TYPESPEC--a type specifier.

Description:
............

‘upgraded-complex-part-type’ returns the part type of the most
specialized complex number representation that can hold parts of type
typespec.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

The purpose of ‘upgraded-complex-part-type’ is to reveal how an
implementation does its upgrading.

See Also:
.........

*note complex (Function):: (function and type)

Notes:
......


File: ansicl,  Node: realp,  Next: numerator; denominator,  Prev: upgraded-complex-part-type,  Up: Numbers

realp (Function)
================

Syntax:
.......

 -- Function: realp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘real’; otherwise, returns false.

Examples:
.........

 (realp 12) → true
 (realp #c(5/3 7.2)) → false
 (realp nil) → false
 (realp (cons 1 2)) → false

Notes:
......

 (realp OBJECT) ≡ (typep OBJECT 'real)


File: ansicl,  Node: numerator; denominator,  Next: rational; rationalize,  Prev: realp,  Up: Numbers

numerator, denominator (Function)
=================================

Syntax:
.......

 -- Function: numerator rational → numerator

 -- Function: denominator rational → denominator

Arguments and Values:
.....................

RATIONAL--a rational.

NUMERATOR--an integer.

DENOMINATOR--a positive integer.

Description:
............

‘numerator’ and ‘denominator’ reduce RATIONAL to canonical form and
compute the numerator or denominator of that number.

‘numerator’ and ‘denominator’ return the numerator or denominator of
the canonical form of RATIONAL.

If RATIONAL is an integer, ‘numerator’ returns RATIONAL and
‘denominator’ returns 1.

Examples:
.........

 (numerator 1/2) → 1
 (denominator 12/36) → 3
 (numerator -1) → -1
 (denominator (/ -33)) → 33
 (numerator (/ 8 -6)) → -4
 (denominator (/ 8 -6)) → 3

See Also:
.........

*note / (Function)::

Notes:
......

 (gcd (numerator x) (denominator x)) → 1


File: ansicl,  Node: rational; rationalize,  Next: rationalp,  Prev: numerator; denominator,  Up: Numbers

rational, rationalize (Function)
================================

Syntax:
.......

 -- Function: rational number → rational

 -- Function: rationalize number → rational

Arguments and Values:
.....................

NUMBER--a real.

RATIONAL--a rational.

Description:
............

‘rational’ and ‘rationalize’ convert reals to rationals.

If NUMBER is already rational, it is returned.

If NUMBER is a float, ‘rational’ returns a rational that is
mathematically equal in value to the float.  ‘rationalize’ returns a
rational that approximates the float to the accuracy of the underlying
floating-point representation.

‘rational’ assumes that the float is completely accurate.

‘rationalize’ assumes that the float is accurate only to the precision
of the floating-point representation.

Examples:
.........

 (rational 0) → 0
 (rationalize -11/100) → -11/100
 (rational .1) → 13421773/134217728 ;implementation-dependent
 (rationalize .1) → 1/10

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NUMBER is not a real.
Might signal ‘arithmetic-error’.

Notes:
......

It is always the case that

 (float (rational x) x) ≡ x

and

 (float (rationalize x) x) ≡ x

That is, rationalizing a float by either method and then converting it
back to a float of the same format produces the original NUMBER.


File: ansicl,  Node: rationalp,  Next: ash,  Prev: rational; rationalize,  Up: Numbers

rationalp (Function)
====================

Syntax:
.......

 -- Function: rationalp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘rational’; otherwise, returns false.

Examples:
.........

 (rationalp 12) → true
 (rationalp 6/5) → true
 (rationalp 1.212) → false

See Also:
.........

*note rational::

Notes:
......

 (rationalp OBJECT) ≡ (typep OBJECT 'rational)


File: ansicl,  Node: ash,  Next: integer-length,  Prev: rationalp,  Up: Numbers

ash (Function)
==============

Syntax:
.......

 -- Function: ash integer count → shifted-integer

Arguments and Values:
.....................

INTEGER--an integer.

COUNT--an integer.

SHIFTED-INTEGER--an integer.

Description:
............

‘ash’ performs the arithmetic shift operation on the binary
representation of INTEGER, which is treated as if it were binary.

‘ash’ shifts INTEGER arithmetically left by COUNT bit positions if
COUNT is positive, or right COUNT bit positions if COUNT is negative.
The shifted value of the same sign as INTEGER is returned.

Mathematically speaking, ‘ash’ performs the computation
‘floor’(INTEGER· 2^COUNT).  Logically, ‘ash’ moves all of the bits in
INTEGER to the left, adding zero-bits at the right, or moves them to
the right, discarding bits.

‘ash’ is defined to behave as if INTEGER were represented in two's
complement form, regardless of how integers are represented internally.

Examples:
.........

 (ash 16 1) → 32
 (ash 16 0) → 16
 (ash 16 -1) → 8
 (ash -100000000000000000000000000000000 -100) → -79

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.  Should signal an error of type ‘type-error’ if COUNT is not
an integer.  Might signal ‘arithmetic-error’.

Notes:
......

 (logbitp J (ash N K))
 ≡ (and (>= J K) (logbitp (- J K) N))


File: ansicl,  Node: integer-length,  Next: integerp,  Prev: ash,  Up: Numbers

integer-length (Function)
=========================

Syntax:
.......

 -- Function: integer-length integer → number-of-bits

Arguments and Values:
.....................

INTEGER--an integer.

NUMBER-OF-BITS--a non-negative integer.

Description:
............

Returns the number of bits needed to represent INTEGER in binary
two's-complement format.

Examples:
.........

 (integer-length 0) → 0
 (integer-length 1) → 1
 (integer-length 3) → 2
 (integer-length 4) → 3
 (integer-length 7) → 3
 (integer-length -1) → 0
 (integer-length -4) → 2
 (integer-length -7) → 3
 (integer-length -8) → 3
 (integer-length (expt 2 9)) → 10
 (integer-length (1- (expt 2 9))) → 9
 (integer-length (- (expt 2 9))) → 9
 (integer-length (- (1+ (expt 2 9)))) → 10

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER is not an
integer.

Notes:
......

This function could have been defined by:

(defun integer-length (integer)
  (ceiling (log (if (minusp integer)
                    (- integer)
                    (1+ integer))
                2)))

If INTEGER is non-negative, then its value can be represented in
unsigned binary form in a field whose width in bits is no smaller than
‘(integer-length INTEGER)’.  Regardless of the sign of INTEGER, its
value can be represented in signed binary two's-complement form in a
field whose width in bits is no smaller than ‘(+ (integer-length
INTEGER) 1)’.


File: ansicl,  Node: integerp,  Next: parse-integer,  Prev: integer-length,  Up: Numbers

integerp (Function)
===================

Syntax:
.......

 -- Function: integerp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘integer’; otherwise, returns false.

Examples:
.........

 (integerp 1) → true
 (integerp (expt 2 130)) → true
 (integerp 6/5) → false
 (integerp nil) → false

Notes:
......

 (integerp OBJECT) ≡ (typep OBJECT 'integer)


File: ansicl,  Node: parse-integer,  Next: boole,  Prev: integerp,  Up: Numbers

parse-integer (Function)
========================

Syntax:
.......

 -- Function: parse-integer string &key start end radix junk-allowed →
          integer, pos

Arguments and Values:
.....................

STRING--a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

RADIX--a radix.  The default is ‘10’.

JUNK-ALLOWED--a generalized boolean.  The default is false.

INTEGER--an integer or false.

POS--a bounding index of STRING.

Description:
............

‘parse-integer’ parses an integer in the specified RADIX from the
substring of STRING delimited by START and END.

‘parse-integer’ expects an optional sign (‘+’ or ‘-’) followed by a a
non-empty sequence of digits to be interpreted in the specified RADIX.
Optional leading and trailing whitespace₁ is ignored.

‘parse-integer’ does not recognize the syntactic radix-specifier
prefixes ‘#O’, ‘#B’, ‘#X’, and ‘#nR’, nor does it recognize a trailing
decimal point.

If JUNK-ALLOWED is false, an error of type ‘parse-error’ is signaled if
substring does not consist entirely of the representation of a signed
integer, possibly surrounded on either side by whitespace₁ characters.

The first value returned is either the integer that was parsed, or else
‘nil’ if no syntactically correct integer was seen but JUNK-ALLOWED was
true.

The second value is either the index into the string of the delimiter
that terminated the parse, or the upper bounding index of the substring
if the parse terminated at the end of the substring (as is always the
case if JUNK-ALLOWED is false).

Examples:
.........

 (parse-integer "123") → 123, 3
 (parse-integer "123" :start 1 :radix 5) → 13, 3
 (parse-integer "no-integer" :junk-allowed t) → NIL, 0

Exceptional Situations:
.......................

If JUNK-ALLOWED is false, an error is signaled if substring does not
consist entirely of the representation of an integer, possibly
surrounded on either side by whitespace₁ characters.


File: ansicl,  Node: boole,  Next: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Prev: parse-integer,  Up: Numbers

boole (Function)
================

Syntax:
.......

 -- Function: boole op integer-1 integer-2 → result-integer

Arguments and Values:
.....................

OP--a bit-wise logical operation specifier.

INTEGER-1--an integer.

INTEGER-2--an integer.

RESULT-INTEGER--an integer.

Description:
............

‘boole’ performs bit-wise logical operations on INTEGER-1 and
INTEGER-2, which are treated as if they were binary and in two's
complement representation.

The operation to be performed and the return value are determined by OP.

‘boole’ returns the values specified for any OP in the next figure.

Op              Result
------------------------------------------------------------- 
‘boole-1’       INTEGER-1
‘boole-2’       INTEGER-2
‘boole-andc1’   and complement of INTEGER-1 with INTEGER-2
‘boole-andc2’   and INTEGER-1 with complement of INTEGER-2
‘boole-and’     and
‘boole-c1’      complement of INTEGER-1
‘boole-c2’      complement of INTEGER-2
‘boole-clr’     always 0 (all zero bits)
‘boole-eqv’     equivalence (exclusive nor)
‘boole-ior’     inclusive or
‘boole-nand’    not-and
‘boole-nor’     not-or
‘boole-orc1’    or complement of INTEGER-1 with INTEGER-2
‘boole-orc2’    or INTEGER-1 with complement of INTEGER-2
‘boole-set’     always -1 (all one bits)
‘boole-xor’     exclusive or

Figure 12.17: Bit-Wise Logical Operations

Examples:
.........

 (boole boole-ior 1 16) → 17
 (boole boole-and -2 5) → 4
 (boole boole-eqv 17 15) → -31

;;; These examples illustrate the result of applying BOOLE and each
;;; of the possible values of OP to each possible combination of bits.
 (progn
   (format t "~&Results of (BOOLE <op> #b0011 #b0101) ...~
           ~%---Op-------Decimal-----Binary----Bits---~%")
   (dolist (symbol '(boole-1     boole-2    boole-and  boole-andc1
                     boole-andc2 boole-c1   boole-c2   boole-clr
                     boole-eqv   boole-ior  boole-nand boole-nor
                     boole-orc1  boole-orc2 boole-set  boole-xor))
     (let ((result (boole (symbol-value symbol) #b0011 #b0101)))
       (format t "~& ~A~13T~3,' D~23T~:*~5,' B~31T ...~4,'0B~%"
               symbol result (logand result #b1111)))))
▷ Results of (BOOLE <op> #b0011 #b0101) ...
▷ ---Op-------Decimal-----Binary----Bits---
▷  BOOLE-1       3          11    ...0011
▷  BOOLE-2       5         101    ...0101
▷  BOOLE-AND     1           1    ...0001
▷  BOOLE-ANDC1   4         100    ...0100
▷  BOOLE-ANDC2   2          10    ...0010
▷  BOOLE-C1     -4        -100    ...1100
▷  BOOLE-C2     -6        -110    ...1010
▷  BOOLE-CLR     0           0    ...0000
▷  BOOLE-EQV    -7        -111    ...1001
▷  BOOLE-IOR     7         111    ...0111
▷  BOOLE-NAND   -2         -10    ...1110
▷  BOOLE-NOR    -8       -1000    ...1000
▷  BOOLE-ORC1   -3         -11    ...1101
▷  BOOLE-ORC2   -5        -101    ...1011
▷  BOOLE-SET    -1          -1    ...1111
▷  BOOLE-XOR     6         110    ...0110
→ NIL

Exceptional Situations:
.......................

Should signal ‘type-error’ if its first argument is not a bit-wise
logical operation specifier or if any subsequent argument is not an
integer.

See Also:
.........

*note logand::

Notes:
......

In general,

 (boole boole-and x y) ≡ (logand x y)

Programmers who would prefer to use numeric indices rather than
bit-wise logical operation specifiers can get an equivalent effect by a
technique such as the following:

;; The order of the values in this `table' are such that
;; (logand (boole (elt boole-n-vector n) #b0101 #b0011) #b1111) => n
 (defconstant boole-n-vector
    (vector boole-clr   boole-and  boole-andc1 boole-2
            boole-andc2 boole-1    boole-xor   boole-ior
            boole-nor   boole-eqv  boole-c1    boole-orc1
            boole-c2    boole-orc2 boole-nand  boole-set))
→ BOOLE-N-VECTOR
 (proclaim '(inline boole-n))
→ implementation-dependent
 (defun boole-n (n integer &rest more-integers)
   (apply #'boole (elt boole-n-vector n) integer more-integers))
→ BOOLE-N
 (boole-n #b0111 5 3) → 7
 (boole-n #b0001 5 3) → 1
 (boole-n #b1101 5 3) → -3
 (loop for n from #b0000 to #b1111 collect (boole-n n 5 3))
→ (0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1)


File: ansicl,  Node: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Next: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Prev: boole,  Up: Numbers

boole-1, boole-2, boole-and, boole-andc1, boole-andc2, boole-c1, boole-c2, boole-clr, boole-eqv, boole-ior, boole-nand, boole-nor, boole-orc1, boole-orc2, boole-set, boole-xor (Constant Variable)
===================================================================================================================================================================================================

Constant Value:
...............

The identity and nature of the values of each of these variables is
implementation-dependent, except that it must be distinct from each of
the values of the others, and it must be a valid first argument to the
function ‘boole’.

Description:
............

Each of these constants has a value which is one of the sixteen
possible bit-wise logical operation specifiers.

Examples:
.........

 (boole boole-ior 1 16) → 17
 (boole boole-and -2 5) → 4
 (boole boole-eqv 17 15) → -31

See Also:
.........

*note boole::


File: ansicl,  Node: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Next: logbitp,  Prev: boole-1; boole-2; boole-and; boole-andc1; boole-andc2; boole-c1; boole-+,  Up: Numbers

logand, logandc1, logandc2, logeqv, logior, lognand, lognor, lognot, logorc1, logorc2, logxor (Function)
========================================================================================================

Syntax:
.......

 -- Function: logand &rest integers → result-integer

 -- Function: logandc1 integer-1 integer-2 → result-integer

 -- Function: logandc2 integer-1 integer-2 → result-integer

 -- Function: logeqv &rest integers → result-integer

 -- Function: logior &rest integers → result-integer

 -- Function: lognand integer-1 integer-2 → result-integer

 -- Function: lognor integer-1 integer-2 → result-integer

 -- Function: lognot integer → result-integer

 -- Function: logorc1 integer-1 integer-2 → result-integer

 -- Function: logorc2 integer-1 integer-2 → result-integer

 -- Function: logxor &rest integers → result-integer

Arguments and Values:
.....................

INTEGERS--integers.

INTEGER--an integer.

INTEGER-1--an integer.

INTEGER-2--an integer.

RESULT-INTEGER--an integer.

Description:
............

The functions ‘logandc1’, ‘logandc2’, ‘logand’, ‘logeqv’, ‘logior’,
‘lognand’, ‘lognor’, ‘lognot’, ‘logorc1’, ‘logorc2’, and ‘logxor’
perform bit-wise logical operations on their arguments, that are
treated as if they were binary.

The next figure lists the meaning of each of the functions.  Where an
`identity' is shown, it indicates the value yielded by the function
when no arguments are supplied.

Function     Identity   Operation performed
--------------------------------------------------------------------- 
‘logandc1’   --         and complement of INTEGER-1 with INTEGER-2
‘logandc2’   --         and INTEGER-1 with complement of INTEGER-2
‘logand’     ‘-1’       and
‘logeqv’     ‘-1’       equivalence (exclusive nor)
‘logior’     ‘0’        inclusive or
‘lognand’    --         complement of INTEGER-1 and INTEGER-2
‘lognor’     --         complement of INTEGER-1 or INTEGER-2
‘lognot’     --         complement
‘logorc1’    --         or complement of INTEGER-1 with INTEGER-2
‘logorc2’    --         or INTEGER-1 with complement of INTEGER-2
‘logxor’     ‘0’        exclusive or

Figure 12.18: Bit-wise Logical Operations on Integers

Negative INTEGERS are treated as if they were in two's-complement
notation.

Examples:
.........

 (logior 1 2 4 8) → 15
 (logxor 1 3 7 15) → 10
 (logeqv) → -1
 (logand 16 31) → 16
 (lognot 0) → -1
 (lognot 1) → -2
 (lognot -1) → 0
 (lognot (1+ (lognot 1000))) → 999

;;; In the following example, m is a mask.  For each bit in
;;; the mask that is a 1, the corresponding bits in x and y are
;;; exchanged.  For each bit in the mask that is a 0, the
;;; corresponding bits of x and y are left unchanged.
 (flet ((show (m x y)
          (format t "~%m = #o~6,'0O~%x = #o~6,'0O~%y = #o~6,'0O~%"
                  m x y)))
   (let ((m #o007750)
         (x #o452576)
         (y #o317407))
     (show m x y)
     (let ((z (logand (logxor x y) m)))
       (setq x (logxor z x))
       (setq y (logxor z y))
       (show m x y))))
▷ m = #o007750
▷ x = #o452576
▷ y = #o317407
▷
▷ m = #o007750
▷ x = #o457426
▷ y = #o312557
→ NIL

Exceptional Situations:
.......................

Should signal ‘type-error’ if any argument is not an integer.

See Also:
.........

*note boole::

Notes:
......

‘(logbitp K -1)’ returns true for all values of K.

Because the following functions are not associative, they take exactly
two arguments rather than any number of arguments.

 (lognand N1 N2) ≡ (lognot (logand N1 N2))
 (lognor N1 N2) ≡ (lognot (logior N1 N2))
 (logandc1 N1 N2) ≡ (logand (lognot N1) N2)
 (logandc2 N1 N2) ≡ (logand N1 (lognot N2))
 (logiorc1 N1 N2) ≡ (logior (lognot N1) N2)
 (logiorc2 N1 N2) ≡ (logior N1 (lognot N2))
 (logbitp J (lognot X)) ≡ (not (logbitp J X))


File: ansicl,  Node: logbitp,  Next: logcount,  Prev: logand; logandc1; logandc2; logeqv; logior; lognand; lognor; lognot; lo+,  Up: Numbers

logbitp (Function)
==================

Syntax:
.......

 -- Function: logbitp index integer → generalized-boolean

Arguments and Values:
.....................

INDEX--a non-negative integer.

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘logbitp’ is used to test the value of a particular bit in INTEGER,
that is treated as if it were binary.  The value of ‘logbitp’ is true
if the bit in INTEGER whose index is INDEX (that is, its weight is
2^index) is a one-bit; otherwise it is false.

Negative INTEGERS are treated as if they were in two's-complement
notation.

Examples:
.........

 (logbitp 1 1) → false
 (logbitp 0 1) → true
 (logbitp 3 10) → true
 (logbitp 1000000 -1) → true
 (logbitp 2 6) → true
 (logbitp 0 6) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INDEX is not a
non-negative integer.  Should signal an error of type ‘type-error’ if
INTEGER is not an integer.

Notes:
......

 (logbitp K N) ≡ (ldb-test (byte 1 K) N)


File: ansicl,  Node: logcount,  Next: logtest,  Prev: logbitp,  Up: Numbers

logcount (Function)
===================

Syntax:
.......

 -- Function: logcount integer → number-of-on-bits

Arguments and Values:
.....................

INTEGER--an integer.

NUMBER-OF-ON-BITS--a non-negative integer.

Description:
............

Computes and returns the number of bits in the two's-complement binary
representation of INTEGER that are `on' or `set'.  If INTEGER is
negative, the ‘0’ bits are counted; otherwise, the ‘1’ bits are counted.

Examples:
.........

 (logcount 0) → 0
 (logcount -1) → 0
 (logcount 7) → 3
 (logcount  13) → 3 ;Two's-complement binary: ...0001101
 (logcount -13) → 2 ;Two's-complement binary: ...1110011
 (logcount  30) → 4 ;Two's-complement binary: ...0011110
 (logcount -30) → 4 ;Two's-complement binary: ...1100010
 (logcount (expt 2 100)) → 1
 (logcount (- (expt 2 100))) → 100
 (logcount (- (1+ (expt 2 100)))) → 1

Exceptional Situations:
.......................

Should signal ‘type-error’ if its argument is not an integer.

Notes:
......

Even if the implementation does not represent integers internally in
two's complement binary, ‘logcount’ behaves as if it did.

The following identity always holds:

    (logcount X)
 ≡ (logcount (- (+ X 1)))
 ≡ (logcount (lognot X))


File: ansicl,  Node: logtest,  Next: byte; byte-size; byte-position,  Prev: logcount,  Up: Numbers

logtest (Function)
==================

Syntax:
.......

 -- Function: logtest integer-1 integer-2 → generalized-boolean

Arguments and Values:
.....................

INTEGER-1--an integer.

INTEGER-2--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if any of the bits designated by the 1's in INTEGER-1 is 1
in INTEGER-2; otherwise it is false.  INTEGER-1 and INTEGER-2 are
treated as if they were binary.

Negative INTEGER-1 and INTEGER-2 are treated as if they were
represented in two's-complement binary.

Examples:
.........

 (logtest 1 7) → true
 (logtest 1 2) → false
 (logtest -2 -1) → true
 (logtest 0 -1) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if INTEGER-1 is not an
integer.  Should signal an error of type ‘type-error’ if INTEGER-2 is
not an integer.

Notes:
......

 (logtest X Y) ≡ (not (zerop (logand X Y)))


File: ansicl,  Node: byte; byte-size; byte-position,  Next: deposit-field,  Prev: logtest,  Up: Numbers

byte, byte-size, byte-position (Function)
=========================================

Syntax:
.......

 -- Function: byte size position → bytespec

 -- Function: byte-size bytespec → size

 -- Function: byte-position bytespec → position

Arguments and Values:
.....................

SIZE, POSITION--a non-negative integer.

BYTESPEC--a byte specifier.

Description:
............

‘byte’ returns a byte specifier that indicates a byte of width SIZE and
whose bits have weights 2^POSITION + SIZE - 1 through 2^POSITION, and
whose representation is implementation-dependent.

‘byte-size’ returns the number of bits specified by BYTESPEC.

‘byte-position’ returns the position specified by BYTESPEC.

Examples:
.........

 (setq b (byte 100 200)) → #<BYTE-SPECIFIER size 100 position 200>
 (byte-size b) → 100
 (byte-position b) → 200

See Also:
.........

*note ldb::, *note dpb::

Notes:
......

 (byte-size (byte J K)) ≡ J
 (byte-position (byte J K)) ≡ K

A byte of size of ‘0’ is permissible; it refers to a byte of width
zero.  For example,

 (ldb (byte 0 3) #o7777) → 0
 (dpb #o7777 (byte 0 3) 0) → 0


File: ansicl,  Node: deposit-field,  Next: dpb,  Prev: byte; byte-size; byte-position,  Up: Numbers

deposit-field (Function)
========================

Syntax:
.......

 -- Function: deposit-field newbyte bytespec integer → result-integer

Arguments and Values:
.....................

NEWBYTE--an integer.

BYTESPEC--a byte specifier.

INTEGER--an integer.

RESULT-INTEGER--an integer.

Description:
............

Replaces a field of bits within INTEGER; specifically, returns an
integer that contains the bits of NEWBYTE within the byte specified by
BYTESPEC, and elsewhere contains the bits of INTEGER.

Examples:
.........

 (deposit-field 7 (byte 2 1) 0) → 6
 (deposit-field -1 (byte 4 0) 0) → 15
 (deposit-field 0 (byte 2 1) -3) → -7

See Also:
.........

*note byte::, *note dpb::

Notes:
......

 (logbitp J (deposit-field M (byte S P) N))
 ≡ (if (and (>= J P) (< J (+ P S)))
        (logbitp J M)
        (logbitp J N))

‘deposit-field’ is to ‘mask-field’ as ‘dpb’           is to ‘ldb’.


File: ansicl,  Node: dpb,  Next: ldb,  Prev: deposit-field,  Up: Numbers

dpb (Function)
==============

Syntax:
.......

 -- Function: dpb newbyte bytespec integer → result-integer

Pronunciation:
..............

[ˌdə ˈpib] or [ˌdə ˈpə b] or [ˈdēˈpēˈbē]

Arguments and Values:
.....................

NEWBYTE--an integer.

BYTESPEC--a byte specifier.

INTEGER--an integer.

RESULT-INTEGER--an integer.

Description:
............

‘dpb’ (deposit byte) is used to replace a field of bits within INTEGER.
‘dpb’ returns an integer that is the same as INTEGER except in the bits
specified by BYTESPEC.

Let ‘s’ be the size specified by BYTESPEC; then the low ‘s’ bits of
NEWBYTE appear in the result in the byte specified by BYTESPEC.
NEWBYTE is interpreted as being right-justified, as if it were the
result of ‘ldb’.

Examples:
.........

 (dpb 1 (byte 1 10) 0) → 1024
 (dpb -2 (byte 2 10) 0) → 2048
 (dpb 1 (byte 2 10) 2048) → 1024

See Also:
.........

*note byte::, *note deposit-field::, *note ldb::

Notes:
......

 (logbitp J (dpb M (byte S P) N))
 ≡ (if (and (>= J P) (< J (+ P S)))
        (logbitp (- J P) M)
        (logbitp J N))

In general,

 (dpb X (byte 0 Y) Z) → Z

for all valid values of X, Y, and Z.

Historically, the name "dpb" comes from a DEC PDP-10 assembly language
instruction meaning "deposit byte."


File: ansicl,  Node: ldb,  Next: ldb-test,  Prev: dpb,  Up: Numbers

ldb (Accessor)
==============

Syntax:
.......

 -- Function: ldb bytespec integer → byte

(setf (ldb bytespec place) new-byte)

Pronunciation:
..............

[ˈlidib] or [ˈlidə b] or [ˈelˈdēˈbē]

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

BYTE, NEW-BYTE--a non-negative integer.

Description:
............

‘ldb’ extracts and returns the byte of INTEGER specified by BYTESPEC.

‘ldb’ returns an integer in which the bits with weights 2^(s-1) through
2^0 are the same as those in INTEGER with weights 2^(p+s-1) through
2^p, and all other bits zero; s is ‘(byte-size BYTESPEC)’ and p is
‘(byte-position BYTESPEC)’.

‘setf’ may be used with ‘ldb’ to modify a byte within the INTEGER that
is stored in a given PLACE.  The order of evaluation, when an ‘ldb’
form is supplied to ‘setf’, is exactly left-to-right.  The effect is to
perform a ‘dpb’ operation and then store the result back into the PLACE.

Examples:
.........

 (ldb (byte 2 1) 10) → 1
 (setq a (list 8)) → (8)
 (setf (ldb (byte 2 1) (car a)) 1) → 1
 a → (10)

See Also:
.........

*note byte::, *note byte-position::, *note byte-size::, *note dpb::

Notes:
......

 (logbitp J (ldb (byte S P) N))
    ≡ (and (< J S) (logbitp (+ J P) N))

In general,

 (ldb (byte 0 X) Y) → 0

for all valid values of X and Y.

Historically, the name "ldb" comes from a DEC PDP-10 assembly language
instruction meaning "load byte."


File: ansicl,  Node: ldb-test,  Next: mask-field,  Prev: ldb,  Up: Numbers

ldb-test (Function)
===================

Syntax:
.......

 -- Function: ldb-test bytespec integer → generalized-boolean

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if any of the bits of the byte in INTEGER specified by
BYTESPEC is non-zero; otherwise returns false.

Examples:
.........

 (ldb-test (byte 4 1) 16) → true
 (ldb-test (byte 3 1) 16) → false
 (ldb-test (byte 3 2) 16) → true

See Also:
.........

*note byte::, *note ldb::, *note zerop::

Notes:
......

 (ldb-test bytespec n) ≡
 (not (zerop (ldb bytespec n))) ≡
 (logtest (ldb bytespec -1) n)


File: ansicl,  Node: mask-field,  Next: most-positive-fixnum; most-negative-fixnum,  Prev: ldb-test,  Up: Numbers

mask-field (Accessor)
=====================

Syntax:
.......

 -- Function: mask-field bytespec integer → masked-integer

(setf (mask-field bytespec place) new-masked-integer)

Arguments and Values:
.....................

BYTESPEC--a byte specifier.

INTEGER--an integer.

MASKED-INTEGER, NEW-MASKED-INTEGER--a non-negative integer.

Description:
............

‘mask-field’ performs a "mask" operation on INTEGER.  It returns an
integer that has the same bits as INTEGER in the byte specified by
BYTESPEC, but that has zero-bits everywhere else.

‘setf’ may be used with ‘mask-field’ to modify a byte within the
integer that is stored in a given PLACE.  The effect is to perform a
‘deposit-field’ operation and then store the result back into the PLACE.

Examples:
.........

 (mask-field (byte 1 5) -1) → 32
 (setq a 15) → 15
 (mask-field (byte 2 0) a) → 3
 a → 15
 (setf (mask-field (byte 2 0) a) 1) → 1
 a → 13

See Also:
.........

*note byte::, *note ldb::

Notes:
......

 (ldb BS (mask-field BS N)) ≡ (ldb BS N)
 (logbitp J (mask-field (byte S P) N))
   ≡ (and (>= J P) (< J S) (logbitp J N))
 (mask-field BS N) ≡ (logand N (dpb -1 BS 0))


File: ansicl,  Node: most-positive-fixnum; most-negative-fixnum,  Next: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Prev: mask-field,  Up: Numbers

most-positive-fixnum, most-negative-fixnum (Constant Variable)
==============================================================

Constant Value:
...............

implementation-dependent.

Description:
............

‘most-positive-fixnum’ is that fixnum closest in value to positive
infinity provided by the implementation, and greater than or equal to
both 2^15 - 1 and ‘array-dimension-limit’.

‘most-negative-fixnum’ is that fixnum closest in value to negative
infinity provided by the implementation, and less than or equal to
-2^15.


File: ansicl,  Node: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Next: float (Function),  Prev: most-positive-fixnum; most-negative-fixnum,  Up: Numbers

decode-float, scale-float, float-radix, float-sign, float-digits, float-precision, integer-decode-float (Function)
==================================================================================================================

Syntax:
.......

 -- Function: decode-float float → significand, exponent, sign

 -- Function: scale-float float integer → scaled-float

 -- Function: float-radix float → float-radix

 -- Function: float-sign float-1 &optional float-2 → signed-float

 -- Function: float-digits float → digits1

 -- Function: float-precision float → digits2

 -- Function: integer-decode-float float → significand, exponent,
          integer-sign

Arguments and Values:
.....................

DIGITS1--a non-negative integer.

DIGITS2--a non-negative integer.

EXPONENT--an integer.

FLOAT--a float.

FLOAT-1--a float.

FLOAT-2--a float.

FLOAT-RADIX--an integer.

INTEGER--a non-negative integer.

INTEGER-SIGN--the integer ‘-1’, or the integer ‘1’.

SCALED-FLOAT--a float.

SIGN--A float of the same type as FLOAT but numerically equal to ‘1.0’
or ‘-1.0’.

SIGNED-FLOAT--a float.

SIGNIFICAND--a float.

Description:
............

‘decode-float’ computes three values that characterize FLOAT.  The
first value is of the same type as FLOAT and represents the significand.
The second value represents the exponent to which the radix (notated in
this description by b) must be raised to obtain the value that, when
multiplied with the first result, produces the absolute value of FLOAT.
If FLOAT is zero, any integer value may be returned, provided that the
identity shown for ‘scale-float’ holds.  The third value is of the same
type as FLOAT and is 1.0 if FLOAT is greater than or equal to zero or
-1.0 otherwise.

‘decode-float’ divides FLOAT by an integral power of b so as to bring
its value between 1/b (inclusive) and 1 (exclusive), and returns the
quotient as the first value.  If FLOAT is zero, however, the result
equals the absolute value of FLOAT (that is, if there is a negative
zero, its significand is considered to be a positive zero).

‘scale-float’ returns ‘(* FLOAT (expt (float b FLOAT) INTEGER))’, where
b is the radix of the floating-point representation. FLOAT is not
necessarily between 1/b and 1.

‘float-radix’ returns the radix of FLOAT.

‘float-sign’ returns a number ‘z’ such that ‘z’ and FLOAT-1 have the
same sign and also such that ‘z’ and FLOAT-2 have the same absolute
value.  If FLOAT-2 is not supplied, its value is ‘(float 1 FLOAT-1)’.
If an implementation has distinct representations for negative zero and
positive zero, then ‘(float-sign -0.0)’ → ‘-1.0’.

‘float-digits’ returns the number of radix b digits used in the
representation of FLOAT (including any implicit digits, such as a
"hidden bit").

‘float-precision’ returns the number of significant radix b digits
present in FLOAT; if FLOAT is a float zero, then the result is an
integer zero.

For normalized floats, the results of ‘float-digits’ and
‘float-precision’ are the same, but the precision is less than the
number of representation digits for a denormalized or zero number.

‘integer-decode-float’ computes three values that characterize FLOAT -
the significand scaled so as to be an integer, and the same last two
values that are returned by ‘decode-float’.  If FLOAT is zero,
‘integer-decode-float’ returns zero as the first value.  The second
value bears the same relationship to the first value as for
‘decode-float’:

 (multiple-value-bind (signif expon sign)
                      (integer-decode-float f)
   (scale-float (float signif f) expon)) ≡ (abs f)

Examples:
.........

 ;; Note that since the purpose of this functionality is to expose
 ;; details of the implementation, all of these examples are necessarily
 ;; very implementation-dependent.  Results may vary widely.
 ;; Values shown here are chosen consistently from one particular implementation.
 (decode-float .5) → 0.5, 0, 1.0
 (decode-float 1.0) → 0.5, 1, 1.0
 (scale-float 1.0 1) → 2.0
 (scale-float 10.01 -2) → 2.5025
 (scale-float 23.0 0) → 23.0
 (float-radix 1.0) → 2
 (float-sign 5.0) → 1.0
 (float-sign -5.0) → -1.0
 (float-sign 0.0) → 1.0
 (float-sign 1.0 0.0) → 0.0
 (float-sign 1.0 -10.0) → 10.0
 (float-sign -1.0 10.0) → -10.0
 (float-digits 1.0) → 24
 (float-precision 1.0) → 24
 (float-precision least-positive-single-float) → 1
 (integer-decode-float 1.0) → 8388608, -23, 1

Affected By:
............

The implementation's representation for floats.

Exceptional Situations:
.......................

The functions ‘decode-float’, ‘float-radix’, ‘float-digits’,
‘float-precision’, and ‘integer-decode-float’ should signal an error if
their only argument is not a float.

The function ‘scale-float’ should signal an error if its first argument
is not a float or if its second argument is not an integer.

The function ‘float-sign’ should signal an error if its first argument
is not a float or if its second argument is supplied but is not a float.

Notes:
......

The product of the first result of ‘decode-float’ or
‘integer-decode-float’, of the radix raised to the power of the second
result, and of the third result is exactly equal to the value of FLOAT.

 (multiple-value-bind (signif expon sign)
                      (decode-float f)
   (scale-float signif expon))
≡ (abs f)

and

 (multiple-value-bind (signif expon sign)
                      (decode-float f)
   (* (scale-float signif expon) sign))
≡ f


File: ansicl,  Node: float (Function),  Next: floatp,  Prev: decode-float; scale-float; float-radix; float-sign; float-digits; float+,  Up: Numbers

float (Function)
================

Syntax:
.......

 -- Function: float number &optional prototype → float

Arguments and Values:
.....................

NUMBER--a real.

PROTOTYPE--a float.

FLOAT--a float.

Description:
............

‘float’ converts a real number to a float.

If a PROTOTYPE is supplied, a float is returned that is mathematically
equal to NUMBER but has the same format as PROTOTYPE.

If PROTOTYPE is not supplied, then if the NUMBER is already a float, it
is returned; otherwise, a float is returned that is mathematically
equal to NUMBER but is a single float.

Examples:
.........

 (float 0) → 0.0
 (float 1 .5) → 1.0
 (float 1.0) → 1.0
 (float 1/2) → 0.5
→ 1.0d0
or→ 1.0
 (eql (float 1.0 1.0d0) 1.0d0) → true

See Also:
.........

*note coerce::


File: ansicl,  Node: floatp,  Next: most-positive-short-float; least-positive-short-float; least-positive-n+,  Prev: float (Function),  Up: Numbers

floatp (Function)
=================

Syntax:
.......

 -- Function: floatp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘float’; otherwise, returns false.

Examples:
.........

 (floatp 1.2d2) → true
 (floatp 1.212) → true
 (floatp 1.2s2) → true
 (floatp (expt 2 130)) → false

Notes:
......

 (floatp OBJECT) ≡ (typep OBJECT 'float)


File: ansicl,  Node: most-positive-short-float; least-positive-short-float; least-positive-n+,  Next: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Prev: floatp,  Up: Numbers

most-positive-short-float, least-positive-short-float, least-positive-normalized-short-float, most-positive-double-float, least-positive-double-float, least-positive-normalized-double-float, most-positive-long-float, least-positive-long-float, least-positive-normalized-long-float, most-positive-single-float, least-positive-single-float, least-positive-normalized-single-float, most-negative-short-float, least-negative-short-float, least-negative-normalized-short-float, most-negative-single-float, least-negative-single-float, least-negative-normalized-single-float, most-negative-double-float, least-negative-double-float, least-negative-normalized-double-float, most-negative-long-float, least-negative-long-float, least-negative-normalized-long-float (Constant Variable)
========================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

These constant variables provide a way for programs to examine the
implementation-defined limits for the various float formats.

Of these variables, each which has "‘-normalized’" in its name must
have a value which is a normalized float, and each which does not have
"‘-normalized’" in its name may have a value which is either a
normalized float or a denormalized float, as appropriate.

Of these variables, each which has "‘short-float’" in its name must
have a value which is a short float, each which has "‘single-float’" in
its name must have a value which is a single float, each which has
"‘double-float’" in its name must have a value which is a double float,
and each which has "‘long-float’" in its name must have a value which
is a long float.

   * ‘most-positive-short-float’, ‘most-positive-single-float’,
     ‘most-positive-double-float’, ‘most-positive-long-float’

     Each of these constant variables has as its value the positive
     float of the largest magnitude (closest in value to, but not equal
     to, positive infinity) for the float format implied by its name.

   *
     ‘least-positive-short-float’, ‘least-positive-normalized-short-float’,
     ‘least-positive-single-float’, ‘least-positive-normalized-single-float’,
     ‘least-positive-double-float’, ‘least-positive-normalized-double-float’,
     ‘least-positive-long-float’, ‘least-positive-normalized-long-float’

     Each of these constant variables has as its value the smallest
     positive (nonzero) float for the float format implied by its name.

   *
     ‘least-negative-short-float’, ‘least-negative-normalized-short-float’,
     ‘least-negative-single-float’, ‘least-negative-normalized-single-float’,
     ‘least-negative-double-float’, ‘least-negative-normalized-double-float’,
     ‘least-negative-long-float’, ‘least-negative-normalized-long-float’

     Each of these constant variables has as its value the negative
     (nonzero) float of the smallest magnitude for the float format
     implied by its name.  (If an implementation supports minus zero as
     a different object from positive zero, this value must not be
     minus zero.)

   * ‘most-negative-short-float’, ‘most-negative-single-float’,
     ‘most-negative-double-float’, ‘most-negative-long-float’

     Each of these constant variables has as its value the negative
     float of the largest magnitude (closest in value to, but not equal
     to, negative infinity) for the float format implied by its name.

Notes:
......


File: ansicl,  Node: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Next: arithmetic-error,  Prev: most-positive-short-float; least-positive-short-float; least-positive-n+,  Up: Numbers

short-float-epsilon, short-float-negative-epsilon, single-float-epsilon, single-float-negative-epsilon, double-float-epsilon, double-float-negative-epsilon, long-float-epsilon, long-float-negative-epsilon (Constant Variable)
================================================================================================================================================================================================================================

Constant Value:
...............

implementation-dependent.

Description:
............

The value of each of the constants ‘short-float-epsilon’,
‘single-float-epsilon’, ‘double-float-epsilon’, and
‘long-float-epsilon’ is the smallest positive float ε of the given
format, such that the following expression is true when evaluated:

‘(not (= (float 1 ε) (+ (float 1 ε) ε)))’

The value of each of the constants ‘short-float-negative-epsilon’,
‘single-float-negative-epsilon’, ‘double-float-negative-epsilon’, and
‘long-float-negative-epsilon’ is the smallest positive float ε of the
given format, such that the following expression is true when evaluated:

‘(not (= (float 1 ε) (- (float 1 ε) ε)))’


File: ansicl,  Node: arithmetic-error,  Next: arithmetic-error-operands; arithmetic-error-operation,  Prev: short-float-epsilon; short-float-negative-epsilon; single-float-epsilon+,  Up: Numbers

arithmetic-error (Condition Type)
=================================

Class Precedence List:
......................

‘arithmetic-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘arithmetic-error’ consists of error conditions that occur
during arithmetic operations.  The operation and operands are
initialized with the initialization arguments named :operation and
:operands to ‘make-condition’, and are accessed by the functions
‘arithmetic-error-operation’ and ‘arithmetic-error-operands’.

See Also:
.........

*note arithmetic-error-operation::, *note arithmetic-error-operands::


File: ansicl,  Node: arithmetic-error-operands; arithmetic-error-operation,  Next: division-by-zero,  Prev: arithmetic-error,  Up: Numbers

arithmetic-error-operands, arithmetic-error-operation (Function)
================================================================

Syntax:
.......

 -- Function: arithmetic-error-operands condition → operands

 -- Function: arithmetic-error-operation condition → operation

Arguments and Values:
.....................

CONDITION--a condition of type ‘arithmetic-error’.

OPERANDS--a list.

OPERATION--a function designator.

Description:
............

‘arithmetic-error-operands’ returns a list of the operands which were
used in the offending call to the operation that signaled the CONDITION.

‘arithmetic-error-operation’ returns a list of the offending operation
in the offending call that signaled the CONDITION.

See Also:
.........

*note arithmetic-error::, *note Chapter 9 (Conditions): Conditions.

Notes:
......


File: ansicl,  Node: division-by-zero,  Next: floating-point-invalid-operation,  Prev: arithmetic-error-operands; arithmetic-error-operation,  Up: Numbers

division-by-zero (Condition Type)
=================================

Class Precedence List:
......................

‘division-by-zero’, ‘arithmetic-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘division-by-zero’ consists of error conditions that occur
because of division by zero.


File: ansicl,  Node: floating-point-invalid-operation,  Next: floating-point-inexact,  Prev: division-by-zero,  Up: Numbers

floating-point-invalid-operation (Condition Type)
=================================================

Class Precedence List:
......................

‘floating-point-invalid-operation’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-invalid-operation’ consists of error
conditions that occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: ansicl,  Node: floating-point-inexact,  Next: floating-point-overflow,  Prev: floating-point-invalid-operation,  Up: Numbers

floating-point-inexact (Condition Type)
=======================================

Class Precedence List:
......................

‘floating-point-inexact’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-inexact’ consists of error conditions that
occur because of certain floating point traps.

It is implementation-dependent whether floating point traps occur, and
whether or how they may be enabled or disabled.  Therefore, conforming
code may establish handlers for this condition, but must not depend on
its being signaled.


File: ansicl,  Node: floating-point-overflow,  Next: floating-point-underflow,  Prev: floating-point-inexact,  Up: Numbers

floating-point-overflow (Condition Type)
========================================

Class Precedence List:
......................

‘floating-point-overflow’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-overflow’ consists of error conditions that
occur because of floating-point overflow.


File: ansicl,  Node: floating-point-underflow,  Prev: floating-point-overflow,  Up: Numbers

floating-point-underflow (Condition Type)
=========================================

Class Precedence List:
......................

‘floating-point-underflow’, ‘arithmetic-error’, ‘error’,
‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘floating-point-underflow’ consists of error conditions that
occur because of floating-point underflow.


File: ansicl,  Node: Characters,  Next: Conses,  Prev: Numbers,  Up: Top

13 Characters
*************

* Menu:

* Character Concepts::

Dictionary

* character (System Class)::
* base-char::
* standard-char::
* extended-char::
* char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+::
* character (Function)::
* characterp::
* alpha-char-p::
* alphanumericp::
* digit-char::
* digit-char-p::
* graphic-char-p::
* standard-char-p::
* char-upcase; char-downcase::
* upper-case-p; lower-case-p; both-case-p::
* char-code::
* char-int::
* code-char::
* char-code-limit::
* char-name::
* name-char::


File: ansicl,  Node: Character Concepts,  Next: character (System Class),  Up: Characters

13.1 Character Concepts
=======================

* Menu:

* Introduction to Characters::
* Introduction to Scripts and Repertoires::
* Character Attributes::
* Character Categories::
* Identity of Characters::
* Ordering of Characters::
* Character Names::
* Treatment of Newline during Input and Output::
* Character Encodings::
* Documentation of Implementation-Defined Scripts::


File: ansicl,  Node: Introduction to Characters,  Next: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.1 Introduction to Characters
---------------------------------

A "character" is an object that represents a unitary token (e.g., a
letter, a special symbol, or a "control character") in an aggregate
quantity of text (e.g., a string or a text stream).

Common Lisp allows an implementation to provide support for
international language characters as well as characters used in
specialized arenas (e.g., mathematics).

The following figures contain lists of defined names applicable to
characters.

The next figure lists some defined names relating to character
attributes and character predicates.

alpha-char-p      char-not-equal      char>
alphanumericp     char-not-greaterp   char>=
both-case-p       char-not-lessp      digit-char-p
char-code-limit   char/=              graphic-char-p
char-equal        char<               lower-case-p
char-greaterp     char<=              standard-char-p
char-lessp        char=               upper-case-p

Figure 13.1: Character defined names - 1

The next figure lists some character construction and conversion
defined names.

char-code       char-name     code-char
char-downcase   char-upcase   digit-char
char-int        character     name-char

Figure 13.2: Character defined names - 2


File: ansicl,  Node: Introduction to Scripts and Repertoires,  Next: Character Attributes,  Prev: Introduction to Characters,  Up: Character Concepts

13.1.2 Introduction to Scripts and Repertoires
----------------------------------------------

13.1.2.1 Character Scripts
..........................

A script is one of possibly several sets that form an exhaustive
partition of the type ‘character’.

The number of such sets and boundaries between them is
implementation-defined.  Common Lisp does not require these sets to be
types, but an implementation is permitted to define such types as an
extension.  Since no character from one script can ever be a member of
another script, it is generally more useful to speak about character
repertoires.

Although the term "script" is chosen for definitional compatibility
with ISO terminology, no conforming implementation is required to use
any particular scripts standardized by ISO or by any other standards
organization.

Whether and how the script or scripts used by any given implementation
are named is implementation-dependent.

13.1.2.2 Character Repertoires
..............................

A "repertoire" is a type specifier for a subtype of type ‘character’.
This term is generally used when describing a collection of characters
independent of their coding.  Characters in repertoires are only
identified by name, by glyph, or by character description.

A repertoire can contain characters from several scripts, and a
character can appear in more than one repertoire.

For some examples of repertoires, see the coded character standards ISO
8859/1, ISO 8859/2, and ISO 6937/2.  Note, however, that although the
term "repertoire" is chosen for definitional compatibility with ISO
terminology, no conforming implementation is required to use
repertoires standardized by ISO or any other standards organization.


File: ansicl,  Node: Character Attributes,  Next: Character Categories,  Prev: Introduction to Scripts and Repertoires,  Up: Character Concepts

13.1.3 Character Attributes
---------------------------

Characters have only one standardized attribute: a code.  A character's
code is a non-negative integer.  This code is composed from a character
script and a character label in an implementation-dependent way.  See
the functions *note char-code:: and ‘code-char’.

Additional, implementation-defined attributes of characters are also
permitted so that, for example, two characters with the same code may
differ in some other, implementation-defined way.

For any implementation-defined attribute there is a distinguished value
called the "null" value for that attribute.  A character for which each
implementation-defined attribute has the null value for that attribute
is called a simple character.  If the implementation has no
implementation-defined attributes, then all characters are simple
characters.


File: ansicl,  Node: Character Categories,  Next: Identity of Characters,  Prev: Character Attributes,  Up: Character Concepts

13.1.4 Character Categories
---------------------------

There are several (overlapping) categories of characters that have no
formally associated type but that are nevertheless useful to name.
They include graphic characters, alphabetic₁ characters, characters
with case (uppercase and lowercase characters), numeric characters,
alphanumeric characters, and digits (in a given radix).

For each implementation-defined attribute of a character, the
documentation for that implementation must specify whether characters
that differ only in that attribute are permitted to differ in whether
are not they are members of one of the aforementioned categories.

Note that these terms are defined independently of any special syntax
which might have been enabled in the current readtable.

13.1.4.1 Graphic Characters
...........................

Characters that are classified as "graphic", or displayable, are each
associated with a glyph, a visual representation of the character.

A graphic character is one that has a standard textual representation
as a single glyph, such as ‘A’ or ‘*’ or ‘=’.  Space, which effectively
has a blank glyph, is defined to be a graphic.

Of the standard characters, newline is non-graphic and all others are
graphic; see *note Section 2.1.3 (Standard Characters): Standard
Characters.

Characters that are not graphic are called "non-graphic".  Non-graphic
characters are sometimes informally called "formatting characters" or
"control characters."

‘#\Backspace’, ‘#\Tab’, ‘#\Rubout’, ‘#\Linefeed’, ‘#\Return’, and
‘#\Page’, if they are supported by the implementation, are non-graphic.

13.1.4.2 Alphabetic Characters
..............................

The alphabetic₁ characters are a subset of the graphic characters.  Of
the standard characters, only these are the alphabetic₁ characters:

‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’

‘a b c d e f g h i j k l m n o p q r s t u v w x y z’

Any implementation-defined character that has case must be alphabetic₁.
For each implementation-defined graphic character that has no case, it
is implementation-defined whether that character is alphabetic₁.

13.1.4.3 Characters With Case
.............................

The characters with case are a subset of the alphabetic₁ characters.  A
character with case has the property of being either uppercase or
lowercase.  Every character with case is in one-to-one correspondence
with some other character with the opposite case.

13.1.4.3.1 Uppercase Characters
...............................

An uppercase character is one that has a corresponding lowercase
character that is different (and can be obtained using ‘char-downcase’).

Of the standard characters, only these are uppercase characters:

‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’

13.1.4.3.2 Lowercase Characters
...............................

A lowercase character is one that has a corresponding uppercase
character that is different (and can be obtained using ‘char-upcase’).

Of the standard characters, only these are lowercase characters:

‘a b c d e f g h i j k l m n o p q r s t u v w x y z’

13.1.4.3.3 Corresponding Characters in the Other Case
.....................................................

The uppercase standard characters ‘A’ through ‘Z’ mentioned above
respectively correspond to the lowercase standard characters ‘a’
through ‘z’ mentioned above.  For example, the uppercase character ‘E’
corresponds to the lowercase character ‘e’, and vice versa.

13.1.4.3.4 Case of Implementation-Defined Characters
....................................................

An implementation may define that other implementation-defined graphic
characters have case.  Such definitions must always be done in
pairs--one uppercase character in one-to-one correspondence with one
lowercase character.

13.1.4.4 Numeric Characters
...........................

The numeric characters are a subset of the graphic characters.  Of the
standard characters, only these are numeric characters:

‘0 1 2 3 4 5 6 7 8 9’

For each implementation-defined graphic character that has no case, the
implementation must define whether or not it is a numeric character.

13.1.4.5 Alphanumeric Characters
................................

The set of alphanumeric characters is the union of the set of
alphabetic₁ characters and the set of numeric characters.

13.1.4.6 Digits in a Radix
..........................

What qualifies as a digit depends on the radix (an integer between ‘2’
and ‘36’, inclusive).  The potential digits are:

‘0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y
Z’

Their respective weights are ‘0’, ‘1’, ‘2’, ... ‘35’.  In any given
radix n, only the first n potential digits are considered to be digits.
For example, the digits in radix ‘2’  are ‘0’ and ‘1’, the digits in
radix ‘10’ are ‘0’ through ‘9’, and the digits in radix ‘16’ are ‘0’
through ‘F’.

Case is not significant in digits; for example, in radix ‘16’, both ‘F’
and ‘f’ are digits with weight ‘15’.


File: ansicl,  Node: Identity of Characters,  Next: Ordering of Characters,  Prev: Character Categories,  Up: Character Concepts

13.1.5 Identity of Characters
-----------------------------

Two characters that are ‘eql’, ‘char=’, or ‘char-equal’ are not
necessarily ‘eq’.


File: ansicl,  Node: Ordering of Characters,  Next: Character Names,  Prev: Identity of Characters,  Up: Character Concepts

13.1.6 Ordering of Characters
-----------------------------

The total ordering on characters is guaranteed to have the following
properties:

   * If two characters have the same implementation-defined attributes,
     then their ordering by ‘char<’ is consistent with the numerical
     ordering by the predicate ‘<’ on their code attributes.

   * If two characters differ in any attribute, then they are not
     ‘char=’.

   * The total ordering is not necessarily the same as the total
     ordering on the integers produced by applying ‘char-int’ to the
     characters.

   * While alphabetic₁ standard characters of a given case must obey a
     partial ordering, they need not be contiguous; it is permissible
     for uppercase and lowercase characters to be interleaved.  Thus
     ‘(char<= #\a x #\z)’ is not a valid way of determining whether or
     not ‘x’ is a lowercase character.


Of the standard characters, those which are alphanumeric obey the
following partial ordering:

 A<B<C<D<E<F<G<H<I<J<K<L<M<N<O<P<Q<R<S<T<U<V<W<X<Y<Z
 a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<p<q<r<s<t<u<v<w<x<y<z
 0<1<2<3<4<5<6<7<8<9
 either 9<A or Z<0
 either 9<a or z<0

This implies that, for standard characters, alphabetic₁ ordering holds
within each case (uppercase and lowercase), and that the numeric
characters as a group are not interleaved with alphabetic characters.
However, the ordering or possible interleaving of uppercase characters
and lowercase characters is implementation-defined.


File: ansicl,  Node: Character Names,  Next: Treatment of Newline during Input and Output,  Prev: Ordering of Characters,  Up: Character Concepts

13.1.7 Character Names
----------------------

The following character names must be present in all conforming
implementations:

‘Newline’
     The character that represents the division between lines.  An
     implementation must translate between ‘#\Newline’, a
     single-character representation, and whatever external
     representation(s) may be used.

‘Space’
     The space or blank character.

The following names are semi-standard; if an implementation supports
them, they should be used for the described characters and no others.

‘Rubout’
     The rubout or delete character.

‘Page’
     The form-feed or page-separator character.

‘Tab’
     The tabulate character.

‘Backspace’
     The backspace character.

‘Return’
     The carriage return character.

‘Linefeed’
     The line-feed character.

In some implementations, one or more of these character names might
denote a standard character; for example, ‘#\Linefeed’ and ‘#\Newline’
might be the same character in some implementations.


File: ansicl,  Node: Treatment of Newline during Input and Output,  Next: Character Encodings,  Prev: Character Names,  Up: Character Concepts

13.1.8 Treatment of Newline during Input and Output
---------------------------------------------------

When the character ‘#\Newline’ is written to an output file, the
implementation must take the appropriate action to produce a line
division.  This might involve writing out a record or translating
‘#\Newline’ to a CR/LF sequence.  When reading, a corresponding reverse
transformation must take place.


File: ansicl,  Node: Character Encodings,  Next: Documentation of Implementation-Defined Scripts,  Prev: Treatment of Newline during Input and Output,  Up: Character Concepts

13.1.9 Character Encodings
--------------------------

A character is sometimes represented merely by its code, and sometimes
by another integer value which is composed from the code and all
implementation-defined attributes (in an implementation-defined way
that might vary between Lisp images even in the same implementation).
This integer, returned by the function ‘char-int’, is called the
character's "encoding."  There is no corresponding function from a
character's encoding back to the character, since its primary intended
uses include things like hashing where an inverse operation is not
really called for.


File: ansicl,  Node: Documentation of Implementation-Defined Scripts,  Prev: Character Encodings,  Up: Character Concepts

13.1.10 Documentation of Implementation-Defined Scripts
-------------------------------------------------------

An implementation must document the character scripts it supports. For
each character script supported, the documentation must describe at
least the following:

   * Character labels, glyphs, and descriptions.  Character labels must
     be uniquely named using only Latin capital letters A-Z, hyphen
     (-), and digits 0-9.

   * Reader canonicalization.  Any mechanisms by which ‘read’ treats
     different characters as equivalent must be documented.

   * The impact on ‘char-upcase’, ‘char-downcase’, and the
     case-sensitive format directives.  In particular, for each
     character with case, whether it is uppercase or lowercase, and
     which character is its equivalent in the opposite case.

   * The behavior of the case-insensitive functions ‘char-equal’,
     ‘char-not-equal’, ‘char-lessp’, ‘char-greaterp’,
     ‘char-not-greaterp’, and ‘char-not-lessp’.

   * The behavior of any character predicates; in particular, the
     effects of ‘alpha-char-p’, ‘lower-case-p’, ‘upper-case-p’,
     ‘both-case-p’, ‘graphic-char-p’, and ‘alphanumericp’.

   * The interaction with file I/O, in particular, the supported coded
     character sets (for example, ISO8859/1-1987) and external encoding
     schemes supported are documented.


File: ansicl,  Node: character (System Class),  Next: base-char,  Prev: Character Concepts,  Up: Characters

character (System Class)
========================

Class Precedence List:
......................

‘character’, ‘t’

Description:
............

A character is an object that represents a unitary token in an
aggregate quantity of text; see *note Section 13.1 (Character
Concepts): Character Concepts.

The types ‘base-char’ and ‘extended-char’ form an exhaustive partition
of the type ‘character’.

See Also:
.........

*note Section 13.1 (Character Concepts): Character Concepts, *note
Section 2.4.8.1 (Sharpsign Backslash): SharpsignBackslash, *note
Section 22.1.3.2 (Printing Characters): PrintingCharacters.


File: ansicl,  Node: base-char,  Next: standard-char,  Prev: character (System Class),  Up: Characters

base-char (Type)
================

Supertypes:
...........

‘base-char’, ‘character’, ‘t’

Description:
............

The type ‘base-char’ is defined as the upgraded array element type of
‘standard-char’.  An implementation can support additional subtypes of
type ‘character’ (besides the ones listed in this standard) that might
or might not be supertypes of type ‘base-char’.  In addition, an
implementation can define ‘base-char’ to be the same type as
‘character’.

Base characters are distinguished in the following respects:

  1. The type ‘standard-char’ is a subrepertoire of the type
     ‘base-char’.

  2. The selection of base characters that are not standard characters
     is implementation defined.

  3. Only objects of the type ‘base-char’ can be elements of a base
     string.

  4. No upper bound is specified for the number of characters in the
     ‘base-char’ repertoire; the size of that repertoire is
     implementation-defined.  The lower bound is 96, the number of
     standard characters.

Whether a character is a base character depends on the way that an
implementation represents strings, and not any other properties of the
implementation or the host operating system.  For example, one
implementation might encode all strings as characters having 16-bit
encodings, and another might have two kinds of strings: those with
characters having 8-bit encodings and those with characters having
16-bit encodings.  In the first implementation, the type ‘base-char’ is
equivalent to the type ‘character’: there is only one kind of string.
In the second implementation, the base characters might be those
characters that could be stored in a string of characters having 8-bit
encodings.  In such an implementation, the type ‘base-char’ is a proper
subtype of the type ‘character’.

The type ‘standard-char’ is a subtype of type ‘base-char’.


File: ansicl,  Node: standard-char,  Next: extended-char,  Prev: base-char,  Up: Characters

standard-char (Type)
====================

Supertypes:
...........

‘standard-char’, ‘base-char’, ‘character’, ‘t’

Description:
............

A fixed set of 96 characters required to be present in all conforming
implementations.  Standard characters are defined in *note Section
2.1.3 (Standard Characters): Standard Characters.

Any character that is not simple is not a standard character.

See Also:
.........

*note Section 2.1.3 (Standard Characters): Standard Characters.


File: ansicl,  Node: extended-char,  Next: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Prev: standard-char,  Up: Characters

extended-char (Type)
====================

Supertypes:
...........

‘extended-char’, ‘character’, ‘t’

Description:
............

The type ‘extended-char’ is equivalent to the type ‘(and character (not
base-char))’.

Notes:
......

The type ‘extended-char’ might have no elements₄ in implementations in
which all characters are of type ‘base-char’.


File: ansicl,  Node: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Next: character (Function),  Prev: extended-char,  Up: Characters

char=, char/=, char<, char>, char<=, char>=, char-equal, char-not-equal, char-lessp, char-greaterp, char-not-greaterp, char-not-lessp (Function)
================================================================================================================================================

Syntax:
.......

 -- Function: char= &rest characters+ → generalized-boolean

 -- Function: char/= &rest characters+ → generalized-boolean

 -- Function: char< &rest characters+ → generalized-boolean

 -- Function: char> &rest characters+ → generalized-boolean

 -- Function: char<= &rest characters+ → generalized-boolean

 -- Function: char>= &rest characters+ → generalized-boolean

 -- Function: char-equal &rest characters+ → generalized-boolean

 -- Function: char-not-equal &rest characters+ → generalized-boolean

 -- Function: char-lessp &rest characters+ → generalized-boolean

 -- Function: char-greaterp &rest characters+ → generalized-boolean

 -- Function: char-not-greaterp &rest characters+ → generalized-boolean

 -- Function: char-not-lessp &rest characters+ → generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These predicates compare characters.

‘char=’ returns true if all CHARACTERS are the same; otherwise, it
returns false.  If two CHARACTERS differ in any implementation-defined
attributes, then they are not ‘char=’.

‘char/=’ returns true if all CHARACTERS are different; otherwise, it
returns false.

‘char<’ returns true if the CHARACTERS are monotonically increasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char<’ is
consistent with the numerical ordering by the predicate ‘<’ on their
codes.

‘char>’ returns true if the CHARACTERS are monotonically decreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char>’ is
consistent with the numerical ordering by the predicate ‘>’ on their
codes.

‘char<=’ returns true if the CHARACTERS are monotonically nondecreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char<=’ is
consistent with the numerical ordering by the predicate ‘<=’ on their
codes.

‘char>=’ returns true if the CHARACTERS are monotonically nonincreasing;
otherwise, it returns false.  If two characters have identical
implementation-defined attributes, then their ordering by ‘char>=’ is
consistent with the numerical ordering by the predicate ‘>=’ on their
codes.

‘char-equal’, ‘char-not-equal’, ‘char-lessp’, ‘char-greaterp’,
‘char-not-greaterp’, and ‘char-not-lessp’ are similar to ‘char=’,
‘char/=’, ‘char<’, ‘char>’, ‘char<=’, ‘char>=’, respectively, except
that they ignore differences in case and might have an
implementation-defined behavior for non-simple characters.  For
example, an implementation might define that ‘char-equal’, etc. ignore
certain implementation-defined attributes.  The effect, if any, of each
implementation-defined attribute upon these functions must be specified
as part of the definition of that attribute.

Examples:
.........

 (char= #\d #\d) → true
 (char= #\A #\a) → false
 (char= #\d #\x) → false
 (char= #\d #\D) → false
 (char/= #\d #\d) → false
 (char/= #\d #\x) → true
 (char/= #\d #\D) → true
 (char= #\d #\d #\d #\d) → true
 (char/= #\d #\d #\d #\d) → false
 (char= #\d #\d #\x #\d) → false
 (char/= #\d #\d #\x #\d) → false
 (char= #\d #\y #\x #\c) → false
 (char/= #\d #\y #\x #\c) → true
 (char= #\d #\c #\d) → false
 (char/= #\d #\c #\d) → false
 (char< #\d #\x) → true
 (char<= #\d #\x) → true
 (char< #\d #\d) → false
 (char<= #\d #\d) → true
 (char< #\a #\e #\y #\z) → true
 (char<= #\a #\e #\y #\z) → true
 (char< #\a #\e #\e #\y) → false
 (char<= #\a #\e #\e #\y) → true
 (char> #\e #\d) → true
 (char>= #\e #\d) → true
 (char> #\d #\c #\b #\a) → true
 (char>= #\d #\c #\b #\a) → true
 (char> #\d #\d #\c #\a) → false
 (char>= #\d #\d #\c #\a) → true
 (char> #\e #\d #\b #\c #\a) → false
 (char>= #\e #\d #\b #\c #\a) → false
 (char> #\z #\A) → implementation-dependent
 (char> #\Z #\a) → implementation-dependent
 (char-equal #\A #\a) → true
 (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char-lessp)
→ (#\A #\a #\b #\B #\c #\C)
 (stable-sort (list #\b #\A #\B #\a #\c #\C) #'char<)
→ (#\A #\B #\C #\a #\b #\c) ;Implementation A
→ (#\a #\b #\c #\A #\B #\C) ;Implementation B
→ (#\a #\A #\b #\B #\c #\C) ;Implementation C
→ (#\A #\a #\B #\b #\C #\c) ;Implementation D
→ (#\A #\B #\a #\b #\C #\c) ;Implementation E

Exceptional Situations:
.......................

Should signal an error of type ‘program-error’ if at least one
CHARACTER is not supplied.

See Also:
.........

*note Section 2.1 (Character Syntax): Character Syntax, *note Section
13.1.10 (Documentation of Implementation-Defined Scripts):
Documentation of Implementation-Defined Scripts.

Notes:
......

If characters differ in their code attribute or any
implementation-defined attribute, they are considered to be different
by ‘char=’.

There is no requirement that ‘(eq c1 c2)’ be true merely because
‘(char= c1 c2)’ is true.  While ‘eq’ can distinguish two characters
that ‘char=’ does not, it is distinguishing them not as characters, but
in some sense on the basis of a lower level implementation
characteristic.  If ‘(eq c1 c2)’ is true, then ‘(char= c1 c2)’ is also
true.  ‘eql’ and ‘equal’ compare characters in the same way that
‘char=’ does.

The manner in which case is used by ‘char-equal’, ‘char-not-equal’,
‘char-lessp’, ‘char-greaterp’, ‘char-not-greaterp’, and ‘char-not-lessp’
implies an ordering for standard characters such that ‘A=a’, ‘B=b’, and
so on, up to ‘Z=z’, and furthermore either ‘9<A’ or ‘Z<0’.


File: ansicl,  Node: character (Function),  Next: characterp,  Prev: char=; char/=; char<; char>; char<=; char>=; char-equal; char-not-equal+,  Up: Characters

character (Function)
====================

Syntax:
.......

 -- Function: character character → denoted-character

Arguments and Values:
.....................

CHARACTER--a character designator.

DENOTED-CHARACTER--a character.

Description:
............

Returns the character denoted by the CHARACTER designator.

Examples:
.........

 (character #\a) → #\a
 (character "a") → #\a
 (character 'a) → #\A
 (character '\a) → #\a
 (character 65.) is an error.
 (character 'apple) is an error.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if OBJECT is not a
character designator.

See Also:
.........

*note coerce::

Notes:
......

 (character OBJECT) ≡ (coerce OBJECT 'character)


File: ansicl,  Node: characterp,  Next: alpha-char-p,  Prev: character (Function),  Up: Characters

characterp (Function)
=====================

Syntax:
.......

 -- Function: characterp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘character’; otherwise, returns false.

Examples:
.........

 (characterp #\a) → true
 (characterp 'a) → false
 (characterp "a") → false
 (characterp 65.) → false
 (characterp #\Newline) → true
 ;; This next example presupposes an implementation
 ;; in which #\Rubout is an implementation-defined character.
 (characterp #\Rubout) → true

See Also:
.........

*note character (Function):: (type and function), *note typep::

Notes:
......

 (characterp OBJECT) ≡ (typep OBJECT 'character)


File: ansicl,  Node: alpha-char-p,  Next: alphanumericp,  Prev: characterp,  Up: Characters

alpha-char-p (Function)
=======================

Syntax:
.......

 -- Function: alpha-char-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabetic₁ character; otherwise,
returns false.

Examples:
.........

 (alpha-char-p #\a) → true
 (alpha-char-p #\5) → false
 (alpha-char-p #\Newline) → false
 ;; This next example presupposes an implementation
 ;; in which #\α is a defined character.
 (alpha-char-p #\α) → implementation-dependent

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note alphanumericp::, *note Section 13.1.10 (Documentation of
Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: ansicl,  Node: alphanumericp,  Next: digit-char,  Prev: alpha-char-p,  Up: Characters

alphanumericp (Function)
========================

Syntax:
.......

 -- Function: alphanumericp character → generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is an alphabetic₁ character  or a  numeric
character; otherwise, returns false.

Examples:
.........

 (alphanumericp #\Z) → true
 (alphanumericp #\9) → true
 (alphanumericp #\Newline) → false
 (alphanumericp #\#) → false

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note alpha-char-p::, *note graphic-char-p::, *note digit-char-p::

Notes:
......

Alphanumeric characters are graphic as defined by ‘graphic-char-p’.
The alphanumeric characters are a subset of the graphic characters.
The standard characters ‘A’ through ‘Z’, ‘a’ through ‘z’, and ‘0’
through ‘9’ are alphanumeric characters.

 (alphanumericp x)
   ≡ (or (alpha-char-p x) (not (null (digit-char-p x))))


File: ansicl,  Node: digit-char,  Next: digit-char-p,  Prev: alphanumericp,  Up: Characters

digit-char (Function)
=====================

Syntax:
.......

 -- Function: digit-char weight &optional radix → char

Arguments and Values:
.....................

WEIGHT--a non-negative integer.

RADIX--a radix.  The default is ‘10’.

CHAR--a character or false.

Description:
............

If WEIGHT is less than RADIX, ‘digit-char’ returns a character which
has that WEIGHT when considered as a digit in the specified radix.  If
the resulting character is to be an alphabetic₁ character, it will be
an uppercase character.

If WEIGHT is greater than or equal to RADIX, ‘digit-char’ returns false.

Examples:
.........

 (digit-char 0) → #\0
 (digit-char 10 11) → #\A
 (digit-char 10 10) → false
 (digit-char 7) → #\7
 (digit-char 12) → false
 (digit-char 12 16) → #\C  ;not #\c
 (digit-char 6 2) → false
 (digit-char 1 2) → #\1

See Also:
.........

*note digit-char-p::, *note graphic-char-p::, *note Section 2.1
(Character Syntax): Character Syntax.

Notes:
......


File: ansicl,  Node: digit-char-p,  Next: graphic-char-p,  Prev: digit-char,  Up: Characters

digit-char-p (Function)
=======================

Syntax:
.......

 -- Function: digit-char-p char &optional radix → weight

Arguments and Values:
.....................

CHAR--a character.

RADIX--a radix.  The default is ‘10’.

WEIGHT--either a non-negative integer less than RADIX, or false.

Description:
............

Tests whether CHAR is a digit in the specified RADIX (i.e., with a
weight less than RADIX).  If it is a digit in that RADIX, its weight is
returned as an integer; otherwise ‘nil’ is returned.

Examples:
.........

 (digit-char-p #\5)    → 5
 (digit-char-p #\5 2)  → false
 (digit-char-p #\A)    → false
 (digit-char-p #\a)    → false
 (digit-char-p #\A 11) → 10
 (digit-char-p #\a 11) → 10
 (mapcar #'(lambda (radix)
             (map 'list #'(lambda (x) (digit-char-p x radix))
                  "059AaFGZ"))
         '(2 8 10 16 36))
 → ((0 NIL NIL NIL NIL NIL NIL NIL)
     (0 5 NIL NIL NIL NIL NIL NIL)
     (0 5 9 NIL NIL NIL NIL NIL)
     (0 5 9 10 10 15 NIL NIL)
     (0 5 9 10 10 15 16 35))

Affected By:
............

None.  (In particular, the results of this predicate are independent of
any special syntax which might have been enabled in the current
readtable.)

See Also:
.........

*note alphanumericp::

Notes:
......

Digits are graphic characters.


File: ansicl,  Node: graphic-char-p,  Next: standard-char-p,  Prev: digit-char-p,  Up: Characters

graphic-char-p (Function)
=========================

Syntax:
.......

 -- Function: graphic-char-p char → generalized-boolean

Arguments and Values:
.....................

CHAR--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is a graphic character; otherwise, returns
false.

Examples:
.........

 (graphic-char-p #\G) → true
 (graphic-char-p #\#) → true
 (graphic-char-p #\Space) → true
 (graphic-char-p #\Newline) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note read::, *note Section 2.1 (Character Syntax): Character Syntax,
*note Section 13.1.10 (Documentation of Implementation-Defined
Scripts): Documentation of Implementation-Defined Scripts.


File: ansicl,  Node: standard-char-p,  Next: char-upcase; char-downcase,  Prev: graphic-char-p,  Up: Characters

standard-char-p (Function)
==========================

Syntax:
.......

 -- Function: standard-char-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if CHARACTER is of type ‘standard-char’; otherwise,
returns false.

Examples:
.........

 (standard-char-p #\Space) → true
 (standard-char-p #\~) → true
 ;; This next example presupposes an implementation
 ;; in which #\Bell is a defined character.
 (standard-char-p #\Bell) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.


File: ansicl,  Node: char-upcase; char-downcase,  Next: upper-case-p; lower-case-p; both-case-p,  Prev: standard-char-p,  Up: Characters

char-upcase, char-downcase (Function)
=====================================

Syntax:
.......

 -- Function: char-upcase character → corresponding-character

 -- Function: char-downcase character → corresponding-character

Arguments and Values:
.....................

CHARACTER, CORRESPONDING-CHARACTER--a character.

Description:
............

If CHARACTER is a lowercase character, ‘char-upcase’ returns the
corresponding uppercase character.  Otherwise, ‘char-upcase’ just
returns the given CHARACTER.

If CHARACTER is an uppercase character, ‘char-downcase’ returns the
corresponding lowercase character.  Otherwise, ‘char-downcase’ just
returns the given CHARACTER.

The result only ever differs from CHARACTER in its code attribute; all
implementation-defined attributes are preserved.

Examples:
.........

 (char-upcase #\a) → #\A
 (char-upcase #\A) → #\A
 (char-downcase #\a) → #\a
 (char-downcase #\A) → #\a
 (char-upcase #\9) → #\9
 (char-downcase #\9) → #\9
 (char-upcase #\@) → #\@
 (char-downcase #\@) → #\@
 ;; Note that this next example might run for a very long time in
 ;; some implementations if CHAR-CODE-LIMIT happens to be very large
 ;; for that implementation.
 (dotimes (code char-code-limit)
   (let ((char (code-char code)))
     (when char
       (unless (cond ((upper-case-p char) (char= (char-upcase (char-downcase char)) char))
                     ((lower-case-p char) (char= (char-downcase (char-upcase char)) char))
                     (t (and (char= (char-upcase (char-downcase char)) char)
                             (char= (char-downcase (char-upcase char)) char))))
         (return char)))))
→ NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note upper-case-p::, *note alpha-char-p::, *note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.

Notes:
......

If the CORRESPONDING-CHAR is different than CHARACTER, then both the
CHARACTER and the CORRESPONDING-CHAR have case.

Since ‘char-equal’ ignores the case of the characters it compares, the
CORRESPONDING-CHARACTER is always the same as CHARACTER under
‘char-equal’.


File: ansicl,  Node: upper-case-p; lower-case-p; both-case-p,  Next: char-code,  Prev: char-upcase; char-downcase,  Up: Characters

upper-case-p, lower-case-p, both-case-p (Function)
==================================================

Syntax:
.......

 -- Function: upper-case-p character → generalized-boolean

 -- Function: lower-case-p character → generalized-boolean

 -- Function: both-case-p character → generalized-boolean

Arguments and Values:
.....................

CHARACTER--a character.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

These functions test the case of a given CHARACTER.

‘upper-case-p’ returns true if CHARACTER is an uppercase character;
otherwise, returns false.

‘lower-case-p’ returns true if CHARACTER is a lowercase character;
otherwise, returns false.

‘both-case-p’ returns true if CHARACTER is a character with case;
otherwise, returns false.

Examples:
.........

 (upper-case-p #\A) → true
 (upper-case-p #\a) → false
 (both-case-p #\a) → true
 (both-case-p #\5) → false
 (lower-case-p #\5) → false
 (upper-case-p #\5) → false
 ;; This next example presupposes an implementation
 ;; in which #\Bell is an implementation-defined character.
 (lower-case-p #\Bell) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note char-upcase::, *note char-downcase::, *note Section 13.1.4.3
(Characters With Case): CharactersWithCase, *note Section 13.1.10
(Documentation of Implementation-Defined Scripts): Documentation of
Implementation-Defined Scripts.


File: ansicl,  Node: char-code,  Next: char-int,  Prev: upper-case-p; lower-case-p; both-case-p,  Up: Characters

char-code (Function)
====================

Syntax:
.......

 -- Function: char-code character → code

Arguments and Values:
.....................

CHARACTER--a character.

CODE--a character code.

Description:
............

‘char-code’ returns the code attribute of CHARACTER.

Examples:
.........

;; An implementation using ASCII character encoding
;; might return these values:
(char-code #\$) → 36
(char-code #\a) → 97

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note char-code-limit::


File: ansicl,  Node: char-int,  Next: code-char,  Prev: char-code,  Up: Characters

char-int (Function)
===================

Syntax:
.......

 -- Function: char-int character → integer

Arguments and Values:
.....................

CHARACTER--a character.

INTEGER--a non-negative integer.

Description:
............

Returns a non-negative integer encoding the CHARACTER object.  The
manner in which the integer is computed is implementation-dependent.
In contrast to ‘sxhash’, the result is not guaranteed to be independent
of the particular Lisp image.

If CHARACTER has no implementation-defined attributes, the results of
‘char-int’ and ‘char-code’ are the same.

 (char= c1 c2) ≡ (= (char-int c1) (char-int c2))

for characters c1 and c2.

Examples:
.........

 (char-int #\A) → 65       ; implementation A
 (char-int #\A) → 577      ; implementation B
 (char-int #\A) → 262145   ; implementation C

See Also:
.........

*note char-code::


File: ansicl,  Node: code-char,  Next: char-code-limit,  Prev: char-int,  Up: Characters

code-char (Function)
====================

Syntax:
.......

 -- Function: code-char code → char-p

Arguments and Values:
.....................

CODE--a character code.

CHAR-P--a character or ‘nil’.

Description:
............

Returns a character with the code attribute given by CODE.  If no such
character exists and one cannot be created, ‘nil’ is returned.

Examples:
.........

(code-char 65.) → #\A  ;in an implementation using ASCII codes
(code-char (char-code #\Space)) → #\Space  ;in any implementation

Affected By:
............

The implementation's character encoding.

See Also:
.........

*note char-code::

Notes:
......


File: ansicl,  Node: char-code-limit,  Next: char-name,  Prev: code-char,  Up: Characters

char-code-limit (Constant Variable)
===================================

Constant Value:
...............

A non-negative integer, the exact magnitude of which is
implementation-dependent, but which is not less than ‘96’ (the number
of standard characters).

Description:
............

The upper exclusive bound on the value returned by the function
‘char-code’.

See Also:
.........

*note char-code::

Notes:
......

The value of ‘char-code-limit’ might be larger than the actual number
of characters supported by the implementation.


File: ansicl,  Node: char-name,  Next: name-char,  Prev: char-code-limit,  Up: Characters

char-name (Function)
====================

Syntax:
.......

 -- Function: char-name character → name

Arguments and Values:
.....................

CHARACTER--a character.

NAME--a string or ‘nil’.

Description:
............

Returns a string that is the name of the CHARACTER, or ‘nil’ if the
CHARACTER has no name.

All non-graphic characters are required to have names unless they have
some implementation-defined attribute which is not null.  Whether or
not other characters have names is implementation-dependent.

The standard characters <Newline> and <Space> have the respective names
‘"Newline"’ and ‘"Space"’.  The semi-standard characters <Tab>, <Page>,
<Rubout>, <Linefeed>, <Return>, and <Backspace>  (if they are supported
by the implementation) have the respective names ‘"Tab"’,  ‘"Page"’,
‘"Rubout"’,  ‘"Linefeed"’,  ‘"Return"’, and ‘"Backspace"’ (in the
indicated case, even though name lookup by "‘#\’" and by the function
‘name-char’ is not case sensitive).

Examples:
.........

 (char-name #\ ) → "Space"
 (char-name #\Space) → "Space"
 (char-name #\Page) → "Page"

 (char-name #\a)
→ NIL
or→ "LOWERCASE-a"
or→ "Small-A"
or→ "LA01"

 (char-name #\A)
→ NIL
or→ "UPPERCASE-A"
or→ "Capital-A"
or→ "LA02"

 ;; Even though its CHAR-NAME can vary, #\A prints as #\A
 (prin1-to-string (read-from-string (format nil "#\\~A" (or (char-name #\A) "A"))))
→ "#\\A"

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if CHARACTER is not a
character.

See Also:
.........

*note name-char::, *note Section 22.1.3.2 (Printing Characters):
PrintingCharacters.

Notes:
......

Non-graphic characters having names are written by the Lisp printer as
"‘#\’" followed by the their name; see *note Section 22.1.3.2 (Printing
Characters): PrintingCharacters.


File: ansicl,  Node: name-char,  Prev: char-name,  Up: Characters

name-char (Function)
====================

Syntax:
.......

 -- Function: name-char name → char-p

Arguments and Values:
.....................

NAME--a string designator.

CHAR-P--a character or ‘nil’.

Description:
............

Returns the character object whose name is NAME (as determined by
‘string-equal’--i.e., lookup is not case sensitive).  If such a
character does not exist, ‘nil’ is returned.

Examples:
.........

(name-char 'space) → #\Space
(name-char "space") → #\Space
(name-char "Space") → #\Space
(let ((x (char-name #\a)))
  (or (not x) (eql (name-char x) #\a))) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a string
designator.

See Also:
.........

*note char-name::


File: ansicl,  Node: Conses,  Next: Arrays,  Prev: Characters,  Up: Top

14 Conses
*********

* Menu:

* Cons Concepts::

Dictionary

* list (System Class)::
* null (System Class)::
* cons (System Class)::
* atom (Type)::
* cons (Function)::
* consp::
* atom (Function)::
* rplaca; rplacd::
* car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+::
* copy-tree::
* sublis; nsublis::
* subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not::
* tree-equal::
* copy-list::
* list; list*::
* list-length::
* listp::
* make-list::
* push::
* pop::
* first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+::
* nth::
* endp::
* null (Function)::
* nconc::
* append::
* revappend; nreconc::
* butlast; nbutlast::
* last::
* ldiff; tailp::
* nthcdr::
* rest::
* member; member-if; member-if-not::
* mapc; mapcar; mapcan; mapl; maplist; mapcon::
* acons::
* assoc; assoc-if; assoc-if-not::
* copy-alist::
* pairlis::
* rassoc; rassoc-if; rassoc-if-not::
* get-properties::
* getf::
* remf::
* intersection; nintersection::
* adjoin::
* pushnew::
* set-difference; nset-difference::
* set-exclusive-or; nset-exclusive-or::
* subsetp::
* union; nunion::


File: ansicl,  Node: Cons Concepts,  Next: list (System Class),  Up: Conses

14.1 Cons Concepts
==================

A "cons" is a compound data object having two components called the car
and the cdr.

car   cons     rplacd
cdr   rplaca   

Figure 14.1: Some defined names relating to conses.

Depending on context, a group of connected conses can be viewed in a
variety of different ways.  A variety of operations is provided to
support each of these various views.

* Menu:

* Conses as Trees::
* Conses as Lists::


File: ansicl,  Node: Conses as Trees,  Next: Conses as Lists,  Up: Cons Concepts

14.1.1 Conses as Trees
----------------------

A "tree" is a binary recursive data structure made up of conses and
atoms: the conses are themselves also trees (sometimes called
"subtrees" or "branches"), and the atoms are terminal nodes (sometimes
called "leaves").  Typically, the leaves represent data while the
branches establish some relationship among that data.

caaaar   caddar   cdar        nsubst
caaadr   cadddr   cddaar      nsubst-if
caaar    caddr    cddadr      nsubst-if-not
caadar   cadr     cddar       nthcdr
caaddr   cdaaar   cdddar      sublis
caadr    cdaadr   cddddr      subst
caar     cdaar    cdddr       subst-if
cadaar   cdadar   cddr        subst-if-not
cadadr   cdaddr   copy-tree   tree-equal
cadar    cdadr    nsublis     

Figure 14.2: Some defined names relating to trees.

14.1.1.1 General Restrictions on Parameters that must be Trees
..............................................................

Except as explicitly stated otherwise, for any standardized function
that takes a parameter that is required to be a tree, the consequences
are undefined if that tree is circular.


File: ansicl,  Node: Conses as Lists,  Prev: Conses as Trees,  Up: Cons Concepts

14.1.2 Conses as Lists
----------------------

A "list" is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link
in the chain or a terminating atom.

A "proper list" is a list terminated by the empty list.  The empty list
is a proper list, but is not a cons.

An "improper list" is a list that is not a proper list; that is, it is
a circular list or a dotted list.

A "dotted list" is a list that has a terminating atom that is not the
empty list.  A non-nil atom by itself is not considered to be a list of
any kind--not even a dotted list.

A "circular list" is a chain of conses that has no termination because
some cons in the chain is the cdr of a later cons.

append       last            nbutlast   rest
butlast      ldiff           nconc      revappend
copy-alist   list            ninth      second
copy-list    list*           nreconc    seventh
eighth       list-length     nth        sixth
endp         make-list       nthcdr     tailp
fifth        member          pop        tenth
first        member-if       push       third
fourth       member-if-not   pushnew    

Figure 14.3: Some defined names relating to lists.

14.1.2.1 Lists as Association Lists
...................................

An "association list" is a list of conses representing an association
of keys with values, where the car of each cons is the key and the cdr
is the value associated with that key.

acons   assoc-if       pairlis   rassoc-if
assoc   assoc-if-not   rassoc    rassoc-if-not

Figure 14.4: Some defined names related to assocation lists.

14.1.2.2 Lists as Sets
......................

Lists are sometimes viewed as sets by considering their elements
unordered and by assuming there is no duplication of elements.

adjoin          nset-difference     set-difference     union
intersection    nset-exclusive-or   set-exclusive-or   
nintersection   nunion              subsetp            

Figure 14.5: Some defined names related to sets.

14.1.2.3 General Restrictions on Parameters that must be Lists
..............................................................

Except as explicitly specified otherwise, any standardized function
that takes a parameter that is required to be a list should be prepared
to signal an error of type ‘type-error’ if the value received is a
dotted list.

Except as explicitly specified otherwise, for any standardized function
that takes a parameter that is required to be a list, the consequences
are undefined if that list is circular.


File: ansicl,  Node: list (System Class),  Next: null (System Class),  Prev: Cons Concepts,  Up: Conses

list (System Class)
===================

Class Precedence List:
......................

‘list’, ‘sequence’, ‘t’

Description:
............

A "list" is a chain of conses in which the car of each cons is an
element of the list, and the cdr of each cons is either the next link
in the chain or a terminating atom.

A "proper list" is a chain of conses terminated by the "empty list",
(), which is  itself a proper list.  A "dotted list" is a list which
has a terminating atom that is not the empty list.  A "circular list"
is a chain of conses that has no termination because some cons in the
chain is the cdr of a later cons.

Dotted lists and circular lists are also lists, but usually the
unqualified term "list" within this specification means proper list.
Nevertheless, the type ‘list’ unambiguously includes dotted lists and
circular lists.

For each element of a list there is a cons.  The empty list has no
elements and is not a cons.

The types ‘cons’ and ‘null’ form an exhaustive partition of the type
‘list’.

See Also:
.........

*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: ansicl,  Node: null (System Class),  Next: cons (System Class),  Prev: list (System Class),  Up: Conses

null (System Class)
===================

Class Precedence List:
......................

‘null’, ‘symbol’, ‘list’, ‘sequence’, ‘t’

Description:
............

The only object of type ‘null’ is ‘nil’, which represents the empty
list and can also be notated ().

See Also:
.........

*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *note
Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.3 (Printing Symbols): PrintingSymbols.


File: ansicl,  Node: cons (System Class),  Next: atom (Type),  Prev: null (System Class),  Up: Conses

cons (System Class)
===================

Class Precedence List:
......................

‘cons’, ‘list’, ‘sequence’, ‘t’

Description:
............

A cons is a compound object having two components, called the car and
cdr. These form a dotted pair.  Each component can be any object.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(cons [car-typespec [cdr-typespec]])

Compound Type Specifier Arguments:
..................................

CAR-TYPESPEC--a type specifier, or the symbol *.  The default is the
symbol *.

CDR-TYPESPEC--a type specifier, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This denotes the set of conses whose car is constrained to be of type
CAR-TYPESPEC and whose cdr is constrained to be of type CDR-TYPESPEC.
(If either CAR-TYPESPEC or CDR-TYPESPEC is *, it is as if the type ‘t’
had been denoted.)

See Also:
.........

*note Section 2.4.1 (Left-Parenthesis): Left-Parenthesis, *note Section
22.1.3.5 (Printing Lists and Conses): PrintingListsAndConses.


File: ansicl,  Node: atom (Type),  Next: cons (Function),  Prev: cons (System Class),  Up: Conses

atom (Type)
===========

Supertypes:
...........

‘atom’, ‘t’

Description:
............

It is equivalent to ‘(not cons)’.


File: ansicl,  Node: cons (Function),  Next: consp,  Prev: atom (Type),  Up: Conses

cons (Function)
===============

Syntax:
.......

 -- Function: cons object-1 object-2 → cons

Arguments and Values:
.....................

OBJECT-1--an object.

OBJECT-2--an object.

CONS--a cons.

Description:
............

Creates a fresh cons, the car of which is OBJECT-1 and the cdr of which
is OBJECT-2.

Examples:
.........

 (cons 1 2) → (1 . 2)
 (cons 1 nil) → (1)
 (cons nil 2) → (NIL . 2)
 (cons nil nil) → (NIL)
 (cons 1 (cons 2 (cons 3 (cons 4 nil)))) → (1 2 3 4)
 (cons 'a 'b) → (A . B)
 (cons 'a (cons 'b (cons 'c '()))) → (A B C)
 (cons 'a '(b c d)) → (A B C D)

See Also:
.........

*note list::

Notes:
......

If OBJECT-2 is a list, ‘cons’ can be thought of as producing a new list
which is like it but has OBJECT-1 prepended.


File: ansicl,  Node: consp,  Next: atom (Function),  Prev: cons (Function),  Up: Conses

consp (Function)
================

Syntax:
.......

 -- Function: consp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘cons’; otherwise, returns false.

Examples:
.........

 (consp nil) → false
 (consp (cons 1 2)) → true

The empty list is not a cons, so

 (consp '()) ≡ (consp 'nil) → false

See Also:
.........

*note listp::

Notes:
......

 (consp OBJECT) ≡ (typep OBJECT 'cons) ≡ (not (typep OBJECT 'atom)) ≡ (typep OBJECT '(not atom))


File: ansicl,  Node: atom (Function),  Next: rplaca; rplacd,  Prev: consp,  Up: Conses

atom (Function)
===============

Syntax:
.......

 -- Function: atom object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘atom’; otherwise, returns false.

Examples:
.........

 (atom 'sss) → true
 (atom (cons 1 2)) → false
 (atom nil) → true
 (atom '()) → true
 (atom 3) → true

Notes:
......

 (atom OBJECT) ≡ (typep OBJECT 'atom) ≡ (not (consp OBJECT))
 ≡ (not (typep OBJECT 'cons)) ≡ (typep OBJECT '(not cons))


File: ansicl,  Node: rplaca; rplacd,  Next: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Prev: atom (Function),  Up: Conses

rplaca, rplacd (Function)
=========================

Syntax:
.......

 -- Function: rplaca cons object → cons

 -- Function: rplacd cons object → cons

Pronunciation:
..............

‘rplaca’: [ˌrēˈplakə] or [ˌrəˈplakə]

‘rplacd’: [ˌrēˈplakdə] or [ˌrəˈplakdə] or [ˌrēˈplakdē] or [ˌrəˈplakdē]

Arguments and Values:
.....................

CONS--a cons.

OBJECT--an object.

Description:
............

‘rplaca’ replaces the car of the CONS with OBJECT.

‘rplacd’ replaces the cdr of the CONS with OBJECT.

Examples:
.........

 (defparameter *some-list* (list* 'one 'two 'three 'four)) → *some-list*
 *some-list* → (ONE TWO THREE . FOUR)
 (rplaca *some-list* 'uno) → (UNO TWO THREE . FOUR)
 *some-list* → (UNO TWO THREE . FOUR)
 (rplacd (last *some-list*) (list 'IV)) → (THREE IV)
 *some-list* → (UNO TWO THREE IV)

Side Effects:
.............

The CONS is modified.

Should signal an error of type ‘type-error’ if CONS is not a cons.


File: ansicl,  Node: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Next: copy-tree,  Prev: rplaca; rplacd,  Up: Conses

car, cdr, caar, cadr, cdar, cddr, caaar, caadr, cadar, caddr, cdaar, cdadr, cddar, cdddr, caaaar, caaadr, caadar, caaddr, cadaar, cadadr, caddar, cadddr, cdaaar, cdaadr, cdadar, cdaddr, cddaar, cddadr, cdddar, cddddr (Accessor)
===================================================================================================================================================================================================================================

Syntax:
.......

car x → object  |  (setf (x object) new-object)
cdr x → object  |  (setf (x object) new-object)
caar x → object  |  (setf (x object) new-object)
cadr x → object  |  (setf (x object) new-object)
cdar x → object  |  (setf (x object) new-object)
cddr x → object  |  (setf (x object) new-object)
caaar x → object  |  (setf (x object) new-object)
caadr x → object  |  (setf (x object) new-object)
cadar x → object  |  (setf (x object) new-object)
caddr x → object  |  (setf (x object) new-object)
cdaar x → object  |  (setf (x object) new-object)
cdadr x → object  |  (setf (x object) new-object)
cddar x → object  |  (setf (x object) new-object)
cdddr x → object  |  (setf (x object) new-object)
caaaar x → object  |  (setf (x object) new-object)
caaadr x → object  |  (setf (x object) new-object)
caadar x → object  |  (setf (x object) new-object)
caaddr x → object  |  (setf (x object) new-object)
cadaar x → object  |  (setf (x object) new-object)
cadadr x → object  |  (setf (x object) new-object)
caddar x → object  |  (setf (x object) new-object)
cadddr x → object  |  (setf (x object) new-object)
cdaaar x → object  |  (setf (x object) new-object)
cdaadr x → object  |  (setf (x object) new-object)
cdadar x → object  |  (setf (x object) new-object)
cdaddr x → object  |  (setf (x object) new-object)
cddaar x → object  |  (setf (x object) new-object)
cddadr x → object  |  (setf (x object) new-object)
cdddar x → object  |  (setf (x object) new-object)
cddddr x → object  |  (setf (x object) new-object)
Pronunciation:
..............

‘cadr’: [ˈkaˌdə r]

‘caddr’: [ˈkadə ˌdə r] or [ˈkaˌd.udə r]

‘cdr’: [ˈk.uˌdə r]

‘cddr’: [ˈk.udə ˌdə r] or [ˈkəˌd.udə r]

Arguments and Values:
.....................

X--a list.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

If X is a cons, ‘car’ returns the car of that cons.  If X is ‘nil’,
‘car’ returns ‘nil’.

If X is a cons, ‘cdr’ returns the cdr of that cons.  If X is ‘nil’,
‘cdr’ returns ‘nil’.

Functions are provided which perform compositions of up to four ‘car’
and ‘cdr’ operations.  Their names consist of a ‘C’, followed by two,
three, or four occurrences of ‘A’ or ‘D’, and finally an ‘R’.  The
series of ‘A’'s and ‘D’'s in each function's name is chosen to identify
the series of ‘car’ and ‘cdr’ operations that is performed by the
function.  The order in which the ‘A’'s and ‘D’'s appear is the inverse
of the order in which the corresponding operations are performed.  The
next figure  defines the relationships precisely.

This place ...   Is equivalent to this place ...
--------------------------------------------------- 
‘(caar X)’       ‘(car (car X))’
‘(cadr X)’       ‘(car (cdr X))’
‘(cdar X)’       ‘(cdr (car X))’
‘(cddr X)’       ‘(cdr (cdr X))’
‘(caaar X)’      ‘(car (car (car X)))’
‘(caadr X)’      ‘(car (car (cdr X)))’
‘(cadar X)’      ‘(car (cdr (car X)))’
‘(caddr X)’      ‘(car (cdr (cdr X)))’
‘(cdaar X)’      ‘(cdr (car (car X)))’
‘(cdadr X)’      ‘(cdr (car (cdr X)))’
‘(cddar X)’      ‘(cdr (cdr (car X)))’
‘(cdddr X)’      ‘(cdr (cdr (cdr X)))’
‘(caaaar X)’     ‘(car (car (car (car X))))’
‘(caaadr X)’     ‘(car (car (car (cdr X))))’
‘(caadar X)’     ‘(car (car (cdr (car X))))’
‘(caaddr X)’     ‘(car (car (cdr (cdr X))))’
‘(cadaar X)’     ‘(car (cdr (car (car X))))’
‘(cadadr X)’     ‘(car (cdr (car (cdr X))))’
‘(caddar X)’     ‘(car (cdr (cdr (car X))))’
‘(cadddr X)’     ‘(car (cdr (cdr (cdr X))))’
‘(cdaaar X)’     ‘(cdr (car (car (car X))))’
‘(cdaadr X)’     ‘(cdr (car (car (cdr X))))’
‘(cdadar X)’     ‘(cdr (car (cdr (car X))))’
‘(cdaddr X)’     ‘(cdr (car (cdr (cdr X))))’
‘(cddaar X)’     ‘(cdr (cdr (car (car X))))’
‘(cddadr X)’     ‘(cdr (cdr (car (cdr X))))’
‘(cdddar X)’     ‘(cdr (cdr (cdr (car X))))’
‘(cddddr X)’     ‘(cdr (cdr (cdr (cdr X))))’

Figure 14.6: CAR and CDR variants

‘setf’ can also be used with any of these functions to change an
existing component of X, but ‘setf’ will not make new components.  So,
for example, the car of a cons can be assigned with ‘setf’ of ‘car’,
but the car of ‘nil’ cannot be assigned with ‘setf’ of ‘car’.
Similarly, the car of the car of a cons whose car is a cons can be
assigned with ‘setf’ of ‘caar’, but neither ‘nil’ nor a cons whose car
is ‘nil’ can be assigned with ‘setf’ of ‘caar’.

The argument X is permitted to be a dotted list or a circular list.

Examples:
.........

 (car nil) → NIL
 (cdr '(1 . 2)) → 2
 (cdr '(1 2)) → (2)
 (cadr '(1 2)) → 2
 (car '(a b c)) → A
 (cdr '(a b c)) → (B C)

Exceptional Situations:
.......................

The functions ‘car’ and ‘cdr’ should signal ‘type-error’ if they
receive an argument which is not a list.  The other functions (‘caar’,
‘cadr’, ... ‘cddddr’) should behave for the purpose of error checking
as if defined by appropriate calls to ‘car’ and ‘cdr’.

See Also:
.........

*note rplaca::, *note first::, *note rest::

Notes:
......

The car of a cons can also be altered by using ‘rplaca’, and the cdr of
a cons can be altered by using ‘rplacd’.

(car x)    ≡ (first x)
(cadr x)   ≡ (second x) ≡ (car (cdr x))
(caddr x)  ≡ (third x)  ≡ (car (cdr (cdr x)))
(cadddr x) ≡ (fourth x) ≡ (car (cdr (cdr (cdr x))))


File: ansicl,  Node: copy-tree,  Next: sublis; nsublis,  Prev: car; cdr; caar; cadr; cdar; cddr; caaar; caadr; cadar; caddr; cdaar; cd+,  Up: Conses

copy-tree (Function)
====================

Syntax:
.......

 -- Function: copy-tree tree → new-tree

Arguments and Values:
.....................

TREE--a tree.

NEW-TREE--a tree.

Description:
............

Creates a copy of a tree of conses.

If TREE is not a cons, it is returned; otherwise, the result is a new
cons of the results of calling ‘copy-tree’ on the car and cdr of TREE.
In other words, all conses in the tree represented by TREE are copied
recursively, stopping only when non-conses are encountered.

‘copy-tree’ does not preserve circularities and the sharing of
substructure.

Examples:
.........

 (setq object (list (cons 1 "one")
                    (cons 2 (list 'a 'b 'c))))
→ ((1 . "one") (2 A B C))
 (setq object-too object) → ((1 . "one") (2 A B C))
 (setq copy-as-list (copy-list object))
 (setq copy-as-alist (copy-alist object))
 (setq copy-as-tree (copy-tree object))
 (eq object object-too) → true
 (eq copy-as-tree object) → false
 (eql copy-as-tree object) → false
 (equal copy-as-tree object) → true
 (setf (first (cdr (second object))) "a"
       (car (second object)) "two"
       (car object) '(one . 1)) → (ONE . 1)
 object → ((ONE . 1) ("two" "a" B C))
 object-too → ((ONE . 1) ("two" "a" B C))
 copy-as-list → ((1 . "one") ("two" "a" B C))
 copy-as-alist → ((1 . "one") (2 "a" B C))
 copy-as-tree → ((1 . "one") (2 A B C))

See Also:
.........

*note tree-equal::


File: ansicl,  Node: sublis; nsublis,  Next: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Prev: copy-tree,  Up: Conses

sublis, nsublis (Function)
==========================

Syntax:
.......

 -- Function: sublis alist tree &key key test test-not → new-tree

 -- Function: nsublis alist tree &key key test test-not → new-tree

Arguments and Values:
.....................

ALIST--an association list.

TREE--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

NEW-TREE--a tree.

Description:
............

‘sublis’ makes substitutions for objects in TREE (a structure of
conses).  ‘nsublis’ is like ‘sublis’ but destructively modifies the
relevant parts of the TREE.

‘sublis’ looks at all subtrees and leaves of TREE; if a subtree or leaf
appears as a key in ALIST (that is, the key and the subtree or leaf
satisfy the test), it is replaced by the object with which that key is
associated.  This operation is non-destructive.  In effect, ‘sublis’ can
perform several ‘subst’ operations simultaneously.

If ‘sublis’ succeeds, a new copy of TREE is returned in which each
occurrence of such a subtree or leaf is replaced by the object with
which it is associated.   If no changes are made, the original tree is
returned.  The original TREE is left unchanged, but the result tree may
share cells with it.

‘nsublis’ is permitted to modify TREE but otherwise returns the same
values as ‘sublis’.

Examples:
.........

 (sublis '((x . 100) (z . zprime))
         '(plus x (minus g z x p) 4 . x))
→ (PLUS 100 (MINUS G ZPRIME 100 P) 4 . 100)
 (sublis '(((+ x y) . (- x y)) ((- x y) . (+ x y)))
         '(* (/ (+ x y) (+ x p)) (- x y))
         :test #'equal)
→ (* (/ (- X Y) (+ X P)) (+ X Y))
 (setq tree1 '(1 (1 2) ((1 2 3)) (((1 2 3 4)))))
→ (1 (1 2) ((1 2 3)) (((1 2 3 4))))
 (sublis '((3 . "three")) tree1)
→ (1 (1 2) ((1 2 "three")) (((1 2 "three" 4))))
 (sublis '((t . "string"))
          (sublis '((1 . "") (4 . 44)) tree1)
          :key #'stringp)
→ ("string" ("string" 2) (("string" 2 3)) ((("string" 2 3 44))))
 tree1 → (1 (1 2) ((1 2 3)) (((1 2 3 4))))
 (setq tree2 '("one" ("one" "two") (("one" "Two" "three"))))
→ ("one" ("one" "two") (("one" "Two" "three")))
 (sublis '(("two" . 2)) tree2)
→ ("one" ("one" "two") (("one" "Two" "three")))
 tree2 → ("one" ("one" "two") (("one" "Two" "three")))
 (sublis '(("two" . 2)) tree2 :test 'equal)
→ ("one" ("one" 2) (("one" "Two" "three")))

 (nsublis '((t . 'temp))
           tree1
           :key #'(lambda (x) (or (atom x) (< (list-length x) 3))))
→ ((QUOTE TEMP) (QUOTE TEMP) QUOTE TEMP)

Side Effects:
.............

‘nsublis’ modifies TREE.

See Also:
.........

*note subst::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Because the side-effecting variants (e.g., ‘nsublis’) potentially
change the path that is being traversed, their effects in the presence
of shared or circular structure structure may vary in surprising ways
when compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

 (defun test-it (fn)
   (let* ((shared-piece (list 'a 'b))
          (data (list shared-piece shared-piece)))
     (funcall fn '((a . b) (b . a)) data)))
 (test-it #'sublis) → ((B A) (B A))
 (test-it #'nsublis) → ((A B) (A B))


File: ansicl,  Node: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Next: tree-equal,  Prev: sublis; nsublis,  Up: Conses

subst, subst-if, subst-if-not, nsubst, nsubst-if, nsubst-if-not (Function)
==========================================================================

Syntax:
.......

 -- Function: subst new old tree &key key test test-not → new-tree

 -- Function: subst-if new predicate tree &key key → new-tree

 -- Function: subst-if-not new predicate tree &key key → new-tree

 -- Function: nsubst new old tree &key key test test-not → new-tree

 -- Function: nsubst-if new predicate tree &key key → new-tree

 -- Function: nsubst-if-not new predicate tree &key key → new-tree

Arguments and Values:
.....................

NEW--an object.

OLD--an object.

PREDICATE--a symbol that names a function, or a function of one argument
that returns a generalized boolean value.

TREE--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

NEW-TREE--a tree.

Description:
............

‘subst’, ‘subst-if’, and ‘subst-if-not’ perform substitution operations
on TREE.  Each function searches TREE for occurrences of a particular
OLD item of an element or subexpression that satisfies the test.

‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ are like ‘subst’,
‘subst-if’, and ‘subst-if-not’ respectively, except that the original
TREE is  modified.

‘subst’ makes a copy of TREE, substituting NEW for every subtree or
leaf of TREE (whether the subtree or leaf is a car or a cdr of its
parent) such that OLD and the subtree or leaf satisfy the test.

‘nsubst’ is a destructive version of ‘subst’.  The list structure of
TREE is altered by destructively replacing with NEW each leaf of the
TREE such that OLD and the leaf satisfy the test.

For ‘subst’, ‘subst-if’, and ‘subst-if-not’, if the functions succeed,
a new copy of the tree is returned in which each  occurrence of such an
element is replaced by the NEW element or subexpression.  If no changes
are made, the original TREE may be returned.  The original TREE is left
unchanged, but the result tree may share storage with it.

For ‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ the original TREE is
modified and returned as the function result, but the result may not be
‘eq’ to TREE.

Examples:
.........

 (setq tree1 '(1 (1 2) (1 2 3) (1 2 3 4))) → (1 (1 2) (1 2 3) (1 2 3 4))
 (subst "two" 2 tree1) → (1 (1 "two") (1 "two" 3) (1 "two" 3 4))
 (subst "five" 5 tree1) → (1 (1 2) (1 2 3) (1 2 3 4))
 (eq tree1 (subst "five" 5 tree1)) → implementation-dependent
 (subst 'tempest 'hurricane
        '(shakespeare wrote (the hurricane)))
→ (SHAKESPEARE WROTE (THE TEMPEST))
 (subst 'foo 'nil '(shakespeare wrote (twelfth night)))
→ (SHAKESPEARE WROTE (TWELFTH NIGHT . FOO) . FOO)
 (subst '(a . cons) '(old . pair)
        '((old . spice) ((old . shoes) old . pair) (old . pair))
        :test #'equal)
→ ((OLD . SPICE) ((OLD . SHOES) A . CONS) (A . CONS))

 (subst-if 5 #'listp tree1) → 5
 (subst-if-not '(x) #'consp tree1)
→ (1 X)

 tree1 → (1 (1 2) (1 2 3) (1 2 3 4))
 (nsubst 'x 3 tree1 :key #'(lambda (y) (and (listp y) (third y))))
→ (1 (1 2) X X)
 tree1 → (1 (1 2) X X)

Side Effects:
.............

‘nsubst’, ‘nsubst-if’, and ‘nsubst-if-not’ might alter the tree
structure of TREE.

See Also:
.........

*note substitute::, *note nsubstitute::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The functions ‘subst-if-not’ and ‘nsubst-if-not’ are deprecated.

One possible definition of ‘subst’:

 (defun subst (old new tree &rest x &key test test-not key)
   (cond ((satisfies-the-test old tree :test test
                              :test-not test-not :key key)
          new)
         ((atom tree) tree)
         (t (let ((a (apply #'subst old new (car tree) x))
                  (d (apply #'subst old new (cdr tree) x)))
              (if (and (eql a (car tree))
                       (eql d (cdr tree)))
                  tree
                  (cons a d))))))


File: ansicl,  Node: tree-equal,  Next: copy-list,  Prev: subst; subst-if; subst-if-not; nsubst; nsubst-if; nsubst-if-not,  Up: Conses

tree-equal (Function)
=====================

Syntax:
.......

 -- Function: tree-equal tree-1 tree-2 &key test test-not →
          generalized-boolean

Arguments and Values:
.....................

TREE-1--a tree.

TREE-2--a tree.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘tree-equal’ tests whether two trees are of the same shape and have the
same leaves.  ‘tree-equal’ returns true if TREE-1 and TREE-2  are both
atoms and satisfy the test, or if they are both conses and the car of
TREE-1 is ‘tree-equal’ to the car of TREE-2 and the cdr of TREE-1 is
‘tree-equal’ to the cdr of TREE-2.  Otherwise, ‘tree-equal’ returns
false.

‘tree-equal’ recursively compares conses but not any other objects that
have components.

The first argument to the :test or :test-not function is TREE-1 or a
car or cdr of TREE-1; the second argument is TREE-2 or a car or cdr of
TREE-2.

Examples:
.........

 (setq tree1 '(1 (1 2))
       tree2 '(1 (1 2))) → (1 (1 2))
 (tree-equal tree1 tree2) → true
 (eql tree1 tree2) → false
 (setq tree1 '('a ('b 'c))
       tree2 '('a ('b 'c))) → ('a ('b 'c))
→ ((QUOTE A) ((QUOTE B) (QUOTE C)))
 (tree-equal tree1 tree2 :test 'eq) → true

Exceptional Situations:
.......................

The consequences are undefined if both TREE-1 and TREE-2 are circular.

See Also:
.........

*note equal::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: copy-list,  Next: list; list*,  Prev: tree-equal,  Up: Conses

copy-list (Function)
====================

Syntax:
.......

 -- Function: copy-list list → copy

Arguments and Values:
.....................

LIST--a proper list or a dotted list.

COPY--a list.

Description:
............

Returns a copy of LIST.  If LIST is a dotted list, the resulting list
will also be a dotted list.

Only the list structure of LIST is copied; the elements of the
resulting list are the same as the corresponding elements of the given
LIST.

Examples:
.........

 (setq lst (list 1 (list 2 3))) → (1 (2 3))
 (setq slst lst) → (1 (2 3))
 (setq clst (copy-list lst)) → (1 (2 3))
 (eq slst lst) → true
 (eq clst lst) → false
 (equal clst lst) → true
 (rplaca lst "one") → ("one" (2 3))
 slst → ("one" (2 3))
 clst → (1 (2 3))
 (setf (caadr lst) "two") → "two"
 lst → ("one" ("two" 3))
 slst → ("one" ("two" 3))
 clst → (1 ("two" 3))

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.

See Also:
.........

*note copy-alist::, *note copy-seq::, *note copy-tree::

Notes:
......

The copy created is ‘equal’ to LIST, but not ‘eq’.


File: ansicl,  Node: list; list*,  Next: list-length,  Prev: copy-list,  Up: Conses

list, list* (Function)
======================

Syntax:
.......

 -- Function: list &rest objects → list

 -- Function: list* &rest objects+ → result

Arguments and Values:
.....................

OBJECT--an object.

LIST--a list.

RESULT--an object.

Description:
............

‘list’ returns a list containing the supplied OBJECTS.

‘list*’ is like ‘list’ except that the last argument to ‘list’ becomes
the car of the last cons constructed, while the last argument to
‘list*’ becomes the cdr of the last cons constructed.  Hence, any given
call to ‘list*’ always produces one fewer conses than a call to ‘list’
with the same number of arguments.

If the last argument to ‘list*’ is a list, the effect is to construct a
new list which is similar, but which has additional elements added to
the front corresponding to the preceding arguments of ‘list*’.

If ‘list*’ receives only one OBJECT, that OBJECT is returned,
regardless of whether or not it is a list.

Examples:
.........

 (list 1) → (1)
 (list* 1) → 1
 (setq a 1) → 1
 (list a 2) → (1 2)
 '(a 2) → (A 2)
 (list 'a 2) → (A 2)
 (list* a 2) → (1 . 2)
 (list) → NIL ;i.e., ()
 (setq a '(1 2)) → (1 2)
 (eq a (list* a)) → true
 (list 3 4 'a (car '(b . c)) (+ 6 -2)) → (3 4 A B 4)
 (list* 'a 'b 'c 'd) ≡ (cons 'a (cons 'b (cons 'c 'd))) → (A B C . D)
 (list* 'a 'b 'c '(d e f)) → (A B C D E F)

See Also:
.........

*note cons (Function)::

Notes:
......

 (list* X) ≡ X


File: ansicl,  Node: list-length,  Next: listp,  Prev: list; list*,  Up: Conses

list-length (Function)
======================

Syntax:
.......

 -- Function: list-length list → length

Arguments and Values:
.....................

LIST--a proper list or a circular list.

LENGTH--a non-negative integer, or ‘nil’.

Description:
............

Returns the length of LIST if LIST is a proper list.  Returns ‘nil’ if
LIST is a circular list.

Examples:
.........

 (list-length '(a b c d)) → 4
 (list-length '(a (b c) d)) → 3
 (list-length '()) → 0
 (list-length nil) → 0
 (defun circular-list (&rest elements)
   (let ((cycle (copy-list elements)))
     (nconc cycle cycle)))
 (list-length (circular-list 'a 'b)) → NIL
 (list-length (circular-list 'a)) → NIL
 (list-length (circular-list)) → 0

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a proper
list or a circular list.

See Also:
.........

*note length::

Notes:
......

‘list-length’ could be implemented as follows:

 (defun list-length (x)
   (do ((n 0 (+ n 2))           ;Counter.
        (fast x (cddr fast))    ;Fast pointer: leaps by 2.
        (slow x (cdr slow)))    ;Slow pointer: leaps by 1.
       (nil)
     ;; If fast pointer hits the end, return the count.
     (when (endp fast) (return n))
     (when (endp (cdr fast)) (return (+ n 1)))
     ;; If fast pointer eventually equals slow pointer,
     ;;  then we must be stuck in a circular list.
     ;; (A deeper property is the converse: if we are
     ;;  stuck in a circular list, then eventually the
     ;;  fast pointer will equal the slow pointer.
     ;;  That fact justifies this implementation.)
     (when (and (eq fast slow) (> n 0)) (return nil))))


File: ansicl,  Node: listp,  Next: make-list,  Prev: list-length,  Up: Conses

listp (Function)
================

Syntax:
.......

 -- Function: listp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘list’; otherwise, returns false.

Examples:
.........

 (listp nil) → true
 (listp (cons 1 2)) → true
 (listp (make-array 6)) → false
 (listp t) → false

See Also:
.........

*note consp::

Notes:
......

If OBJECT is a cons, ‘listp’ does not check whether OBJECT is a proper
list; it returns true for any kind of list.

 (listp OBJECT) ≡ (typep OBJECT 'list) ≡ (typep OBJECT '(or cons null))


File: ansicl,  Node: make-list,  Next: push,  Prev: listp,  Up: Conses

make-list (Function)
====================

Syntax:
.......

 -- Function: make-list size &key initial-element → list

Arguments and Values:
.....................

SIZE--a non-negative integer.

INITIAL-ELEMENT--an object.  The default is ‘nil’.

LIST--a list.

Description:
............

Returns a list of LENGTH given by size, each of the elements of which
is INITIAL-ELEMENT.

Examples:
.........

 (make-list 5) → (NIL NIL NIL NIL NIL)
 (make-list 3 :initial-element 'rah) → (RAH RAH RAH)
 (make-list 2 :initial-element '(1 2 3)) → ((1 2 3) (1 2 3))
 (make-list 0) → NIL ;i.e., ()
 (make-list 0 :initial-element 'new-element) → NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SIZE is not a
non-negative integer.

See Also:
.........

*note cons (Function)::, *note list::


File: ansicl,  Node: push,  Next: pop,  Prev: make-list,  Up: Conses

push (Macro)
============

Syntax:
.......

 -- Macro: push item place → new-place-value

Arguments and Values:
.....................

ITEM--an object.

PLACE--a place, the value of which may be any object.

NEW-PLACE-VALUE--a list (the new value of PLACE).

Description:
............

‘push’ prepends ITEM to the list that is stored in PLACE, stores the
resulting list in PLACE, and returns the list.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq llst '(nil)) → (NIL)
 (push 1 (car llst)) → (1)
 llst → ((1))
 (push 1 (car llst)) → (1 1)
 llst → ((1 1))
 (setq x '(a (b c) d)) → (A (B C) D)
 (push 5 (cadr x)) → (5 B C)
 x → (A (5 B C) D)

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*note pop::, *note pushnew::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ‘(push item place)’ is equivalent to

 (setf place (cons item place))

except that the subforms of PLACE are evaluated only once, and ITEM is
evaluated before PLACE.


File: ansicl,  Node: pop,  Next: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Prev: push,  Up: Conses

pop (Macro)
===========

Syntax:
.......

 -- Macro: pop place → element

Arguments and Values:
.....................

PLACE--a place, the value of which is a list (possibly, but
necessarily, a dotted list or circular list).

ELEMENT--an object (the car of the contents of PLACE).

Description:
............

‘pop’ reads the value of PLACE, remembers the car of the list which was
retrieved, writes the cdr of the list back into the PLACE, and finally
yields the car of the originally retrieved list.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq stack '(a b c)) → (A B C)
 (pop stack) → A
 stack → (B C)
 (setq llst '((1 2 3 4))) → ((1 2 3 4))
 (pop (car llst)) → 1
 llst → ((2 3 4))

Side Effects:
.............

The contents of PLACE are modified.

See Also:
.........

*note push::, *note pushnew::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of ‘(pop PLACE)’ is roughly equivalent to

 (prog1 (car PLACE) (setf PLACE (cdr PLACE)))

except that the latter would evaluate any subforms of PLACE three
times, while ‘pop’ evaluates them only once.


File: ansicl,  Node: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Next: nth,  Prev: pop,  Up: Conses

first, second, third, fourth, fifth, sixth, seventh, eighth, ninth, tenth (Accessor)
====================================================================================

Syntax:
.......

first list → object  |  (setf (list object) new-object)
second list → object  |  (setf (list object) new-object)
third list → object  |  (setf (list object) new-object)
fourth list → object  |  (setf (list object) new-object)
fifth list → object  |  (setf (list object) new-object)
sixth list → object  |  (setf (list object) new-object)
seventh list → object  |  (setf (list object) new-object)
eighth list → object  |  (setf (list object) new-object)
ninth list → object  |  (setf (list object) new-object)
tenth list → object  |  (setf (list object) new-object)
Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

OBJECT, NEW-OBJECT--an OBJECT.

Description:
............

The functions ‘first’, ‘second’, ‘third’, ‘fourth’, ‘fifth’, ‘sixth’,
‘seventh’, ‘eighth’, ‘ninth’, and ‘tenth’ ACCESS the first, second,
third, fourth, fifth, sixth, seventh, eighth, ninth, and tenth elements
of LIST, respectively.  Specifically,

 (first LIST)    ≡  (car LIST)
 (second LIST)   ≡  (car (cdr LIST))
 (third LIST)    ≡  (car (cddr LIST))
 (fourth LIST)   ≡  (car (cdddr LIST))
 (fifth LIST)    ≡  (car (cddddr LIST))
 (sixth LIST)    ≡  (car (cdr (cddddr LIST)))
 (seventh LIST)  ≡  (car (cddr (cddddr LIST)))
 (eighth LIST)   ≡  (car (cdddr (cddddr LIST)))
 (ninth LIST)    ≡  (car (cddddr (cddddr LIST)))
 (tenth LIST)    ≡  (car (cdr (cddddr (cddddr LIST))))

‘setf’ can also be used with any of these functions to change an
existing component.  The same equivalences apply.  For example:

 (setf (fifth LIST) NEW-OBJECT) ≡ (setf (car (cddddr LIST)) NEW-OBJECT)

Examples:
.........

 (setq lst '(1 2 3 (4 5 6) ((V)) vi 7 8 9 10))
→ (1 2 3 (4 5 6) ((V)) VI 7 8 9 10)
 (first lst) → 1
 (tenth lst) → 10
 (fifth lst) → ((V))
 (second (fourth lst)) → 5
 (sixth '(1 2 3)) → NIL
 (setf (fourth lst) "four") → "four"
 lst → (1 2 3 "four" ((V)) VI 7 8 9 10)

See Also:
.........

*note car::, *note nth::

Notes:
......

‘first’  is functionally equivalent to ‘car’, ‘second’ is functionally
equivalent to ‘cadr’, ‘third’  is functionally equivalent to ‘caddr’,
and ‘fourth’ is functionally equivalent to ‘cadddr’.

The ordinal numbering used here is one-origin, as opposed to the
zero-origin numbering used by ‘nth’:

 (fifth x) ≡ (nth 4 x)


File: ansicl,  Node: nth,  Next: endp,  Prev: first; second; third; fourth; fifth; sixth; seventh; eighth; ninth; ten+,  Up: Conses

nth (Accessor)
==============

Syntax:
.......

 -- Function: nth n list → object

(setf (nth n list) new-object)

Arguments and Values:
.....................

N--a non-negative integer.

LIST--a list, which might be a dotted list or a circular list.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

‘nth’ locates the Nth element of LIST, where the car of the LIST is the
"zeroth" element.  Specifically,

 (nth N LIST) ≡ (car (nthcdr N LIST))

‘nth’ may be used to specify a PLACE to ‘setf’.  Specifically,

 (setf (nth N LIST) NEW-OBJECT) ≡ (setf (car (nthcdr N LIST)) NEW-OBJECT)

Examples:
.........

 (nth 0 '(foo bar baz)) → FOO
 (nth 1 '(foo bar baz)) → BAR
 (nth 3 '(foo bar baz)) → NIL
 (setq 0-to-3 (list 0 1 2 3)) → (0 1 2 3)
 (setf (nth 2 0-to-3) "two") → "two"
 0-to-3 → (0 1 "two" 3)

See Also:
.........

*note elt::, *note first::, *note nthcdr::


File: ansicl,  Node: endp,  Next: null (Function),  Prev: nth,  Up: Conses

endp (Function)
===============

Syntax:
.......

 -- Function: endp list → generalized-boolean

Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true  if LIST is the empty list.  Returns false if LIST is a
cons.

Examples:
.........

 (endp nil) → true
 (endp '(1 2)) → false
 (endp (cddr '(1 2))) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a list.

Notes:
......

The purpose of ‘endp’ is to test for the end of PROPER LIST.  Since
‘endp’ does not descend into a cons, it is well-defined to pass it a
dotted list.  However, if shorter "lists" are iteratively produced by
calling ‘cdr’ on such a dotted list and those "lists" are tested with
‘endp’, a situation that has undefined consequences will eventually
result when the non-nil atom (which is not in fact a list) finally
becomes the argument to ‘endp’.  Since this is the usual way in which
‘endp’ is used, it is conservative programming style and consistent
with the intent of ‘endp’ to treat ‘endp’ as simply a function on
proper lists which happens not to enforce an argument type of proper
list except when the argument is atomic.


File: ansicl,  Node: null (Function),  Next: nconc,  Prev: endp,  Up: Conses

null (Function)
===============

Syntax:
.......

 -- Function: null object → boolean

Arguments and Values:
.....................

OBJECT--an object.

BOOLEAN--a boolean.

Description:
............

Returns ‘t’ if OBJECT is the empty list; otherwise, returns ‘nil’.

Examples:
.........

 (null '()) → T
 (null nil) → T
 (null t) → NIL
 (null 1) → NIL

See Also:
.........

*note not (Function)::

Notes:
......

‘null’ is intended to be used to test for the empty list whereas ‘not’
is intended to be used to invert a boolean (or generalized boolean).
Operationally, ‘null’ and ‘not’ compute the same result; which to use
is a matter of style.

 (null OBJECT) ≡ (typep OBJECT 'null) ≡ (eq OBJECT '())


File: ansicl,  Node: nconc,  Next: append,  Prev: null (Function),  Up: Conses

nconc (Function)
================

Syntax:
.......

 -- Function: nconc &rest lists → concatenated-list

Arguments and Values:
.....................

LIST--each but the last must be a list (which might be a DOTTED LIST
but must not be a circular list); the last LIST may be any object.

CONCATENATED-LIST--a list.

Description:
............

Returns a list that is the concatenation of LISTS.  If no LISTS are
supplied, ‘(nconc)’ returns ‘nil’.  ‘nconc’ is defined using the
following recursive relationship:

 (nconc) → ()
 (nconc nil . LISTS) ≡ (nconc . LISTS)
 (nconc LIST) → LIST
 (nconc LIST-1 LIST-2) ≡ (progn (rplacd (last LIST-1) LIST-2) LIST-1)
 (nconc LIST-1 LIST-2 . LISTS) ≡ (nconc (nconc LIST-1 LIST-2) . LISTS)

Examples:
.........

 (nconc) → NIL
 (setq x '(a b c)) → (A B C)
 (setq y '(d e f)) → (D E F)
 (nconc x y) → (A B C D E F)
 x → (A B C D E F)

Note, in the example, that the value of ‘x’ is now different, since its
last cons has been ‘rplacd’'d to the value of ‘y’.  If ‘(nconc x y)’
were evaluated again, it would yield a piece of a circular list, whose
printed representation would be ‘(A B C D E F D E F D E F ...)’,
repeating forever; if the ‘*print-circle*’ switch were non-nil, it
would be printed as ‘(A B C . #1=(D E F . #1#))’.

 (setq foo (list 'a 'b 'c 'd 'e)
       bar (list 'f 'g 'h 'i 'j)
       baz (list 'k 'l 'm)) → (K L M)
 (setq foo (nconc foo bar baz)) → (A B C D E F G H I J K L M)
 foo → (A B C D E F G H I J K L M)
 bar → (F G H I J K L M)
 baz → (K L M)

 (setq foo (list 'a 'b 'c 'd 'e)
       bar (list 'f 'g 'h 'i 'j)
       baz (list 'k 'l 'm)) → (K L M)
 (setq foo (nconc nil foo bar nil baz)) → (A B C D E F G H I J K L M)
 foo → (A B C D E F G H I J K L M)
 bar → (F G H I J K L M)
 baz → (K L M)

Side Effects:
.............

The LISTS are modified rather than copied.

See Also:
.........

*note append::, *note concatenate::


File: ansicl,  Node: append,  Next: revappend; nreconc,  Prev: nconc,  Up: Conses

append (Function)
=================

Syntax:
.......

 -- Function: append &rest lists → result

Arguments and Values:
.....................

LIST--each must be a proper list except the last, which may be any
object.

RESULT--an object.  This will be a list unless the last LIST was not a
list and all preceding LISTS were null.

Description:
............

‘append’ returns a new LIST that is the concatenation of the copies.
LISTS are left unchanged; the list structure of each of LISTS except
the last is copied.  The last argument is not copied; it becomes the
cdr of the final dotted pair of the concatenation of the preceding
LISTS, or is returned directly if there are no preceding non-empty
LISTS.

Examples:
.........

 (append '(a b c) '(d e f) '() '(g)) → (A B C D E F G)
 (append '(a b c) 'd) → (A B C . D)
 (setq lst '(a b c)) → (A B C)
 (append lst '(d)) → (A B C D)
 lst → (A B C)
 (append) → NIL
 (append 'a) → A

See Also:
.........

*note nconc::, *note concatenate::



Local Variables:
coding: utf-8
End:
