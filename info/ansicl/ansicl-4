This is ansicl, produced by makeinfo version 4.13 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: with-slots,  Next: defclass,  Prev: with-accessors,  Up: Objects

with-slots (Macro)
==================

Syntax:
.......

 -- Macro: with-slots ({slot-entry}*) instance-form {declaration}*
          {form}* → {result}*

SLOT-ENTRY::=
     slot-name | (variable-name slot-name)

Arguments and Values:
.....................

SLOT-NAME--a slot name; not evaluated.

VARIABLE-NAME--a variable name; not evaluated.

INSTANCE-FORM--a form; evaluted to produce INSTANCE.

INSTANCE--an object.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by the FORMS.

Description:
............

The macro ‘with-slots’ establishes a lexical environment for referring
to the slots in the INSTANCE named by the given SLOT-NAMES as though
they were variables.  Within such a context the value of the slot can
be specified by using its slot name, as if it were a lexically bound
variable.  Both ‘setf’ and ‘setq’ can be used to set the value of the
slot.

The macro ‘with-slots’ translates an appearance of the slot name as a
variable into a call to ‘slot-value’.

Examples:
.........

 (defclass thing ()
           ((x :initarg :x :accessor thing-x)
            (y :initarg :y :accessor thing-y)))
→ #<STANDARD-CLASS THING 250020173>
 (defmethod (setf thing-x) :before (new-x (thing thing))
   (format t "~&Changing X from ~D to ~D in ~S.~%"
           (thing-x thing) new-x thing))
 (setq thing (make-instance 'thing :x 0 :y 1)) → #<THING 62310540>
 (with-slots (x y) thing (incf x) (incf y)) → 2
 (values (thing-x thing) (thing-y thing)) → 1, 2
 (setq thing1 (make-instance 'thing :x 1 :y 2)) → #<THING 43135676>
 (setq thing2 (make-instance 'thing :x 7 :y 8)) → #<THING 43147374>
 (with-slots ((x1 x) (y1 y))
             thing1
   (with-slots ((x2 x) (y2 y))
               thing2
     (list (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setq x1 (+ y1 x2))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2))
           (setf (thing-x thing2) (list x1))
           (list x1 (thing-x thing1) y1 (thing-y thing1)
                 x2 (thing-x thing2) y2 (thing-y thing2)))))
▷ Changing X from 7 to (9) in #<THING 43147374>.
→ ((1 1 2 2 7 7 8 8)
     9
     (9 9 2 2 7 7 8 8)
     (9)
     (9 9 2 2 (9) (9) 8 8))

Affected By:
............

‘defclass’

Exceptional Situations:
.......................

The consequences are undefined if any SLOT-NAME is not the name of a
slot in the INSTANCE.

See Also:
.........

*note with-accessors::, *note slot-value::, *note symbol-macrolet::

Notes:
......

A ‘with-slots’ expression of the form:

(with-accessors (SLOT-ENTRY₁, ... SLOT-ENTRY_n)
INSTANCE-FORM FORM₁ ... FORM_k)

expands into the equivalent of

(let ((in INSTANCE-FORM))
(symbol-macrolet (Q₁ ... Q_n) FORM₁ ... FORM_k))

where Q_i is

(SLOT-ENTRY_i () (slot-value in 'SLOT-ENTRY_i))

if SLOT-ENTRY_i is a symbol and is

(VARIABLE-NAME_i () (slot-value in 'SLOT-NAME_i))

if SLOT-ENTRY_i is of the form

(VARIABLE-NAME_i SLOT-NAME_i)


File: ansicl,  Node: defclass,  Next: defgeneric,  Prev: with-slots,  Up: Objects

defclass (Macro)
================

Syntax:
.......

 -- Macro: defclass CLASS-NAME ({SUPERCLASS-NAME}*) ({slot-specifier}*)
          [[↓class-option]] → new-class

slot-specifier::=
     slot-name | (slot-name 〚↓slot-option〛)

slot-name::= symbol

slot-option::=
     {:reader reader-function-name}* |
     {:writer writer-function-name}* |
     {:accessor reader-function-name}* |
     {:allocation allocation-type} |
     {:initarg initarg-name}* |
     {:initform form} |
     {:type type-specifier} |
     {:documentation string}

function-name::= {symbol | (setf symbol)}

class-option::=
     (:default-initargs . initarg-list) |
     (:documentation string) |
     (:metaclass class-name)

Arguments and Values:
.....................

CLASS-NAME--a non-nil symbol.

SUPERCLASS-NAME--a non-nil symbol.

SLOT-NAME--a symbol.  The SLOT-NAME argument is a symbol that is
syntactically valid for use as a variable name.

READER-FUNCTION-NAME--a non-nil symbol.  :reader can be supplied more
than once for a given slot.

WRITER-FUNCTION-NAME--a generic function name.  :writer can be supplied
more than once for a given slot.

READER-FUNCTION-NAME--a non-nil symbol.  :accessor can be supplied more
than once for a given slot.

ALLOCATION-TYPE--(member :instance :class).  :allocation can be
supplied once at most for a given slot.

INITARG-NAME--a symbol.  :initarg can be supplied more than once for a
given slot.

FORM--a form.  :init-form can be supplied once at most for a given slot.

TYPE-SPECIFIER--a type specifier.  :type can be supplied once at most
for a given slot.

CLASS-OPTION-- refers to the class as a whole or to all class slots.

INITARG-LIST--a list of alternating initialization argument names and
default initial value forms.  :default-initargs can be supplied at most
once.

CLASS-NAME--a non-nil symbol.  :metaclass can be supplied once at most.

NEW-CLASS--the new class object.

Description:
............

The macro ‘defclass’ defines a new named class.  It returns the new
class object as its result.

The syntax of ‘defclass’ provides options for specifying initialization
arguments for slots, for specifying default initialization values for
slots, and for requesting that methods on specified generic functions
be automatically generated for reading and writing the values of slots.
No reader or writer functions are defined by default; their generation
must be explicitly requested.  However, slots can always be accessed
using ‘slot-value’.

Defining a new class also causes a type of the same name to be defined.
The predicate ‘(typep OBJECT CLASS-NAME)’ returns true if the class of
the given OBJECT is the class named by CLASS-NAME itself or a subclass
of the class CLASS-NAME.  A class object can be used as a type
specifier.  Thus ‘(typep OBJECT CLASS)’ returns true if the class of
the OBJECT is CLASS itself or a subclass of CLASS.

The CLASS-NAME argument specifies the proper name of the new class.  If
a class with the same proper name already exists and that class is an
instance of ‘standard-class’, and if the ‘defclass’ form for the
definition of the new class specifies a class of class ‘standard-class’,
the existing class is redefined, and instances of it (and its
subclasses) are updated to the new definition at the time that they are
next accessed.  For details, see *note Section 4.3.6 (Redefining
Classes): Redefining Classes.

Each SUPERCLASS-NAME argument specifies a direct superclass of the new
class.  If the superclass list is empty, then the superclass defaults
depending on the metaclass, with ‘standard-object’ being the default
for ‘standard-class’.

The new class will inherit slots and methods from each of its direct
superclasses, from their direct superclasses, and so on.  For a
discussion of how slots and methods are inherited, see *note Section
4.3.4 (Inheritance): Inheritance.

The following slot options are available:

   * The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named READER-FUNCTION-NAME to
     read the value of the given slot.

   * The :writer slot option specifies that an unqualified method is to
     be defined on the generic function named WRITER-FUNCTION-NAME to
     write the value of the slot.

   * The :accessor slot option specifies that an unqualified method is
     to be defined on the generic function named READER-FUNCTION-NAME
     to read the value of the given slot and that an unqualified method
     is to be defined on the generic function named ‘(setf
     READER-FUNCTION-NAME)’ to be used with ‘setf’ to modify the value
     of the slot.

   * The :allocation slot option is used to specify where storage is to
     be allocated for the given slot.  Storage for a slot can be located
     in each instance or in the class object itself.  The value of the
     ALLOCATION-TYPE argument can be either the keyword :instance or
     the keyword :class.    If the :allocation slot option is not
     specified, the effect is the same as specifying ‘:allocation
     :instance’.

        - If ALLOCATION-TYPE is :instance, a local slot of the name
          SLOT-NAME is allocated in each instance of the class.

        - If ALLOCATION-TYPE is :class, a shared slot of the given name
          is allocated in the class object created by this ‘defclass’
          form.  The value of the slot is shared by all instances of
          the class.  If a class C₁ defines such a shared slot, any
          subclass C₂ of C₁ will share this single slot unless the
          ‘defclass’ form for C₂ specifies a slot of the same name or
          there is a superclass of C₂ that precedes C₁ in the class
          precedence list of C₂ and that defines a slot of the same
          name.

   * The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This
     form is evaluated every time it is used to initialize the slot.
     The lexical environment in which this form is evaluated is the
     lexical environment in which the ‘defclass’ form was evaluated.
     Note that the lexical environment refers both to variables and to
     functions.  For local slots, the dynamic environment is the dynamic
     environment in which ‘make-instance’ is called; for shared slots,
     the dynamic environment is the dynamic environment in which the
     ‘defclass’ form was evaluated.  See *note Section 7.1 (Object
     Creation and Initialization): Object Creation and Initialization.

     No implementation is permitted to extend the syntax of ‘defclass’
     to allow ‘(SLOT-NAME FORM)’ as an abbreviation for ‘(SLOT-NAME
     :initform FORM)’.

   * The :initarg slot option declares an initialization argument named
     INITARG-NAME and specifies that this initialization argument
     initializes the given slot.  If the initialization argument has a
     value in the call to ‘initialize-instance’, the value will be
     stored into the given slot, and the slot's :initform slot option,
     if any, is not evaluated.  If none of the initialization arguments
     specified for a given slot has a value, the slot is initialized
     according to the :initform slot option, if specified.

   * The :type slot option specifies that the contents of the slot will
     always be of the specified data type.  It effectively declares the
     result type of the reader generic function when applied to an
     object of this class.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot are
     undefined.  The :type slot option is further discussed in *note
     Section 7.5.3 (Inheritance of Slots and Slot Options): Inheritance
     of Slots and Slot Options.

   * The :documentation slot option provides a documentation string for
     the slot.  :documentation can be supplied once at most for a given
     slot.

Each class option is an option that refers to the class as a whole.
The following class options are available:

   * The :default-initargs class option is followed by a list of
     alternating initialization argument names and default initial value
     forms.  If any of these initialization arguments does not appear in
     the initialization argument list supplied to ‘make-instance’, the
     corresponding default initial value form is evaluated, and the
     initialization argument name and the form's value are added to the
     end of the initialization argument list before the instance is
     created; see *note Section 7.1 (Object Creation and
     Initialization): Object Creation and Initialization.  The default
     initial value form is evaluated each time it is used.  The lexical
     environment in which this form is evaluated is the lexical
     environment in which the ‘defclass’ form was evaluated.  The
     dynamic environment is the dynamic environment in which
     ‘make-instance’ was called.  If an initialization argument name
     appears more than once in a :default-initargs class option, an
     error is signaled.

   * The :documentation class option causes a documentation string to
     be attached with the class object, and attached with kind type to
     the CLASS-NAME.  :documentation can be supplied once at most.

   * The :metaclass class option is used to specify that instances of
     the class being defined are to have a different metaclass than the
     default provided by the system (the class ‘standard-class’).

Note the following rules of ‘defclass’ for standard classes:

   * It is not required that the superclasses of a class be defined
     before the ‘defclass’ form for that class is evaluated.

   * All the superclasses of a class must be defined before an instance
     of the class can be made.

   * A class must be defined before it can be used as a parameter
     specializer in a ‘defmethod’ form.

The object system can be extended to cover situations where these rules
are not obeyed.

Some slot options are inherited by a class from its superclasses, and
some can be shadowed or altered by providing a local slot description.
No class options except :default-initargs are inherited.  For a
detailed description of how slots and slot options are inherited, see
*note Section 7.5.3 (Inheritance of Slots and Slot Options):
Inheritance of Slots and Slot Options.

The options to ‘defclass’ can be extended.  It is required that all
implementations signal an error if they observe a class option or a
slot option that is not implemented locally.

It is valid to specify more than one reader, writer, accessor, or
initialization argument for a slot.  No other slot option can appear
more than once in a single slot description, or an error is signaled.

If no reader, writer, or accessor is specified for a slot, the slot can
only be accessed by the function ‘slot-value’.

If a ‘defclass’ form appears as a top level form, the compiler must
make the class name be recognized as a valid type name in subsequent
declarations (as for ‘deftype’) and be recognized as a valid class name
for ‘defmethod’ parameter specializers and for use as the :metaclass
option of a subsequent ‘defclass’.  The compiler must make the class
definition available to be returned by ‘find-class’ when its ENVIRONMENT
argument is a value received as the environment parameter of a macro.

Exceptional Situations:
.......................

If there are any duplicate slot names, an error of type ‘program-error’
is signaled.

If an initialization argument name appears more than once in
:default-initargs class option, an error of type ‘program-error’ is
signaled.

If any of the following slot options appears more than once in a single
slot description, an error of type ‘program-error’ is signaled:
:allocation, :initform, :type, :documentation.

It is required that all implementations signal an error of type
‘program-error’ if they observe a class option or a slot option that is
not implemented locally.

See Also:
.........

*note documentation::, *note initialize-instance (Standard Generic
Function)::, *note make-instance::, *note slot-value::, *note Section
4.3 (Classes): Classes, *note Section 4.3.4 (Inheritance): Inheritance,
*note Section 4.3.6 (Redefining Classes): Redefining Classes, *note
Section 4.3.5 (Determining the Class Precedence List): Determining the
Class Precedence List, *note Section 7.1 (Object Creation and
Initialization): Object Creation and Initialization.


File: ansicl,  Node: defgeneric,  Next: defmethod,  Prev: defclass,  Up: Objects

defgeneric (Macro)
==================

Syntax:
.......

 -- Macro: defgeneric function-name gf-lambda-list 〚↓option |
          {↓method-description}*〛 → new-generic

OPTION::=
     (:argument-precedence-order {PARAMETER-NAME}+) |
     (declare {GF-DECLARATION}+) |
     (:documentation GF-DOCUMENTATION) |
     (:method-combination METHOD-COMBINATION
     {method-combination-argument}*) |
     (:generic-function-class GENERIC-FUNCTION-CLASS) |
     (:method-class METHOD-CLASS)

METHOD-DESCRIPTION::=
     (:method {method-qualifier}* SPECIALIZED-LAMBDA-LIST
     〚{declaration}* | documentation〛 {form}*)

Arguments and Values:
.....................

FUNCTION-NAME--a function name.

GENERIC-FUNCTION-CLASS--a non-nil symbol naming a class.

GF-DECLARATION--an ‘optimize’ declaration specifier; other declaration
specifiers are not permitted.

GF-DOCUMENTATION--a string; not evaluated.

GF-LAMBDA-LIST--a generic function lambda list.

METHOD-CLASS--a non-nil symbol naming a class.

METHOD-COMBINATION-ARGUMENT--an object.

METHOD-COMBINATION-NAME--a symbol naming a method combination type.

METHOD-QUALIFIERS, SPECIALIZED-LAMBDA-LIST, DECLARATIONS, DOCUMENTATION,
FORMS--as per ‘defmethod’.

NEW-GENERIC--the generic function object.

PARAMETER-NAME--a symbol that names a required parameter in the
LAMBDA-LIST.  (If the :argument-precedence-order option is specified,
each required parameter in the LAMBDA-LIST must be used exactly once as
a PARAMETER-NAME.)

Description:
............

The macro ‘defgeneric’ is used to define a generic function or to
specify options and declarations that pertain to a generic function as
a whole.

If FUNCTION-NAME is a list it must be of the form ‘(setf symbol)’.  If
‘(fboundp FUNCTION-NAME)’ is false, a new generic function is created.
If ‘(fdefinition FUNCTION-NAME)’ is a generic function, that generic
function is modified.  If FUNCTION-NAME names an ordinary function, a
macro, or a special operator, an error is signaled.

The effect of the ‘defgeneric’ macro is as if the following three steps
were performed: first, methods defined by previous ‘defgeneric’ forms
are removed;

second, ‘ensure-generic-function’ is called; and finally, methods
specified by the current ‘defgeneric’ form are added to the generic
function.

Each METHOD-DESCRIPTION defines a method on the generic function.  The
lambda list of each method must be congruent with the lambda list
specified by the GF-LAMBDA-LIST option.  If no method descriptions are
specified and a generic function of the same name does not already
exist, a generic function with no methods is created.

The GF-LAMBDA-LIST argument of ‘defgeneric’ specifies the shape of
lambda lists for the methods on this generic function.  All methods on
the resulting generic function must have lambda lists that are
congruent with this shape.  If a ‘defgeneric’ form is evaluated and some
methods for that generic function have lambda lists that are not
congruent with that given in the ‘defgeneric’ form, an error is
signaled.  For further details on method congruence, see *note Section
7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.

The generic function passes to the method all the argument values
passed to it, and only those; default values are not supported.  Note
that optional and keyword arguments in method definitions, however, can
have default initial value forms and can use supplied-p parameters.

The following options are provided.  Except as otherwise noted, a given
option may occur only once.

   * The :argument-precedence-order option is used to specify the order
     in which the required arguments in a call to the generic function
     are tested for specificity when selecting a particular method.
     Each required argument, as specified in the GF-LAMBDA-LIST
     argument, must be included exactly once as a PARAMETER-NAME so
     that the full and unambiguous precedence order is supplied.  If
     this condition is not met, an error is signaled.

   * The declare option is used to specify declarations that pertain to
     the generic function.

     An ‘optimize’ declaration specifier is allowed.  It specifies
     whether method selection should be optimized for speed or space,
     but it has no effect on methods.  To control how a method is
     optimized, an ‘optimize’ declaration must be placed directly in
     the ‘defmethod’ form or method description.  The optimization
     qualities speed and space are the only qualities this standard
     requires, but an implementation can extend the object system to
     recognize other qualities.  A simple implementation that has only
     one method selection technique and ignores ‘optimize’ declaration
     specifiers is valid.

     The ‘special’, ‘ftype’, ‘function’, ‘inline’, ‘notinline’, and
     ‘declaration’ declarations are not permitted.  Individual
     implementations can extend the declare option to support
     additional declarations.

     If an implementation notices a declaration specifier that it does
     not support and that has not been proclaimed as a non-standard
     declaration identifier name in a ‘declaration’ proclamation, it
     should issue a warning.

     The declare option may be specified more than once.  The effect is
     the same as if the lists of declaration specifiers had been
     appended together into a single list and specified as a single
     declare option.

   * The :documentation argument is a documentation string to be
     attached to the generic function object, and to be attached with
     kind function to the FUNCTION-NAME.

   * The :generic-function-class option may be used to specify that the
     generic function is to have a different class than the default
     provided by the system (the class ‘standard-generic-function’).
     The CLASS-NAME argument is the name of a class that can be the
     class of a generic function.  If FUNCTION-NAME specifies an
     existing generic function that has a different value for the
     :generic-function-class argument and the new generic function
     class is compatible with the old, ‘change-class’ is called to
     change the class of the generic function; otherwise an error is
     signaled.

   * The :method-class option is used to specify that all methods on
     this generic function are to have a different class from the
     default provided by the system (the class ‘standard-method’).  The
     CLASS-NAME argument is the name of a class that is capable of
     being the class of a method.

   * The :method-combination option is followed by a symbol that names
     a type of method combination.  The arguments (if any) that follow
     that symbol depend on the type of method combination.  Note that
     the standard method combination type does not support any
     arguments.  However, all types of method combination defined by the
     short form of ‘define-method-combination’ accept an optional
     argument named ORDER, defaulting to :most-specific-first, where a
     value of :most-specific-last reverses the order of the primary
     methods without affecting the order of the auxiliary methods.

The METHOD-DESCRIPTION arguments define methods that will be associated
with the generic function.  The METHOD-QUALIFIER and
SPECIALIZED-LAMBDA-LIST arguments in a method description are the same
as for ‘defmethod’.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If FUNCTION-NAME is a symbol, this
block bears the same name as the generic function.  If FUNCTION-NAME is
a list of the form ‘(setf SYMBOL)’, the name of the block is SYMBOL.

Implementations can extend ‘defgeneric’ to include other options.  It
is required that an implementation signal an error if it observes an
option that is not implemented locally.

‘defgeneric’ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

Examples:
.........

Exceptional Situations:
.......................

If FUNCTION-NAME names an ordinary function, a macro, or a special
operator, an error of type ‘program-error’ is signaled.

Each required argument, as specified in the GF-LAMBDA-LIST argument,
must be included exactly once as a PARAMETER-NAME, or an error of type
‘program-error’ is signaled.

The lambda list of each method specified by a METHOD-DESCRIPTION must
be congruent with the lambda list specified by the GF-LAMBDA-LIST
option, or an error of type ‘error’ is signaled.

If a ‘defgeneric’ form is evaluated and some methods for that generic
function have lambda lists that are not congruent with that given in
the ‘defgeneric’ form, an error of type ‘error’ is signaled.

A given OPTION may occur only once, or an error of type ‘program-error’
is signaled.

If FUNCTION-NAME specifies an existing generic function that has a
different value for the :generic-function-class argument and the new
generic function class is compatible with the old, ‘change-class’ is
called to change the class of the generic function; otherwise an error
of type ‘error’ is signaled.

Implementations can extend ‘defgeneric’ to include other options.  It
is required that an implementation signal an error of type
‘program-error’ if it observes an option that is not implemented
locally.

See Also:
.........

*note defmethod::, *note documentation::, *note
ensure-generic-function::, *note generic-function::, *note Section
7.6.4 (Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function.


File: ansicl,  Node: defmethod,  Next: find-class,  Prev: defgeneric,  Up: Objects

defmethod (Macro)
=================

Syntax:
.......

 -- Macro: defmethod
          function-name {method-qualifier}* specialized-lambda-list
          〚{declaration}* | documentation〛 {form}* → new-method

function-name::= {symbol | (setf symbol)}

method-qualifier::= non-list

specialized-lambda-list::=
     ({var | (var parameter-specializer-name)}*
     [&optional {var | (var [initform [supplied-p-parameter]])}*]
     [&rest var]
     [&key { var | (var [initfom [supplied-p-parameter]])}*
     [‘&allow-other-keys’]]
     [&aux {var |
     (var [initform])}*])

parameter-specializer-name::=
     symbol | (eql eql-specializer-form)

Arguments and Values:
.....................

DECLARATION--a declare expression; not evaluated.

DOCUMENTATION--a string; not evaluated.

VAR--a variable name.

EQL-SPECIALIZER-FORM--a form.

FORM--a form.

INITFORM--a form.

SUPPLIED-P-PARAMETER--variable name.

NEW-METHOD--the new method object.

Description:
............

The macro ‘defmethod’ defines a method on a generic function.

If ‘(fboundp function-name)’ is ‘nil’, a generic function is created
with default values for the argument precedence order (each argument is
more specific than the arguments to its right in the argument list),
for the generic function class (the class ‘standard-generic-function’),
for the method class (the class ‘standard-method’), and for the method
combination type (the standard method combination type).  The lambda
list of the generic function is congruent with the lambda list of the
method being defined; if the ‘defmethod’ form mentions keyword
arguments, the lambda list of the generic function will mention ‘&key’
(but no keyword arguments).  If function-name names an ordinary
function, a macro, or a special operator, an error is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the
generic function.  If this condition does not hold, an error is
signaled.  For a definition of congruence in this context, see *note
Section 7.6.4 (Congruent Lambda-lists for all Methods of a Generic
Function): Congruent Lambda-lists for all Methods of a Generic Function.

Each method-qualifier argument is an object that is used by method
combination to identify the given method.  The method combination type
might further restrict what a method qualifier can be.  The standard
method combination type allows for unqualified methods and methods
whose sole qualifier is one of the keywords :before, :after, or :around.

The specialized-lambda-list argument is like an ordinary lambda list
except that the names of required parameters can be replaced by
specialized parameters.  A specialized parameter is a list of the form
‘(VAR parameter-specializer-name)’.  Only required parameters can be
specialized.  If parameter-specializer-name is a symbol it names a
class; if it is a list, it is of the form ‘(eql EQL-SPECIALIZER-FORM)’.
The parameter specializer name ‘(eql EQL-SPECIALIZER-FORM)’ indicates
that the corresponding argument must be ‘eql’ to the object that is the
value of EQL-SPECIALIZER-FORM for the method to be applicable.  The
EQL-SPECIALIZER-FORM is evaluated at the time that the expansion of the
‘defmethod’ macro is evaluated.  If no parameter specializer name is
specified for a given required parameter, the parameter specializer
defaults to the class ‘t’.  For further discussion, see *note Section
7.6.2 (Introduction to Methods): Introduction to Methods.

The FORM arguments specify the method body.  The body of the method is
enclosed in an implicit block.  If function-name is a symbol, this
block bears the same name as the generic function.  If function-name is
a list of the form ‘(setf symbol)’, the name of the block is symbol.

The class of the method object that is created is that given by the
method class option of the generic function on which the method is
defined.

If the generic function already has a method that agrees with the
method being defined on parameter specializers and qualifiers,
‘defmethod’ replaces the existing method with the one now being defined.
For a definition of agreement in this context.  see *note Section 7.6.3
(Agreement on Parameter Specializers and Qualifiers): Agreement on
Parameter Specializers and Qualifiers.

The parameter specializers are derived from the parameter specializer
names as described in *note Section 7.6.2 (Introduction to Methods):
Introduction to Methods.

The expansion of the ‘defmethod’ macro "refers to" each specialized
parameter (see the description of ‘ignore’ within the description of
declare).  This includes parameters that have an explicit parameter
specializer name of ‘t’.  This means that a compiler warning does not
occur if the body of the method does not refer to a specialized
parameter, while a warning might occur if the body of the method does
not refer to an unspecialized parameter.  For this reason, a parameter
that specializes on ‘t’ is not quite synonymous with an unspecialized
parameter in this context.

Declarations at the head of the method body that apply to the method's
lambda variables are treated as bound declarations whose scope is the
same as the corresponding bindings.

Declarations at the head of the method body that apply to the
functional bindings of ‘call-next-method’ or ‘next-method-p’ apply to
references to those functions within the method body FORMS.  Any outer
bindings of the function names ‘call-next-method’ and ‘next-method-p’,
and declarations associated with such bindings are shadowed₂ within the
method body FORMS.

The scope of free declarations at the head of the method body is the
entire method body, which includes any implicit local function
definitions but excludes initialization forms for the lambda variables.

‘defmethod’ is not required to perform any compile-time side effects.
In particular, the methods are not installed for invocation during
compilation.  An implementation may choose to store information about
the generic function for the purposes of compile-time error-checking
(such as checking the number of arguments on calls, or noting that a
definition for the function name has been seen).

DOCUMENTATION is attached as a documentation string to the method
object.

Affected By:
............

The definition of the referenced generic function.

Exceptional Situations:
.......................

If function-name names an ordinary function, a macro, or a special
operator, an error of type ‘error’ is signaled.

If a generic function is currently named by function-name, the lambda
list of the method must be congruent with the lambda list of the
generic function, or an error of type ‘error’ is signaled.

See Also:
.........

*note defgeneric::, *note documentation::, *note Section 7.6.2
(Introduction to Methods): Introduction to Methods, *note Section 7.6.4
(Congruent Lambda-lists for all Methods of a Generic Function):
Congruent Lambda-lists for all Methods of a Generic Function, *note
Section 7.6.3 (Agreement on Parameter Specializers and Qualifiers):
Agreement on Parameter Specializers and Qualifiers, *note Section
3.4.11 (Syntactic Interaction of Documentation Strings and
Declarations): Syntactic Interaction of Documentation Strings and
Declarations.


File: ansicl,  Node: find-class,  Next: next-method-p,  Prev: defmethod,  Up: Objects

find-class (Accessor)
=====================

Syntax:
.......

 -- Function: find-class symbol &optional errorp environment → class

(setf (find-class symbol &optional errorp environment) new-class)

Arguments and Values:
.....................

SYMBOL--a symbol.

ERRORP--a generalized boolean.  The default is true.

ENVIRONMENT--same as the ‘&environment’ argument to macro expansion
functions and is used to distinguish between compile-time and run-time
environments.  The ‘&environment’ argument has dynamic extent; the
consequences are undefined if the ‘&environment’ argument is referred
to outside the dynamic extent of the macro expansion function.

CLASS--a class object, or ‘nil’.

Description:
............

Returns the class object named by the SYMBOL in the ENVIRONMENT.  If
there is no such class, ‘nil’ is returned if ERRORP is false; otherwise,
if ERRORP is true, an error is signaled.

The class associated with a particular symbol can be changed by using
‘setf’ with ‘find-class’; or, if the new class given to ‘setf’ is ‘nil’,
the class association is removed (but the class object itself is not
affected).  The results are undefined if the user attempts to change or
remove the class associated with a symbol that is defined as a type
specifier in this standard.  See *note Section 4.3.7 (Integrating Types
and Classes): Integrating Types and Classes.

When using ‘setf’ of ‘find-class’, any errorp argument is evaluated for
effect, but any values it returns are ignored; the ERRORP parameter is
permitted primarily so that the ENVIRONMENT parameter can be used.

The ENVIRONMENT might be used to distinguish between a compile-time and
a run-time environment.

Exceptional Situations:
.......................

If there is no such class and ERRORP is true, ‘find-class’ signals an
error of type ‘error’.

See Also:
.........

*note defmacro::, *note Section 4.3.7 (Integrating Types and Classes):
Integrating Types and Classes.


File: ansicl,  Node: next-method-p,  Next: call-method; make-method,  Prev: find-class,  Up: Objects

next-method-p (Local Function)
==============================

Syntax:
.......

 -- Function: next-method-p <no arguments> → generalized-boolean

Arguments and Values:
.....................

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

The locally defined function ‘next-method-p’ can be used within the
body forms (but not the lambda list) defined by a method-defining form
to determine whether a next method exists.

The function ‘next-method-p’ has lexical scope and indefinite extent.

Whether or not ‘next-method-p’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘next-method-p’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘next-method-p’ outside of a
method-defining form are undefined.

See Also:
.........

*note call-next-method::, *note defmethod::, *note call-method::


File: ansicl,  Node: call-method; make-method,  Next: call-next-method,  Prev: next-method-p,  Up: Objects

call-method, make-method (Local Macro)
======================================

Syntax:
.......

 -- Macro: call-method method &optional next-method-list → {result}*

 -- Macro: make-method form → method-object

Arguments and Values:
.....................

METHOD--a method object, or a list (see below); not evaluated.

METHOD-OBJECT--a method object.

NEXT-METHOD-LIST--a list of METHOD objects; not evaluated.

RESULTS--the values returned by the method invocation.

Description:
............

The macro ‘call-method’ is used in method combination.  It hides the
implementation-dependent details of how methods are called. The macro
‘call-method’ has lexical scope and can only be used within an
effective method form.

Whether or not ‘call-method’ is fbound in the global environment is
implementation-dependent; however, the restrictions on redefinition and
shadowing of ‘call-method’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘call-method’ outside of an effective
method form are undefined.

The macro ‘call-method’ invokes the specified method, supplying it with
arguments and with definitions for ‘call-next-method’ and for
‘next-method-p’.  If the invocation of ‘call-method’ is lexically inside
of a ‘make-method’, the arguments are those that were supplied to that
method.  Otherwise the arguments are those that were supplied to the
generic function.  The definitions of ‘call-next-method’ and
‘next-method-p’ rely on the specified NEXT-METHOD-LIST.

If METHOD is a list, the first element of the list must be the symbol
‘make-method’ and the second element must be a form.  Such a list
specifies a method object whose method function has a body that is the
given form.

NEXT-METHOD-LIST can contain method objects or lists, the first element
of which must be the symbol ‘make-method’ and the second element of
which must be a form.

Those are the only two places where ‘make-method’ can be used.  The
form used with ‘make-method’ is evaluated in the null lexical
environment augmented with a local macro definition for ‘call-method’
and with bindings named by symbols not accessible from the
‘COMMON-LISP-USER’ package.

The ‘call-next-method’ function available to METHOD will call the first
method in NEXT-METHOD-LIST.  The ‘call-next-method’ function available
in that method, in turn, will call the second method in
NEXT-METHOD-LIST, and so on, until the list of next methods is
exhausted.

If NEXT-METHOD-LIST is not supplied, the ‘call-next-method’ function
available to METHOD signals an error of type ‘control-error’ and the
‘next-method-p’ function available to METHOD returns ‘nil’.

Examples:
.........

See Also:
.........

*note call-next-method::, *note define-method-combination::, *note
next-method-p::


File: ansicl,  Node: call-next-method,  Next: compute-applicable-methods,  Prev: call-method; make-method,  Up: Objects

call-next-method (Local Function)
=================================

Syntax:
.......

 -- Function: call-next-method &rest args → {result}*

Arguments and Values:
.....................

ARG--an object.

RESULTS--the values returned by the method it calls.

Description:
............

The function ‘call-next-method’ can be used within the body forms (but
not the lambda list) of a method defined by a method-defining form to
call the next method.

If there is no next method, the generic function ‘no-next-method’ is
called.

The type of method combination used determines which methods can invoke
‘call-next-method’.  The standard method combination type allows
‘call-next-method’ to be used within primary methods and around methods.
For generic functions using a type of method combination defined by the
short form of ‘define-method-combination’, ‘call-next-method’ can be
used in around methods only.

When ‘call-next-method’ is called with no arguments, it passes the
current method's original arguments to the next method.  Neither
argument defaulting, nor using ‘setq’, nor rebinding variables with the
same names as parameters of the method affects the values
‘call-next-method’ passes to the method it calls.

When ‘call-next-method’ is called with arguments, the next method is
called with those arguments.

If ‘call-next-method’ is called with arguments but omits optional
arguments, the next method called defaults those arguments.

The function ‘call-next-method’ returns any values that are returned by
the next method.

The function ‘call-next-method’ has lexical scope and indefinite extent
and can only be used within the body of a method defined by a
method-defining form.

Whether or not ‘call-next-method’ is fbound in the global environment
is implementation-dependent; however, the restrictions on redefinition
and shadowing of ‘call-next-method’ are the same as for symbols in the
‘COMMON-LISP’ package which are fbound in the global environment.  The
consequences of attempting to use ‘call-next-method’ outside of a
method-defining form are undefined.

Affected By:
............

‘defmethod’, ‘call-method’, ‘define-method-combination’.

Exceptional Situations:
.......................

When providing arguments to ‘call-next-method’, the following rule must
be satisfied or an error of type ‘error’ should be signaled: the
ordered set of applicable methods for a changed set of arguments for
‘call-next-method’ must be the same as the ordered set of applicable
methods for the original arguments to the generic function.
Optimizations of the error checking are possible, but they must not
change the semantics of ‘call-next-method’.

See Also:
.........

*note define-method-combination::, *note defmethod::, *note
next-method-p::, *note no-next-method::, *note call-method::, *note
Section 7.6.6 (Method Selection and Combination): Method Selection and
Combination, *note Section 7.6.6.2 (Standard Method Combination):
StdMethComb, *note Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes.


File: ansicl,  Node: compute-applicable-methods,  Next: define-method-combination,  Prev: call-next-method,  Up: Objects

compute-applicable-methods (Standard Generic Function)
======================================================

Syntax:
.......

 -- Generic Function: compute-applicable-methods generic-function
          function-arguments → methods

Method Signatures:
..................

compute-applicable-methods (GENERIC-FUNCTION
‘standard-generic-function’)

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function.

FUNCTION-ARGUMENTS--a list of arguments for the GENERIC-FUNCTION.

METHODS--a list of method objects.

Description:
............

Given a GENERIC-FUNCTION and a set of FUNCTION-ARGUMENTS, the function
‘compute-applicable-methods’ returns the set of methods that are
applicable for those arguments sorted according to precedence order.
See *note Section 7.6.6 (Method Selection and Combination): Method
Selection and Combination.

Affected By:
............

‘defmethod’

See Also:
.........

*note Section 7.6.6 (Method Selection and Combination): Method
Selection and Combination.


File: ansicl,  Node: define-method-combination,  Next: find-method,  Prev: compute-applicable-methods,  Up: Objects

define-method-combination (Macro)
=================================

Syntax:
.......

 -- Macro: define-method-combination name 〚↓short-form-option〛 → name

 -- Macro: define-method-combination name lambda-list
          ({method-group-specifier}*) [(:arguments . args-lambda-list)]
          [(:generic-function  generic-function-symbol)]
          〚{declaration}* | documentation〛 {form}* → name

SHORT-FORM-OPTION::=
     :documentation DOCUMENTATION |
     :identity-with-one-argument IDENTITY-WITH-ONE-ARGUMENT |
     :operator OPERATOR

METHOD-GROUP-SPECIFIER::=
     (name {{QUALIFIER-PATTERN}+ | predicate} 〚↓long-form-option〛)

LONG-FORM-OPTION::=
     :description DESCRIPTION |
     :order ORDER |
     :required REQUIRED-P

Arguments and Values:
.....................

ARGS-LAMBDA-LIST-- a define-method-combination arguments lambda list.

DECLARATION--a declare expression; not evaluated.

DESCRIPTION--a format control.

DOCUMENTATION--a string; not evaluated.

FORMS--an implicit progn that must compute and return the form that
specifies how the methods are combined, that is, the effective method.

GENERIC-FUNCTION-SYMBOL--a symbol.

IDENTITY-WITH-ONE-ARGUMENT--a generalized boolean.

LAMBDA-LIST--ordinary lambda list.

NAME--a symbol.  Non-keyword, non-nil symbols are usually used.

OPERATOR--an operator.  NAME and OPERATOR are often the same symbol.
This is the default, but it is not required.

ORDER--:most-specific-first or :most-specific-last; evaluated.

PREDICATE--a symbol that names a function of one argument that returns
a generalized boolean.

QUALIFIER-PATTERN--a list, or the symbol *.

REQUIRED-P--a generalized boolean.

Description:
............

The macro ‘define-method-combination’ is used to define new types of
method combination.

There are two forms of ‘define-method-combination’.  The short form is
a simple facility for the cases that are expected to be most commonly
needed.  The long form is more powerful but more verbose.  It resembles
‘defmacro’ in that the body is an expression, usually using backquote,
that computes a form.  Thus arbitrary control structures can be
implemented.  The long form also allows arbitrary processing of method
qualifiers.

Short Form
     The short form syntax of ‘define-method-combination’ is recognized
     when the second subform is a non-nil symbol or is not present.
     When the short form is used, NAME is defined as a type of method
     combination that produces a Lisp form ‘(OPERATOR METHOD-CALL
     METHOD-CALL ...)’.  The OPERATOR is a symbol that can be the name
     of a function, macro, or special operator.  The OPERATOR can be
     supplied by a keyword option; it defaults to NAME.

     Keyword options for the short form are the following:

        * The :documentation option is used to document the
          method-combination type; see description of long form below.

        * The :identity-with-one-argument option enables an optimization
          when its value is true (the default is false).  If there is
          exactly one applicable method and it is a primary method,
          that method serves as the effective method and OPERATOR is
          not called.  This optimization avoids the need to create a
          new effective method and avoids the overhead of a function
          call.  This option is designed to be used with operators such
          as ‘progn’, ‘and’, ‘+’, and ‘max’.

        * The :operator option specifies the name of the operator.  The
          OPERATOR argument is a symbol that can be the name of a
          function, macro, or special form.

     These types of method combination require exactly one qualifier per
     method.  An error is signaled if there are applicable methods with
     no qualifiers or with qualifiers that are not supported by the
     method combination type.

     A method combination procedure defined in this way recognizes two
     roles for methods.  A method whose one qualifier is the symbol
     naming this type of method combination is defined to be a primary
     method.  At least one primary method must be applicable or an
     error is signaled.  A method with :around as its one qualifier is
     an auxiliary method that behaves the same as an around method in
     standard method combination.  The function ‘call-next-method’ can
     only be used in around methods; it cannot be used in primary
     methods defined by the short form of the
     ‘define-method-combination’ macro.

     A method combination procedure defined in this way accepts an
     optional argument named ORDER, which defaults to
     :most-specific-first.  A value of :most-specific-last reverses the
     order of the primary methods without affecting the order of the
     auxiliary methods.

     The short form automatically includes error checking and support
     for around methods.

     For a discussion of built-in method combination types, see *note
     Section 7.6.6.4 (Built-in Method Combination Types):
     BuiltInMethCombTypes.

Long Form
     The long form syntax of ‘define-method-combination’ is recognized
     when the second subform is a list.

     The LAMBDA-LIST receives any arguments provided after the name of
     the method combination type in the :method-combination option to
     ‘defgeneric’.

     A list of method group specifiers follows.  Each specifier selects
     a subset of the applicable methods to play a particular role,
     either by matching their qualifiers against some patterns or by
     testing their qualifiers with a PREDICATE.  These method group
     specifiers define all method qualifiers that can be used with this
     type of method combination.

     The car of each METHOD-GROUP-SPECIFIER is a symbol which names a
     variable.  During the execution of the forms in the body of
     ‘define-method-combination’, this variable is bound to a list of
     the methods in the method group.  The methods in this list occur
     in the order specified by the :order option.

     If QUALIFIER-PATTERN is a symbol it must be *.  A method matches a
     QUALIFIER-PATTERN if the method's list of qualifiers is ‘equal’ to
     the QUALIFIER-PATTERN (except that the symbol * in a
     QUALIFIER-PATTERN matches anything).  Thus a QUALIFIER-PATTERN can
     be one of the following: the empty list, which matches unqualified
     methods; the symbol *, which matches all methods; a true list,
     which matches methods with the same number of qualifiers as the
     length of the list when each qualifier matches the corresponding
     list element; or a dotted list that ends in the symbol * (the *
     matches any number of additional qualifiers).

     Each applicable method is tested against the QUALIFIER-PATTERNS and
     PREDICATES in left-to-right order.  As soon as a QUALIFIER-PATTERN
     matches or a PREDICATE returns true, the method becomes a member
     of the corresponding method group and no further tests are made.
     Thus if a method could be a member of more than one method group,
     it joins only the first such group.  If a method group has more
     than one QUALIFIER-PATTERN, a method need only satisfy one of the
     QUALIFIER-PATTERNS to be a member of the group.

     The name of a PREDICATE function can appear instead of
     QUALIFIER-PATTERNS in a method group specifier.  The PREDICATE is
     called for each method that has not been assigned to an earlier
     method group; it is called with one argument, the method's
     qualifier list.  The PREDICATE should return true if the method is
     to be a member of the method group.  A PREDICATE can be
     distinguished from a QUALIFIER-PATTERN because it is a symbol
     other than ‘nil’ or *.

     If there is an applicable method that does not fall into any
     method group, the function ‘invalid-method-error’ is called.

     Method group specifiers can have keyword options following the
     qualifier patterns or predicate.  Keyword options can be
     distinguished from additional qualifier patterns because they are
     neither lists nor the symbol *.  The keyword options are as
     follows:

        * The :description option is used to provide a description of
          the role of methods in the method group.  Programming
          environment tools use ‘(apply #'format stream FORMAT-CONTROL
          (method-qualifiers METHOD))’ to print this description, which
          is expected to be concise.  This keyword option allows the
          description of a method qualifier to be defined in the same
          module that defines the meaning of the method qualifier.  In
          most cases, FORMAT-CONTROL will not contain any ‘format’
          directives, but they are available for generality.  If
          :description is not supplied, a default description is
          generated based on the variable name and the qualifier
          patterns and on whether this method group includes the
          unqualified methods.

        * The :order option specifies the order of methods.  The ORDER
          argument is a form that evaluates to :most-specific-first or
          :most-specific-last.  If it evaluates to any other value, an
          error is signaled.  If :order is not supplied, it defaults to
          :most-specific-first.

        * The :required option specifies whether at least one method in
          this method group is required.  If its value is true and the
          method group is empty (that is, no applicable methods match
          the qualifier patterns or satisfy the predicate), an error is
          signaled.  If :required is not supplied, it defaults to ‘nil’.

     The use of method group specifiers provides a convenient syntax to
     select methods, to divide them among the possible roles, and to
     perform the necessary error checking.  It is possible to perform
     further filtering of methods in the body forms by using normal
     list-processing operations and the functions ‘method-qualifiers’
     and ‘invalid-method-error’.  It is permissible to use ‘setq’ on the
     variables named in the method group specifiers and to bind
     additional variables.  It is also possible to bypass the method
     group specifier mechanism and do everything in the body forms.
     This is accomplished by writing a single method group with * as
     its only QUALIFIER-PATTERN; the variable is then bound to a list
     of all of the applicable methods, in most-specific-first order.

     The body FORMS compute and return the form that specifies how the
     methods are combined, that is, the effective method.  The
     effective method is evaluated in the null lexical environment
     augmented with a local macro definition for ‘call-method’ and with
     bindings named by symbols not accessible from the
     ‘COMMON-LISP-USER’ package.  Given a method object in one of the
     lists produced by the method group specifiers and a list of next
     methods, ‘call-method’ will invoke the method such that
     ‘call-next-method’ has available the next methods.

     When an effective method has no effect other than to call a single
     method, some implementations employ an optimization that uses the
     single method directly as the effective method, thus avoiding the
     need to create a new effective method.  This optimization is
     active when the effective method form consists entirely of an
     invocation of the ‘call-method’ macro whose first subform is a
     method object and whose second subform is ‘nil’ or unsupplied.
     Each ‘define-method-combination’ body is responsible for stripping
     off redundant invocations of ‘progn’, ‘and’,
     ‘multiple-value-prog1’, and the like, if this optimization is
     desired.

     The list ‘(:arguments . LAMBDA-LIST)’ can appear before any
     declarations or documentation string.  This form is useful when
     the method combination type performs some specific behavior as
     part of the combined method and that behavior needs access to the
     arguments to the generic function.  Each parameter variable
     defined by LAMBDA-LIST is bound to a form that can be inserted
     into the effective method.  When this form is evaluated during
     execution of the effective method, its value is the corresponding
     argument to the generic function; the consequences of using such a
     form as the PLACE in a ‘setf’ form are undefined.  Argument
     correspondence is computed by dividing the :arguments LAMBDA-LIST
     and the generic function LAMBDA-LIST into three sections: the
     required parameters, the optional parameters, and the keyword and
     rest parameters.  The arguments supplied to the generic function
     for a particular call are also divided into three sections; the
     required arguments section contains as many arguments as the
     generic function has required parameters, the optional arguments
     section contains as many arguments as the generic function has
     optional parameters, and the keyword/rest arguments section
     contains the remaining arguments.  Each parameter in the required
     and optional sections of the :arguments LAMBDA-LIST accesses the
     argument at the same position in the corresponding section of the
     arguments.  If the section of the :arguments LAMBDA-LIST is
     shorter, extra arguments are ignored.  If the section of the
     :arguments LAMBDA-LIST is longer, excess required parameters are
     bound to forms that evaluate to ‘nil’  and excess optional
     parameters are bound to their initforms.  The keyword parameters
     and rest parameters in the :arguments LAMBDA-LIST access the
     keyword/rest section of the arguments.  If the :arguments
     LAMBDA-LIST contains ‘&key’, it behaves as if it also contained
     ‘&allow-other-keys’.

     In addition, ‘&whole’ VAR can be placed first in the :arguments
     LAMBDA-LIST.  It causes VAR to be bound to a form that evaluates
     to a list of all of the arguments supplied to the generic
     function.  This is different from ‘&rest’ because it accesses all
     of the arguments, not just the keyword/rest arguments.

     Erroneous conditions detected by the body should be reported with
     ‘method-combination-error’ or ‘invalid-method-error’; these
     functions add any necessary contextual information to the error
     message and will signal the appropriate error.

     The body FORMS are evaluated inside of the bindings created by the
     lambda list and method group specifiers.

     Declarations at the head of the body are positioned directly
     inside of bindings created by the lambda list and outside of the
     bindings of the method group variables.  Thus method group
     variables cannot be declared in this way.  ‘locally’ may be used
     around the body, however.

     Within the body FORMS, GENERIC-FUNCTION-SYMBOL is bound to the
     generic function object.

     DOCUMENTATION is attached as a documentation string to NAME (as
     kind ‘method-combination’) and to the method combination object.

     Note that two methods with identical specializers, but with
     different qualifiers, are not ordered by the algorithm described
     in Step 2 of the method selection and combination process
     described in *note Section 7.6.6 (Method Selection and
     Combination): Method Selection and Combination.  Normally the two
     methods play different roles in the effective method because they
     have different qualifiers, and no matter how they are ordered in
     the result of Step 2, the effective method is the same.  If the
     two methods play the same role and their order matters,

     an error is signaled.  This happens as part of the qualifier
     pattern matching in ‘define-method-combination’.

If a ‘define-method-combination’ form appears as a top level form, the
compiler must make the method combination name be recognized as a valid
method combination name in subsequent ‘defgeneric’ forms.  However, the
method combination is executed no earlier than when the
‘define-method-combination’ form is executed, and possibly as late as
the time that generic functions that use the method combination are
executed.

Examples:
.........

Most examples of the long form of ‘define-method-combination’ also
illustrate the use of the related functions that are provided as part
of the declarative method combination facility.

;;; Examples of the short form of define-method-combination

 (define-method-combination and :identity-with-one-argument t)

 (defmethod func and ((x class1) y) ...)

;;; The equivalent of this example in the long form is:

 (define-method-combination and
         (&optional (order :most-specific-first))
         ((around (:around))
          (primary (and) :order order :required t))
   (let ((form (if (rest primary)
                   `(and ,@(mapcar #'(lambda (method)
                                       `(call-method ,method))
                                   primary))
                   `(call-method ,(first primary)))))
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;;; Examples of the long form of define-method-combination

;The default method-combination technique
 (define-method-combination standard ()
         ((around (:around))
          (before (:before))
          (primary () :required t)
          (after (:after)))
   (flet ((call-methods (methods)
            (mapcar #'(lambda (method)
                        `(call-method ,method))
                    methods)))
     (let ((form (if (or before after (rest primary))
                     `(multiple-value-prog1
                        (progn ,@(call-methods before)
                               (call-method ,(first primary)
                                            ,(rest primary)))
                        ,@(call-methods (reverse after)))
                     `(call-method ,(first primary)))))
       (if around
           `(call-method ,(first around)
                         (,@(rest around)
                          (make-method ,form)))
           form))))

;A simple way to try several methods until one returns non-nil
 (define-method-combination or ()
         ((methods (or)))
   `(or ,@(mapcar #'(lambda (method)
                      `(call-method ,method))
                  methods)))

;A more complete version of the preceding
 (define-method-combination or
         (&optional (order ':most-specific-first))
         ((around (:around))
          (primary (or)))
   ;; Process the order argument
   (case order
     (:most-specific-first)
     (:most-specific-last (setq primary (reverse primary)))
     (otherwise (method-combination-error "~S is an invalid order.~@
     :most-specific-first and :most-specific-last are the possible values."
                                          order)))
   ;; Must have a primary method
   (unless primary
     (method-combination-error "A primary method is required."))
   ;; Construct the form that calls the primary methods
   (let ((form (if (rest primary)
                   `(or ,@(mapcar #'(lambda (method)
                                      `(call-method ,method))
                                  primary))
                   `(call-method ,(first primary)))))
     ;; Wrap the around methods around that form
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;The same thing, using the :order and :required keyword options
 (define-method-combination or
         (&optional (order ':most-specific-first))
         ((around (:around))
          (primary (or) :order order :required t))
   (let ((form (if (rest primary)
                   `(or ,@(mapcar #'(lambda (method)
                                      `(call-method ,method))
                                  primary))
                   `(call-method ,(first primary)))))
     (if around
         `(call-method ,(first around)
                       (,@(rest around)
                        (make-method ,form)))
         form)))

;This short-form call is behaviorally identical to the preceding
 (define-method-combination or :identity-with-one-argument t)

;Order methods by positive integer qualifiers
;:around methods are disallowed to keep the example small
 (define-method-combination example-method-combination ()
         ((methods positive-integer-qualifier-p))
   `(progn ,@(mapcar #'(lambda (method)
                         `(call-method ,method))
                     (stable-sort methods #'<
                       :key #'(lambda (method)
                                (first (method-qualifiers method)))))))

 (defun positive-integer-qualifier-p (method-qualifiers)
   (and (= (length method-qualifiers) 1)
        (typep (first method-qualifiers) '(integer 0 *))))

;;; Example of the use of :arguments
 (define-method-combination progn-with-lock ()
         ((methods ()))
   (:arguments object)
   `(unwind-protect
        (progn (lock (object-lock ,object))
               ,@(mapcar #'(lambda (method)
                             `(call-method ,method))
                         methods))
      (unlock (object-lock ,object))))

Side Effects:
.............

The compiler is not required to perform any compile-time side-effects.

Exceptional Situations:
.......................

Method combination types defined with the short form require exactly
one qualifier per method.  An error of type ‘error’ is signaled if
there are applicable methods with no qualifiers or with qualifiers that
are not supported by the method combination type.  At least one primary
method must be applicable or an error of type ‘error’ is signaled.

If an applicable method does not fall into any method group, the system
signals an error of type ‘error’ indicating that the method is invalid
for the kind of method combination in use.

If the value of the :required option is true and the method group is
empty (that is, no applicable methods match the qualifier patterns or
satisfy the predicate), an error of type ‘error’ is signaled.

If the :order option evaluates to a value other than
:most-specific-first or :most-specific-last, an error of type ‘error’
is signaled.

See Also:
.........

*note call-method::, *note call-next-method::, *note documentation::,
*note method-qualifiers::, *note method-combination-error::, *note
invalid-method-error::, *note defgeneric::, *note Section 7.6.6 (Method
Selection and Combination): Method Selection and Combination, *note
Section 7.6.6.4 (Built-in Method Combination Types):
BuiltInMethCombTypes, *note Section 3.4.11 (Syntactic Interaction of
Documentation Strings and Declarations): Syntactic Interaction of
Documentation Strings and Declarations.

Notes:
......

The :method-combination option of ‘defgeneric’ is used to specify that
a generic function should use a particular method combination type.
The first argument to the :method-combination option is the name of a
method combination type and the remaining arguments are options for
that type.


File: ansicl,  Node: find-method,  Next: add-method,  Prev: define-method-combination,  Up: Objects

find-method (Standard Generic Function)
=======================================

Syntax:
.......

 -- Generic Function: find-method generic-function method-qualifiers
          specializers &optional errorp → method

Method Signatures:
..................

find-method (GENERIC-FUNCTION ‘standard-generic-function’)
method-qualifiers specializers &optional errorp

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function.

METHOD-QUALIFIERS--a list.

SPECIALIZERS--a list.

ERRORP--a generalized boolean.  The default is true.

METHOD--a method object, or ‘nil’.

Description:
............

The generic function ‘find-method’ takes a generic function and returns
the method object that agrees on qualifiers and parameter specializers
with the METHOD-QUALIFIERS and SPECIALIZERS arguments of ‘find-method’.
METHOD-QUALIFIERS  contains the method qualifiers for the method.  The
order of the method qualifiers is significant.  For a definition of
agreement in this context, see *note Section 7.6.3 (Agreement on
Parameter Specializers and Qualifiers): Agreement on Parameter
Specializers and Qualifiers.

The SPECIALIZERS argument contains the parameter specializers for the
method. It must correspond in length to the number of required
arguments of the generic function, or an error is signaled.  This means
that to obtain the default method on a given GENERIC-FUNCTION, a list
whose elements are the class ‘t’ must be given.

If there is no such method and ERRORP is true, ‘find-method’ signals an
error.  If there is no such method and ERRORP is false, ‘find-method’
returns ‘nil’.

Examples:
.........

 (defmethod some-operation ((a integer) (b float)) (list a b))
→ #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
 (find-method #'some-operation '() (mapcar #'find-class '(integer float)))
→ #<STANDARD-METHOD SOME-OPERATION (INTEGER FLOAT) 26723357>
 (find-method #'some-operation '() (mapcar #'find-class '(integer integer)))
▷ Error: No matching method
 (find-method #'some-operation '() (mapcar #'find-class '(integer integer)) nil)
→ NIL

Affected By:
............

‘add-method’, ‘defclass’, ‘defgeneric’, ‘defmethod’

Exceptional Situations:
.......................

If the SPECIALIZERS argument does not correspond in length to the
number of required arguments of the GENERIC-FUNCTION, an an error of
type ‘error’ is signaled.

If there is no such method and ERRORP is true, ‘find-method’ signals an
error of type ‘error’.

See Also:
.........

*note Section 7.6.3 (Agreement on Parameter Specializers and
Qualifiers): Agreement on Parameter Specializers and Qualifiers.


File: ansicl,  Node: add-method,  Next: initialize-instance (Standard Generic Function),  Prev: find-method,  Up: Objects

add-method (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: add-method generic-function method →
          generic-function

Method Signatures:
..................

add-method (GENERIC-FUNCTION ‘standard-generic-function’)
(METHOD ‘method’)

Arguments and Values:
.....................

GENERIC-FUNCTION--a generic function object.

METHOD--a method object.

Description:
............

The generic function ‘add-method’ adds a method to a generic function.

If METHOD agrees with an existing method of GENERIC-FUNCTION on
parameter specializers and qualifiers, the existing method is replaced.

Exceptional Situations:
.......................

The lambda list of the method function of METHOD must be congruent with
the lambda list of GENERIC-FUNCTION, or an error of type ‘error’ is
signaled.

If METHOD is a method object of another generic function, an error of
type ‘error’ is signaled.

See Also:
.........

*note defmethod::, *note defgeneric::, *note find-method::, *note
remove-method::, *note Section 7.6.3 (Agreement on Parameter
Specializers and Qualifiers): Agreement on Parameter Specializers and
Qualifiers.


File: ansicl,  Node: initialize-instance (Standard Generic Function),  Next: class-name,  Prev: add-method,  Up: Objects

initialize-instance (Standard Generic Function)
===============================================

Syntax:
.......

 -- Generic Function: initialize-instance instance &rest initargs &key
          &allow-other-keys → instance

Method Signatures:
..................

initialize-instance (INSTANCE ‘standard-object’) &rest initargs

Arguments and Values:
.....................

INSTANCE--an object.

INITARGS--a defaulted initialization argument list.

Description:
............

Called by ‘make-instance’ to initialize a newly created instance.  The
generic function is called with the new INSTANCE and the defaulted
initialization argument list.

The system-supplied primary method on ‘initialize-instance’ initializes
the slots of the INSTANCE with values according to the INITARGS and the
:initform forms of the slots.  It does this by calling the generic
function ‘shared-initialize’ with the following arguments: the
INSTANCE, ‘t’ (this indicates that all slots for which no
initialization arguments are provided should be initialized according
to their :initform forms), and the INITARGS.

Programmers can define methods for ‘initialize-instance’ to specify
actions to be taken when an instance is initialized.  If only after
methods are defined, they will be run after the system-supplied primary
method for initialization and therefore will not interfere with the
default behavior of ‘initialize-instance’.

See Also:
.........

*note shared-initialize (Standard Generic Function)::, *note
make-instance::, *note slot-boundp::, *note slot-makunbound::, *note
Section 7.1 (Object Creation and Initialization): Object Creation and
Initialization, *note Section 7.1.4 (Rules for Initialization
Arguments): Rules for Initialization Arguments, *note Section 7.1.2
(Declaring the Validity of Initialization Arguments): Declaring the
Validity of Initialization Arguments.


File: ansicl,  Node: class-name,  Next: setf class-name,  Prev: initialize-instance (Standard Generic Function),  Up: Objects

class-name (Standard Generic Function)
======================================

Syntax:
.......

 -- Generic Function: class-name class → name

Method Signatures:
..................

class-name (CLASS ‘class’)

Arguments and Values:
.....................

CLASS--a class object.

NAME--a symbol.

Description:
............

Returns the name of the given CLASS.

See Also:
.........

*note find-class::, *note Section 4.3 (Classes): Classes.

Notes:
......

If S is a symbol such that S =‘(class-name C)’ and C =‘(find-class S)’,
then S is the proper name of C.  For further discussion, see *note
Section 4.3 (Classes): Classes.

The name of an anonymous class is ‘nil’.


File: ansicl,  Node: setf class-name,  Next: class-of,  Prev: class-name,  Up: Objects

(setf class-name) (Standard Generic Function)
=============================================

Syntax:
.......

 -- Generic Function: (setf class-name) new-value class → new-value

Method Signatures:
..................

(setf class-name) new-value (CLASS ‘class’)

Arguments and Values:
.....................

NEW-VALUE--a symbol.

CLASS--a class.

Description:
............

The generic function ‘(setf class-name)’ sets the name of a CLASS
object.

See Also:
.........

*note find-class::, proper name, *note Section 4.3 (Classes): Classes.


File: ansicl,  Node: class-of,  Next: unbound-slot,  Prev: setf class-name,  Up: Objects

class-of (Function)
===================

Syntax:
.......

 -- Function: class-of object → class

Arguments and Values:
.....................

OBJECT--an object.

CLASS--a class object.

Description:
............

Returns the class of which the OBJECT is a direct instance.

Examples:
.........

 (class-of 'fred) → #<BUILT-IN-CLASS SYMBOL 610327300>
 (class-of 2/3) → #<BUILT-IN-CLASS RATIO 610326642>

 (defclass book () ()) → #<STANDARD-CLASS BOOK 33424745>
 (class-of (make-instance 'book)) → #<STANDARD-CLASS BOOK 33424745>

 (defclass novel (book) ()) → #<STANDARD-CLASS NOVEL 33424764>
 (class-of (make-instance 'novel)) → #<STANDARD-CLASS NOVEL 33424764>

 (defstruct kons kar kdr) → KONS
 (class-of (make-kons :kar 3 :kdr 4)) → #<STRUCTURE-CLASS KONS 250020317>

See Also:
.........

*note make-instance::, *note type-of::


File: ansicl,  Node: unbound-slot,  Next: unbound-slot-instance,  Prev: class-of,  Up: Objects

unbound-slot (Condition Type)
=============================

Class Precedence List:
......................

‘unbound-slot’, ‘cell-error’, ‘error’, ‘serious-condition’, ‘condition’,
‘t’

Description:
............

The object having the unbound slot is initialized by the :instance
initialization argument to ‘make-condition’, and is accessed by the
function ‘unbound-slot-instance’.

The name of the cell (see ‘cell-error’) is the name of the slot.

See Also:
.........

*note cell-error-name::, *note unbound-slot-instance::, *note Section
9.1 (Condition System Concepts): Condition System Concepts.


File: ansicl,  Node: unbound-slot-instance,  Prev: unbound-slot,  Up: Objects

unbound-slot-instance (Function)
================================

Syntax:
.......

 -- Function: unbound-slot-instance condition → instance

Arguments and Values:
.....................

CONDITION--a condition of type ‘unbound-slot’.

INSTANCE--an object.

Description:
............

Returns the instance which had the unbound slot in the situation
represented by the CONDITION.

See Also:
.........

*note cell-error-name::, *note unbound-slot::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.


File: ansicl,  Node: Structures,  Next: Conditions,  Prev: Objects,  Up: Top

8 Structures
************

* Menu:


Dictionary

* defstruct::
* copy-structure::


File: ansicl,  Node: defstruct,  Next: copy-structure,  Up: Structures

defstruct (Macro)
=================

Syntax:
.......

 -- Macro: defstruct name-and-options [documentation]
          {↓slot-description}* → structure-name

NAME-AND-OPTIONS::=
     structure-name | (structure-name 〚↓options〛)

OPTIONS::=
     ↓conc-name-option |
     {↓constructor-option}* |
     ↓copier-option |
     ↓include-option |
     ↓initial-offset-option |
     ↓named-option |
     ↓predicate-option |
     ↓printer-option |
     ↓type-option

CONC-NAME-OPTION::=
     :conc-name | (:conc-name) | (:conc-name CONC-NAME)

CONSTRUCTOR-OPTION::=
     :constructor |
     (:constructor) |
     (:constructor CONSTRUCTOR-NAME) |
     (:constructor CONSTRUCTOR-NAME CONSTRUCTOR-ARGLIST)

COPIER-OPTION::=
     :copier | (:copier) | (:copier COPIER-NAME)

PREDICATE-OPTION::=
     :predicate | (:predicate) | (:predicate PREDICATE-NAME)

INCLUDE-OPTION::=
     (:include INCLUDED-STRUCTURE-NAME {↓slot-description}*)

PRINTER-OPTION::=
     ↓print-object-option | ↓print-function-option

PRINT-OBJECT-OPTION::=
     (:print-object PRINTER-NAME) | (:print-object)

PRINT-FUNCTION-OPTION::=
     (:print-function PRINTER-NAME) | (:print-function)

TYPE-OPTION::=
     (:type TYPE)

NAMED-OPTION::=
     :named

INITIAL-OFFSET-OPTION::=
     (:initial-offset INITIAL-OFFSET)

SLOT-DESCRIPTION::=
     SLOT-NAME |
     (SLOT-NAME [SLOT-INITFORM 〚↓slot-option〛])

SLOT-OPTION::=
     :type SLOT-TYPE |
     :read-only SLOT-READ-ONLY-P

Arguments and Values:
.....................

CONC-NAME--a string designator.

CONSTRUCTOR-ARGLIST--a boa lambda list.

CONSTRUCTOR-NAME--a symbol.

COPIER-NAME--a symbol.

INCLUDED-STRUCTURE-NAME--an already-defined structure name.  Note that
a derived type is not permissible, even if it would expand into a
structure name.

INITIAL-OFFSET--a non-negative integer.

PREDICATE-NAME--a symbol.

PRINTER-NAME--a function name or a lambda expression.

SLOT-NAME--a symbol.

SLOT-INITFORM--a form.

SLOT-READ-ONLY-P--a generalized boolean.

STRUCTURE-NAME--a symbol.

TYPE--one of the type specifiers ‘list’, ‘vector’, or ‘(vector SIZE)’,
or some other type specifier defined by the implementation to be
appropriate.

DOCUMENTATION--a string; not evaluated.

Description:
............

‘defstruct’ defines a structured type, named STRUCTURE-TYPE, with named
slots as specified by the SLOT-OPTIONS.

‘defstruct’ defines readers for the slots and arranges for ‘setf’ to
work properly on such reader functions.  Also, unless overridden, it
defines a predicate named ‘NAME-p’, defines a constructor function
named ‘make-CONSTRUCTOR-NAME’, and defines a copier function named
‘copy-CONSTRUCTOR-NAME’.  All names of automatically created functions
might automatically be declared ‘inline’ (at the discretion of the
implementation).

If DOCUMENTATION is supplied, it is attached to STRUCTURE-NAME as a
documentation string of kind structure, and unless :type is used, the
DOCUMENTATION is also attached to STRUCTURE-NAME as a documentation
string of kind type and as a documentation string to the class object
for the class named STRUCTURE-NAME.

‘defstruct’ defines a constructor function that is used to create
instances of the structure created by ‘defstruct’.  The default name is
‘make-STRUCTURE-NAME’.  A different name can be supplied by giving the
name as the argument to the CONSTRUCTOR option.  ‘nil’ indicates that
no constructor function will be created.

After a new structure type has been defined, instances of that type
normally can be created by using the constructor function for the type.
A call to a constructor function is of the following form:

 (constructor-function-name
  slot-keyword1 form-1
  slot-keyword2 form-2
  ...)

The arguments to the constructor function are all keyword arguments.
Each slot keyword argument must  be a keyword whose name corresponds to
the name of a structure slot.  All the KEYWORDS and FORMS are evaluated.
If a slot is not initialized in this way, it is initialized by
evaluating SLOT-INITFORM in the slot description at the time the
constructor function is called.  If no SLOT-INITFORM is supplied, the
consequences are undefined if an attempt is later made to read the
slot's value before a value is explicitly assigned.

Each SLOT-INITFORM supplied for a ‘defstruct’ component, when used by
the constructor function for an otherwise unsupplied component, is
re-evaluated on every call to the constructor function.  The
SLOT-INITFORM is not evaluated unless it is needed in the creation of a
particular structure instance.  If it is never needed, there can be no
type-mismatch error, even if the type of the slot is specified; no
warning should be issued in this case.  For example, in the following
sequence, only the last call is an error.

 (defstruct person (name 007 :type string))
 (make-person :name "James")
 (make-person)

It is as if the SLOT-INITFORMS were used as initialization forms for
the keyword parameters of the constructor function.

The symbols which name the slots must not be used by the implementation
as the names for the lambda variables in the constructor function,
since one or more of those symbols might have been proclaimed ‘special’
or might be defined as the name of a constant variable.  The slot
default init forms are evaluated in the lexical environment in which
the ‘defstruct’ form itself appears and in the dynamic environment in
which the call to the constructor function appears.

For example, if the form ‘(gensym)’ were used as an initialization form,
either in the constructor-function call or as the default
initialization form in ‘defstruct’, then every call to the constructor
function would call ‘gensym’ once to generate a new symbol.

Each SLOT-DESCRIPTION in ‘defstruct’ can specify zero or more
SLOT-OPTIONS.  A SLOT-OPTION consists of a pair of a keyword and a value
(which is not a form to be evaluated, but the value itself).  For
example:

 (defstruct ship
   (x-position 0.0 :type short-float)
   (y-position 0.0 :type short-float)
   (x-velocity 0.0 :type short-float)
   (y-velocity 0.0 :type short-float)
   (mass *default-ship-mass* :type short-float :read-only t))

This specifies that each slot always contains a short float, and that
the last slot cannot be altered once a ship is constructed.

The available slot-options are:

‘:type TYPE’
     This specifies that the contents of the slot is always of type
     TYPE.  This is entirely analogous to the declaration of a variable
     or function; it effectively declares the result type of the reader
     function.  It is implementation-dependent whether the type is
     checked when initializing a slot or when assigning to it.  TYPE is
     not evaluated; it must be a valid type specifier.

‘:read-only X’
     When X is true, this specifies that this slot cannot be altered;
     it will always contain the value supplied at construction time.
     ‘setf’ will not accept the reader function for this slot.  If X is
     false, this slot-option has no effect.  X is not evaluated.

     When this option is false or unsupplied, it is
     implementation-dependent whether the ability to write the slot is
     implemented by a setf function or a setf expander.

The following keyword options are available for use with ‘defstruct’.
A ‘defstruct’ option can be either a keyword or a list of a keyword and
arguments for that keyword; specifying the keyword by itself is
equivalent to specifying a list consisting of the keyword and no
arguments.  The syntax for ‘defstruct’ options differs from the pair
syntax used for slot-options.  No part of any of these options is
evaluated.

:conc-name
     This provides for automatic prefixing of names of reader (or
     access) functions.  The default behavior is to begin the names of
     all the reader functions of a structure with the name of the
     structure followed by a hyphen.

     :conc-name supplies an alternate prefix to be used.  If a hyphen
     is to be used as a separator, it must be supplied as part of the
     prefix.  If :conc-name is ‘nil’ or no argument is supplied, then
     no prefix is used; then the names of the reader functions are the
     same as the slot names.  If a non-nil prefix is given, the name of
     the reader function for each slot is constructed by concatenating
     that prefix and the name of the slot, and interning the resulting
     symbol in the package that is current at the time the ‘defstruct’
     form is expanded.

     Note that no matter what is supplied for :conc-name, slot keywords
     that match the slot names with no prefix attached are used with a
     constructor function.  The reader function name is used in
     conjunction with ‘setf’.  Here is an example:

      (defstruct (door (:conc-name dr-)) knob-color width material) → DOOR
      (setq my-door (make-door :knob-color 'red :width 5.0))
     → #S(DOOR :KNOB-COLOR RED :WIDTH 5.0 :MATERIAL NIL)
      (dr-width my-door) → 5.0
      (setf (dr-width my-door) 43.7) → 43.7
      (dr-width my-door) → 43.7

     Whether or not the :conc-name option is explicitly supplied, the
     following rule governs name conflicts of generated reader (or
     accessor) names: For any structure type S₁ having a reader
     function named R for a slot named X₁ that is inherited by another
     structure type S₂ that would have a reader function with the same
     name R for a slot named X₂, no definition for R is generated by
     the definition of S₂; instead, the definition of R is inherited
     from the definition of S₁.  (In such a case, if X₁ and X₂ are
     different slots, the implementation might signal a style warning.)

:constructor
     This option takes zero, one, or two arguments.  If at least one
     argument is supplied and the first argument is not ‘nil’, then
     that argument is a symbol which specifies the name of the
     constructor function.  If the argument is not supplied (or if the
     option itself is not supplied), the name of the constructor is
     produced by concatenating the string ‘"MAKE-"’ and the name of the
     structure, interning the name in whatever package is current at
     the time ‘defstruct’ is expanded.  If the argument is provided and
     is ‘nil’, no constructor function is defined.

     If :constructor is given as ‘(:constructor NAME ARGLIST)’, then
     instead of making a keyword driven constructor function,
     ‘defstruct’ defines a "positional" constructor function, taking
     arguments whose meaning is determined by the argument's position
     and possibly by keywords.  ARGLIST is used to describe what the
     arguments to the constructor will be. In the simplest case
     something like ‘(:constructor make-foo (a b c))’ defines
     ‘make-foo’ to be a three-argument constructor function whose
     arguments are used to initialize the slots named ‘a’, ‘b’, and ‘c’.

     Because a constructor of this type operates "By Order of
     Arguments," it is sometimes known as a "boa constructor."

     For information on how the ARGLIST for a "boa constructor" is
     processed, see *note Section 3.4.6 (Boa Lambda Lists): Boa Lambda
     Lists.

     It is permissible to use the :constructor option more than once,
     so that you can define several different constructor functions,
     each taking different parameters.

     ‘defstruct’ creates the default-named keyword constructor function
     only if no explicit :constructor options are specified, or if the
     :constructor option is specified without a NAME argument.

     ‘(:constructor nil)’ is meaningful only when there are no other
     :constructor options specified.  It prevents ‘defstruct’ from
     generating any constructors at all.

     Otherwise, ‘defstruct’ creates a constructor function corresponding
     to each supplied :constructor option.  It is permissible to specify
     multiple keyword constructor functions as well as multiple "boa
     constructors".

:copier
     This option takes one argument, a symbol, which specifies the name
     of the copier function.  If the argument is not provided or if the
     option itself is not provided, the name of the copier is produced
     by concatenating the string ‘"COPY-"’ and the name of the
     structure, interning the name in whatever package is current at
     the time ‘defstruct’ is expanded.  If the argument is provided and
     is ‘nil’, no copier function is defined.

     The automatically defined copier function is a function of one
     argument, which must be of the structure type being defined.  The
     copier function creates a fresh structure that has the same type
     as its argument, and that has the same component values as the
     original structure; that is, the component values are not copied
     recursively.  If the ‘defstruct’ :type option was not used, the
     following equivalence applies:

      (COPIER-NAME x) = (copy-structure (the STRUCTURE-NAME x))

:include
     This option is used for building a new structure definition as an
     extension of another structure definition.  For example:

      (defstruct person name age sex)

     To make a new structure to represent an astronaut that has the
     attributes of name, age, and sex, and functions that operate on
     ‘person’ structures, ‘astronaut’ is defined with :include as
     follows:

      (defstruct (astronaut (:include person)
                            (:conc-name astro-))
         helmet-size
         (favorite-beverage 'tang))

     :include causes the structure being defined to have the same slots
     as the included structure.  This is done in such a way that the
     reader functions for the included structure also work on the
     structure being defined.  In this example, an ‘astronaut’
     therefore has five slots: the three defined in ‘person’ and the
     two defined in ‘astronaut’ itself.  The reader functions defined
     by the ‘person’ structure can be applied to instances of the
     ‘astronaut’ structure, and they work correctly.  Moreover,
     ‘astronaut’ has its own reader functions for components defined by
     the ‘person’ structure.  The following examples illustrate the use
     of ‘astronaut’ structures:

      (setq x (make-astronaut :name 'buzz
                              :age 45.
                              :sex t
                              :helmet-size 17.5))
      (person-name x) → BUZZ
      (astro-name x) → BUZZ
      (astro-favorite-beverage x) → TANG

      (reduce #'+ astros :key #'person-age) ; obtains the total of the ages
                                            ; of the possibly empty
                                            ; sequence of astros

     The difference between the reader functions ‘person-name’ and
     ‘astro-name’ is that ‘person-name’ can be correctly applied to any
     ‘person’, including an ‘astronaut’, while ‘astro-name’ can be
     correctly applied only to an ‘astronaut’.  An implementation might
     check for incorrect use of reader functions.

     At most one :include can be supplied in a single ‘defstruct’.  The
     argument to :include is required and must be the name of some
     previously defined structure.  If the structure being defined has
     no :type option, then the included structure must also have had no
     :type option supplied for it.  If the structure being defined has
     a :type option, then the included structure must have been
     declared with a :type option specifying the same representation
     type.

     If no :type option is involved, then the structure name of the
     including structure definition becomes the name of a data type,
     and therefore a valid type specifier recognizable by ‘typep’; it
     becomes a subtype of the included structure.  In the above example,
     ‘astronaut’ is a subtype of ‘person’; hence

      (typep (make-astronaut) 'person) → true

     indicating that all operations on persons also work on astronauts.

     The structure using :include can specify default values or
     slot-options for the included slots different from those the
     included structure specifies, by giving the :include option as:

      (:include INCLUDED-STRUCTURE-NAME {slot-description}*)

     Each SLOT-DESCRIPTION must have a SLOT-NAME that is the same as
     that of some slot in the included structure.  If a
     SLOT-DESCRIPTION has no SLOT-INITFORM, then in the new structure
     the slot has no initial value.  Otherwise its initial value form
     is replaced by the SLOT-INITFORM in the SLOT-DESCRIPTION.  A
     normally writable slot can be made read-only.  If a slot is
     read-only in the included structure, then it must also be so in
     the including structure.  If a type is supplied for a slot, it
     must be a subtype of the type specified in the included structure.

     For example, if the default age for an astronaut is ‘45’, then

      (defstruct (astronaut (:include person (age 45)))
         helmet-size
         (favorite-beverage 'tang))

     If :include is used with the :type option, then the effect is
     first to skip over as many representation elements as needed to
     represent the included structure, then to skip over any additional
     elements supplied by the :initial-offset option, and then to begin
     allocation of elements from that point.  For example:

      (defstruct (binop (:type list) :named (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) → BINOP
      (defstruct (annotated-binop (:type list)
                                  (:initial-offset 3)
                                  (:include binop))
       commutative associative identity) → ANNOTATED-BINOP
      (make-annotated-binop :operator '*
                            :operand-1 'x
                            :operand-2 5
                            :commutative t
                            :associative t
                            :identity 1)
        → (NIL NIL BINOP * X 5 NIL NIL NIL T T 1)

     The first two ‘nil’ elements stem from the :initial-offset of ‘2’
     in the definition of ‘binop’.  The next four elements contain the
     structure name and three slots for ‘binop’.  The next three
     ‘nil’ elements stem from the :initial-offset of ‘3’ in the
     definition of ‘annotated-binop’.  The last three list elements
     contain the additional slots for an ‘annotated-binop’.

:initial-offset
     :initial-offset instructs ‘defstruct’ to skip over a certain
     number of slots before it starts allocating the slots described in
     the body.  This option's argument is the number of slots
     ‘defstruct’ should skip.  :initial-offset can be used only if
     :type is also supplied.

     :initial-offset allows slots to be allocated beginning at a
     representational element other than the first.  For example, the
     form

      (defstruct (binop (:type list) (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) → BINOP

     would result in the following behavior for ‘make-binop’:

      (make-binop :operator '+ :operand-1 'x :operand-2 5)
     → (NIL NIL + X 5)
      (make-binop :operand-2 4 :operator '*)
     → (NIL NIL * NIL 4)

     The selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’ would be essentially equivalent to ‘third’,
     ‘fourth’, and ‘fifth’, respectively.  Similarly, the form

      (defstruct (binop (:type list) :named (:initial-offset 2))
        (operator '? :type symbol)
        operand-1
        operand-2) → BINOP

     would result in the following behavior for ‘make-binop’:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) → (NIL NIL BINOP + X 5)
      (make-binop :operand-2 4 :operator '*) → (NIL NIL BINOP * NIL 4)

     The first two ‘nil’ elements stem from the :initial-offset of ‘2’
     in the definition of ‘binop’.  The next four elements contain the
     structure name and three slots for ‘binop’.

:named
     :named specifies that the structure is named.  If no :type is
     supplied, then the structure is always named.

     For example:

      (defstruct (binop (:type list))
        (operator '? :type symbol)
        operand-1
        operand-2) → BINOP

     This defines a constructor function ‘make-binop’ and three
     selector functions, namely ‘binop-operator’, ‘binop-operand-1’,
     and ‘binop-operand-2’.  (It does not, however, define a predicate
     ‘binop-p’, for reasons explained below.)

     The effect of ‘make-binop’ is simply to construct a list of length
     three:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) → (+ X 5)
      (make-binop :operand-2 4 :operator '*) → (* NIL 4)

     It is just like the function ‘list’ except that it takes keyword
     arguments and performs slot defaulting appropriate to the ‘binop’
     conceptual data type.  Similarly, the selector functions
     ‘binop-operator’, ‘binop-operand-1’, and ‘binop-operand-2’ are
     essentially equivalent to ‘car’, ‘cadr’, and ‘caddr’,
     respectively.  They might not be completely equivalent because,
     for example, an implementation would be justified in adding
     error-checking code to ensure that the argument to each selector
     function is a length-3 list.

     ‘binop’ is a conceptual data type in that it is not made a part of
     the Common Lisp type system.  ‘typep’ does not recognize ‘binop’ as
     a type specifier, and ‘type-of’ returns ‘list’ when given a
     ‘binop’ structure.  There is no way to distinguish a data
     structure constructed by ‘make-binop’ from any other list that
     happens to have the correct structure.

     There is not any way to recover the structure name ‘binop’ from a
     structure created by ‘make-binop’.  This can only be done if the
     structure is named.  A named structure has the property that,
     given an instance of the structure, the structure name (that names
     the type) can be reliably recovered.  For structures defined with
     no :type option, the structure name actually becomes part of the
     Common Lisp data-type system.  ‘type-of’, when applied to such a
     structure, returns the structure name as the type of the object;
     ‘typep’ recognizes the structure name as a valid type specifier.

     For structures defined with a :type option, ‘type-of’ returns a
     type specifier such as ‘list’ or ‘(vector t)’, depending on the
     type supplied to the :type option.  The structure name does not
     become a valid type specifier.  However, if the :named option is
     also supplied, then the first component of the structure (as
     created by a ‘defstruct’ constructor function) always contains the
     structure name.  This allows the structure name to be recovered
     from an instance of the structure and allows a reasonable
     predicate for the conceptual type to be defined: the automatically
     defined NAME-P predicate for the structure operates by first
     checking that its argument is of the proper type (‘list’, ‘(vector
     t)’, or whatever) and then checking whether the first component
     contains the appropriate type name.

     Consider the ‘binop’ example shown above, modified only to include
     the :named option:

      (defstruct (binop (:type list) :named)
        (operator '? :type symbol)
        operand-1
        operand-2) → BINOP

     As before, this defines a constructor function ‘make-binop’ and
     three selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’.  It also defines a predicate ‘binop-p’.  The
     effect of ‘make-binop’ is now to construct a list of length four:

      (make-binop :operator '+ :operand-1 'x :operand-2 5) → (BINOP + X 5)
      (make-binop :operand-2 4 :operator '*) → (BINOP * NIL 4)

     The structure has the same layout as before except that the
     structure name ‘binop’ is included as the first list element.  The
     selector functions ‘binop-operator’, ‘binop-operand-1’, and
     ‘binop-operand-2’ are essentially equivalent to ‘cadr’, ‘caddr’,
     and ‘cadddr’, respectively.  The predicate ‘binop-p’ is more or
     less equivalent to this definition:

      (defun binop-p (x)
        (and (consp x) (eq (car x) 'binop))) → BINOP-P

     The name ‘binop’ is still not a valid type specifier recognizable
     to ‘typep’, but at least there is a way of distinguishing ‘binop’
     structures from other similarly defined structures.

:predicate
     This option takes one argument, which specifies the name of the
     type predicate.  If the argument is not supplied or if the option
     itself is not supplied, the name of the predicate is made by
     concatenating the name of the structure to the string ‘"-P"’,
     interning the name in whatever package is current at the time
     ‘defstruct’ is expanded.  If the argument is provided and is
     ‘nil’, no predicate is defined.  A predicate can be defined only
     if the structure is named; if :type is supplied and :named is not
     supplied, then :predicate must either be unsupplied or have the
     value ‘nil’.

:print-function, :print-object
     The :print-function and :print-object options specify that a
     ‘print-object’ method for structures of type STRUCTURE-NAME should
     be generated.  These options are not synonyms, but do perform a
     similar service; the choice of which option (:print-function or
     :print-object) is used affects how the function named PRINTER-NAME
     is called.  Only one of these options may be used, and these
     options may be used only if :type is not supplied.

     If the :print-function option is used, then when a structure of
     type STRUCTURE-NAME is to be printed, the designated printer
     function is called on three arguments:

        - the structure to be printed (a generalized instance of
          STRUCTURE-NAME).

        - a stream to print to.

        - an integer indicating the current depth.  The magnitude of
          this integer may vary between implementations; however, it
          can reliably be compared against ‘*print-level*’ to determine
          whether depth abbreviation is appropriate.

     Specifying ‘(:print-function PRINTER-NAME)’ is approximately
     equivalent to specifying:

      (defmethod print-object ((object STRUCTURE-NAME) stream)
        (funcall (function PRINTER-NAME) object stream «CURRENT-PRINT-DEPTH»))

     where the «CURRENT-PRINT-DEPTH» represents the printer's belief of
     how deep it is currently printing.  It is implementation-dependent
     whether «CURRENT-PRINT-DEPTH» is always 0 and *PRINT-LEVEL*, if
     non-nil, is re-bound to successively smaller values as printing
     descends recursively, or whether CURRENT-PRINT-DEPTH varies in
     value as printing descends recursively and *PRINT-LEVEL* remains
     constant during the same traversal.

     If the :print-object option is used, then when a structure of type
     STRUCTURE-NAME is to be printed, the designated printer function
     is called on two arguments:

        - the structure to be printed.

        - the stream to print to.

     Specifying ‘(:print-object PRINTER-NAME)’ is equivalent to
     specifying:

      (defmethod print-object ((object STRUCTURE-NAME) stream)
        (funcall (function PRINTER-NAME) object stream))

     If no :type option is supplied, and if either a :print-function or
     a :print-object option is supplied, and if no PRINTER-NAME is
     supplied, then a ‘print-object’ method specialized for
     STRUCTURE-NAME is generated that calls a function that implements
     the default printing behavior for structures using ‘#S’ notation;
     see *note Section 22.1.3.12 (Printing Structures):
     PrintingStructures.

     If neither a :print-function nor a :print-object option is
     supplied, then ‘defstruct’ does not generate a ‘print-object’
     method specialized for STRUCTURE-NAME and some default behavior is
     inherited either from a structure named in an :include option or
     from the default behavior for printing structures; see the
     function *note print-object:: and *note Section 22.1.3.12
     (Printing Structures): PrintingStructures.

     When ‘*print-circle*’ is true, a user-defined print function can
     print objects to the supplied stream using ‘write’, ‘prin1’,
     ‘princ’, or ‘format’ and expect circularities to be detected and
     printed using the ‘#n#’ syntax.  This applies to methods on
     ‘print-object’ in addition to :print-function options.  If a
     user-defined print function prints to a stream other than the one
     that was supplied, then circularity detection starts over for that
     stream.  See the variable *note *print-circle*::.

:type
     :type explicitly specifies the representation to be used for the
     structure.  Its argument must be one of these types:

    ‘vector’
          This produces the same result as specifying ‘(vector t)’.
          The structure is represented as a general vector, storing
          components as vector elements.  The first component is vector
          element 1 if the structure is :named, and element 0 otherwise.

    ‘(vector ELEMENT-TYPE)’
          The structure is represented as a (possibly specialized)
          vector, storing components as vector elements.  Every
          component must be of a type that can be stored in a vector of
          the type specified.  The first component is vector element 1
          if the structure is :named, and element 0 otherwise.  The
          structure can be :named only if the type ‘symbol’ is a
          subtype of the supplied ELEMENT-TYPE.

    ‘list’
          The structure is represented as a list.  The first component
          is the cadr if the structure is :named, and the car if it is
          not :named.

     Specifying this option has the effect of forcing a specific
     representation and of forcing the components to be stored in the
     order specified in ‘defstruct’ in corresponding successive
     elements of the specified representation.  It also prevents the
     structure name from becoming a valid type specifier recognizable
     by ‘typep’.

     For example:

      (defstruct (quux (:type list) :named) x y)

     should make a constructor that builds a list exactly like the one
     that ‘list’ produces, with ‘quux’ as its car.

     If this type is defined:

      (deftype quux () '(satisfies quux-p))

     then this form

      (typep (make-quux) 'quux)

     should return precisely what this one does

      (typep (list 'quux nil nil) 'quux)

     If :type is not supplied, the structure is represented as an
     object of type ‘structure-object’.

     ‘defstruct’ without a :type option defines a class with the
     structure name as its name. The metaclass of structure instances
     is ‘structure-class’.

The consequences of redefining a ‘defstruct’ structure are undefined.

In the case where no ‘defstruct’ options have been supplied, the
following functions are automatically defined to operate on instances
of the new structure:

Predicate
     A predicate with the name ‘STRUCTURE-NAME-p’ is defined to test
     membership in the structure type.  The predicate
     ‘(STRUCTURE-NAME-p OBJECT)’ is true if an OBJECT is of this type;
     otherwise it is false.  ‘typep’ can also be used with the name of
     the new type to test whether an object belongs to the type.  Such
     a function call has the form ‘(typep OBJECT 'STRUCTURE-NAME)’.

Component reader functions
     Reader functions are defined to read the components of the
     structure.  For each slot name, there is a corresponding reader
     function with the name ‘STRUCTURE-NAME-SLOT-NAME’.  This function
     reads the contents of that slot.  Each reader function takes one
     argument, which is an instance of the structure type.  ‘setf’ can
     be used with any of these reader functions to alter the slot
     contents.

Constructor function
     A constructor function with the name ‘make-STRUCTURE-NAME’ is
     defined.  This function creates and returns new instances of the
     structure type.

Copier function
     A copier function with the name ‘copy-STRUCTURE-NAME’ is defined.
     The copier function takes an object of the structure type and
     creates a new object of the same  type that is a copy of the
     first.  The copier function creates a new structure with the same
     component entries as the original.  Corresponding components of
     the two structure instances are ‘eql’.

If a ‘defstruct’ form appears as a top level form, the compiler must
make the structure type name recognized as a valid type name in
subsequent declarations (as for ‘deftype’) and make the structure slot
readers known to ‘setf’.  In addition, the compiler must save enough
information about the structure type so that further ‘defstruct’
definitions can use :include in a subsequent ‘deftype’ in the same file
to refer to the structure type name.  The functions which ‘defstruct’
generates are not defined in the compile time environment, although the
compiler may save enough information about the functions to code
subsequent calls inline.  The ‘#S’ reader macro might or might not
recognize the newly defined structure type name at compile time.

Examples:
.........

An example of a structure definition follows:

 (defstruct ship
   x-position
   y-position
   x-velocity
   y-velocity
   mass)

This declares that every ‘ship’ is an object with five named components.
The evaluation of this form does the following:

  1. It defines ‘ship-x-position’ to be a function of one argument, a
     ship, that returns the ‘x-position’ of the ship; ‘ship-y-position’
     and the other components are given similar function definitions.
     These functions are called the access functions, as they are used
     to access elements of the structure.

  2. ‘ship’ becomes the name of a type of which instances of ships are
     elements.  ‘ship’ becomes acceptable to ‘typep’, for example;
     ‘(typep x 'ship)’ is true if ‘x’ is a ship and false if ‘x’ is any
     object other than a ship.

  3. A function named ‘ship-p’ of one argument is defined; it is a
     predicate that is true if its argument is a ship and is false
     otherwise.

  4. A function called ‘make-ship’ is defined that, when invoked,
     creates a data structure with five components, suitable for use
     with the access functions.  Thus executing

      (setq ship2 (make-ship))

     sets ‘ship2’ to a newly created ‘ship’ object.  One can supply the
     initial values of any desired component in the call to ‘make-ship’
     by using keyword arguments in this way:

      (setq ship2 (make-ship :mass *default-ship-mass*
                             :x-position 0
                             :y-position 0))

     This constructs a new ship and initializes three of its components.
     This function is called the "constructor function" because it
     constructs a new structure.

  5. A function called ‘copy-ship’ of one argument is defined that,
     when given a ‘ship’ object, creates a new ‘ship’ object that is a
     copy of the given one.  This function is called the "copier
     function."

‘setf’ can be used to alter the components of a ‘ship’:

 (setf (ship-x-position ship2) 100)

This alters the ‘x-position’ of ‘ship2’ to be ‘100’.  This works
because ‘defstruct’ behaves as if it generates an appropriate ‘defsetf’
for each access function.

;;;
;;; Example 1
;;; define town structure type
;;; area, watertowers, firetrucks, population, elevation are its components
;;;
 (defstruct town
             area
             watertowers
             (firetrucks 1 :type fixnum)    ;an initialized slot
             population
             (elevation 5128 :read-only t)) ;a slot that can't be changed
→ TOWN
;create a town instance
 (setq town1 (make-town :area 0 :watertowers 0)) → #S(TOWN...)
;town's predicate recognizes the new instance
 (town-p town1) → true
;new town's area is as specified by make-town
 (town-area town1) → 0
;new town's elevation has initial value
 (town-elevation town1) → 5128
;setf recognizes reader function
 (setf (town-population town1) 99) → 99
 (town-population town1) → 99
;copier function makes a copy of town1
 (setq town2 (copy-town town1)) → #S(TOWN...)
 (= (town-population town1) (town-population town2))  → true
;since elevation is a read-only slot, its value can be set only
;when the structure is created
 (setq town3 (make-town :area 0 :watertowers 3 :elevation 1200))
→ #S(TOWN...)
;;;
;;; Example 2
;;; define clown structure type
;;; this structure uses a nonstandard prefix
;;;
 (defstruct (clown (:conc-name bozo-))
             (nose-color 'red)
             frizzy-hair-p polkadots) → CLOWN
 (setq funny-clown (make-clown)) → #S(CLOWN)
;use non-default reader name
 (bozo-nose-color funny-clown) → RED
 (defstruct (klown (:constructor make-up-klown) ;similar def using other
             (:copier clone-klown)              ;customizing keywords
             (:predicate is-a-bozo-p))
             nose-color frizzy-hair-p polkadots) → klown
;custom constructor now exists
 (fboundp 'make-up-klown) → true
;;;
;;; Example 3
;;; define a vehicle structure type
;;; then define a truck structure type that includes
;;; the vehicle structure
;;;
 (defstruct vehicle name year (diesel t :read-only t)) → VEHICLE
 (defstruct (truck (:include vehicle (year 79)))
             load-limit
             (axles 6)) → TRUCK
 (setq x (make-truck :name 'mac :diesel t :load-limit 17))
→ #S(TRUCK...)
;vehicle readers work on trucks
 (vehicle-name x)
→ MAC
;default taken from :include clause
 (vehicle-year x)
→ 79
 (defstruct (pickup (:include truck))     ;pickup type includes truck
             camper long-bed four-wheel-drive) → PICKUP
 (setq x (make-pickup :name 'king :long-bed t)) → #S(PICKUP...)
;:include default inherited
 (pickup-year x) → 79
;;;
;;; Example 4
;;; use of BOA constructors
;;;
 (defstruct (dfs-boa                      ;BOA constructors
               (:constructor make-dfs-boa (a b c))
               (:constructor create-dfs-boa
                 (a &optional b (c 'cc) &rest d &aux e (f 'ff))))
             a b c d e f) → DFS-BOA
;a, b, and c set by position, and the rest are uninitialized
 (setq x (make-dfs-boa 1 2 3)) → #(DFS-BOA...)
 (dfs-boa-a x) → 1
;a and b set, c and f defaulted
 (setq x (create-dfs-boa 1 2)) → #(DFS-BOA...)
 (dfs-boa-b x) → 2
 (eq (dfs-boa-c x) 'cc) → true
;a, b, and c set, and the rest are collected into d
 (setq x (create-dfs-boa 1 2 3 4 5 6)) → #(DFS-BOA...)
 (dfs-boa-d x) → (4 5 6)

Exceptional Situations:
.......................

If any two slot names (whether present directly or inherited by the
:include option) are the same under ‘string=’, ‘defstruct’ should
signal an error of type ‘program-error’.

The consequences are undefined if the INCLUDED-STRUCTURE-NAME does not
name a structure type.

See Also:
.........

*note documentation::, *note print-object::, *note setf::, *note
subtypep::, *note type-of::, *note typep::, *note Section 3.2
(Compilation): Compilation.

Notes:
......

The PRINTER-NAME should observe the values of such printer-control
variables as ‘*print-escape*’.

The restriction against issuing a warning for type mismatches between a
SLOT-INITFORM and the corresponding slot's :type option is necessary
because a SLOT-INITFORM must be specified in order to specify slot
options; in some cases, no suitable default may exist.

The mechanism by which ‘defstruct’ arranges for slot accessors to be
usable with ‘setf’ is implementation-dependent; for example, it may use
setf functions, setf expanders, or some other implementation-dependent
mechanism known to that implementation's code for ‘setf’.


File: ansicl,  Node: copy-structure,  Prev: defstruct,  Up: Structures

copy-structure (Function)
=========================

Syntax:
.......

 -- Function: copy-structure structure → copy

Arguments and Values:
.....................

STRUCTURE--a structure.

COPY--a copy of the STRUCTURE.

Description:
............

Returns a copy₆ of the STRUCTURE.

Only the STRUCTURE itself is copied; not the values of the slots.

See Also:
.........

the :copier option to *note defstruct::

Notes:
......

The COPY is the same as the given STRUCTURE under ‘equalp’, but not
under ‘equal’.


File: ansicl,  Node: Conditions,  Next: Symbols,  Prev: Structures,  Up: Top

9 Conditions
************

* Menu:

* Condition System Concepts::

Dictionary

* condition::
* warning::
* style-warning::
* serious-condition::
* error (Condition Type)::
* cell-error::
* cell-error-name::
* parse-error::
* storage-condition::
* assert::
* error (Function)::
* cerror::
* check-type::
* simple-error::
* invalid-method-error::
* method-combination-error::
* signal::
* simple-condition::
* simple-condition-format-control; simple-condition-format-arguments::
* warn::
* simple-warning::
* invoke-debugger::
* break::
* *debugger-hook*::
* *break-on-signals*::
* handler-bind::
* handler-case::
* ignore-errors::
* define-condition::
* make-condition::
* restart::
* compute-restarts::
* find-restart::
* invoke-restart::
* invoke-restart-interactively::
* restart-bind::
* restart-case::
* restart-name::
* with-condition-restarts::
* with-simple-restart::
* abort (Restart)::
* continue (Restart)::
* muffle-warning (Restart)::
* store-value (Restart)::
* use-value (Restart)::
* abort; continue; muffle-warning; store-value; use-value::


File: ansicl,  Node: Condition System Concepts,  Next: condition,  Up: Conditions

9.1 Condition System Concepts
=============================

Common Lisp constructs are described not only in terms of their
behavior in situations during which they are intended to be used (see
the "Description" part of each operator specification), but in all
other situations (see the "Exceptional Situations" part of each
operator specification).

A situation is the evaluation of an expression in a specific context.
A condition is an object that represents a specific situation that has
been detected.  Conditions are generalized instances of the class
‘condition’.  A hierarchy of condition classes is defined in Common
Lisp.  A condition has slots that contain data relevant to the
situation that the condition represents.

An error is a situation in which normal program execution cannot
continue correctly without some form of intervention (either
interactively by the user or under program control).  Not all errors
are detected.  When an error goes undetected, the effects can be
implementation-dependent, implementation-defined, unspecified, or
undefined. See *note Section 1.4 (Definitions): Definitions.  All
detected errors can be represented by conditions, but not all
conditions represent errors.

Signaling is the process by which a condition can alter the flow of
control in a program by raising the condition which can then be
handled.  The functions ‘error’, ‘cerror’, ‘signal’, and ‘warn’ are
used to signal conditions.

The process of signaling involves the selection and invocation of a
handler from a set of active handlers.  A handler is a function of one
argument (the condition) that is invoked to handle a condition.  Each
handler is associated with a condition type, and a handler will be
invoked only on a condition of the handler's associated type.

Active handlers are established dynamically (see ‘handler-bind’ or
‘handler-case’).  Handlers are invoked in a dynamic environment
equivalent to that of the signaler, except that the set of active
handlers is bound in such a way as to include only those that were
active at the time the handler being invoked was established.
Signaling a condition has no side-effect on the condition, and there is
no dynamic state contained in a condition.

If a handler is invoked, it can address the situation in one of three
ways:

Decline
     It can decline to handle the condition.  It does this by simply
     returning rather than transferring control.  When this happens,
     any values returned by the handler are ignored and the next most
     recently established handler is invoked.  If there is no such
     handler and the signaling function is ‘error’ or ‘cerror’, the
     debugger is entered in the dynamic environment of the signaler. If
     there is no such handler and the signaling function is either
     ‘signal’ or ‘warn’, the signaling function simply returns ‘nil’.

Handle
     It can handle the condition by performing a non-local transfer of
     control.  This can be done either primitively by using ‘go’,
     ‘return’, ‘throw’ or more abstractly by using a function such as
     ‘abort’ or ‘invoke-restart’.

Defer
     It can put off a decision about whether to handle or decline, by
     any of a number of actions, but most commonly by signaling another
     condition, resignaling the same condition, or forcing entry into
     the debugger.

* Menu:

* Condition Types::
* Creating Conditions::
* Printing Conditions::
* Signaling and Handling Conditions::
* Assertions::
* Notes about the Condition System's Background::


File: ansicl,  Node: Condition Types,  Next: Creating Conditions,  Up: Condition System Concepts

9.1.1 Condition Types
---------------------

The next figure lists the standardized condition types.  Additional
condition types can be defined by using ‘define-condition’.

arithmetic-error                   floating-point-overflow    simple-type-error
cell-error                         floating-point-underflow   simple-warning
condition                          package-error              storage-condition
control-error                      parse-error                stream-error
division-by-zero                   print-not-readable         style-warning
end-of-file                        program-error              type-error
error                              reader-error               unbound-slot
file-error                         serious-condition          unbound-variable
floating-point-inexact             simple-condition           undefined-function
floating-point-invalid-operation   simple-error               warning

Figure 9.1: Standardized Condition Types

All condition types are subtypes of type ‘condition’.  That is,

 (typep C 'condition) → true

if and only if C is a condition.

Implementations must define all specified subtype relationships.
Except where noted, all subtype relationships indicated in this
document are not mutually exclusive.  A condition inherits the
structure of its supertypes.

The metaclass of the class ‘condition’ is not specified.  Names of
condition types may be used to specify supertype relationships in
‘define-condition’, but the consequences are not specified if an
attempt is made to use a condition type as a superclass in a ‘defclass’
form.

The next figure shows operators that define condition types and
creating conditions.

define-condition   make-condition   

Figure 9.2: Operators that define and create conditions.

The next figure shows operators that read the value of condition slots.

arithmetic-error-operands    simple-condition-format-arguments
arithmetic-error-operation   simple-condition-format-control
cell-error-name              stream-error-stream
file-error-pathname          type-error-datum
package-error-package        type-error-expected-type
print-not-readable-object    unbound-slot-instance

Figure 9.3: Operators that read condition slots.

9.1.1.1 Serious Conditions
..........................

A serious condition is a condition serious enough to require
interactive intervention if not handled.  Serious conditions are
typically signaled with ‘error’ or ‘cerror’; non-serious conditions are
typically signaled with ‘signal’ or ‘warn’.


File: ansicl,  Node: Creating Conditions,  Next: Printing Conditions,  Prev: Condition Types,  Up: Condition System Concepts

9.1.2 Creating Conditions
-------------------------

The function ‘make-condition’ can be used to construct a condition
object explicitly.  Functions such as ‘error’, ‘cerror’, ‘signal’, and
‘warn’ operate on conditions and might create condition objects
implicitly.  Macros such as ‘ccase’, ‘ctypecase’, ‘ecase’, ‘etypecase’,
‘check-type’, and ‘assert’ might also implicitly create (and signal)
conditions.

9.1.2.1 Condition Designators
.............................

A number of the functions in the condition system take arguments which
are identified as "condition designators".  By convention, those
arguments are notated as

 DATUM &rest ARGUMENTS

Taken together, the DATUM and the ARGUMENTS are "designators for a
condition of default type DEFAULT-TYPE."  How the denoted condition is
computed depends on the type of the DATUM:

   * If the DATUM is a symbol naming a condition type ...

     The denoted condition is the result of

      (apply #'make-condition DATUM ARGUMENTS)

   * If the DATUM is a format control ...

     The denoted condition is the result of

      (make-condition DEFAULTED-TYPE
                      :format-control DATUM
                      :format-arguments ARGUMENTS)

     where the DEFAULTED-TYPE is a subtype of DEFAULT-TYPE.

   * If the DATUM is a condition ...

     The denoted condition is the DATUM itself.  In this case, unless
     otherwise specified by the description of the operator in
     question, the arguments must be null; that is, the consequences
     are undefined if any ARGUMENTS were supplied.

Note that the DEFAULT-TYPE gets used only in the case where the DATUM
string is supplied.  In the other situations, the resulting condition
is not necessarily of type DEFAULT-TYPE.

Here are some illustrations of how different condition designators can
denote equivalent condition objects:

(let ((c (make-condition 'arithmetic-error :operator '/ :operands '(7 0))))
  (error c))
≡ (error 'arithmetic-error :operator '/ :operands '(7 0))

(error "Bad luck.")
≡ (error 'simple-error :format-control "Bad luck." :format-arguments '())


File: ansicl,  Node: Printing Conditions,  Next: Signaling and Handling Conditions,  Prev: Creating Conditions,  Up: Condition System Concepts

9.1.3 Printing Conditions
-------------------------

If the :report argument to ‘define-condition’ is used, a print function
is defined that is called whenever the defined condition is printed
while the value of ‘*print-escape*’ is false.  This function is called
the "condition reporter"; the text which it outputs is called a "report
message".

When a condition is printed and ‘*print-escape*’ is false, the
condition reporter for the condition is invoked.  Conditions are
printed automatically by functions such as ‘invoke-debugger’, ‘break’,
and ‘warn’.

When ‘*print-escape*’ is true, the object should print in an
abbreviated fashion according to the style of the implementation (e.g.,
by ‘print-unreadable-object’).  It is not required that a condition can
be recreated by reading its printed representation.

No function is provided for directly accessing or invoking condition
reporters.

9.1.3.1 Recommended Style in Condition Reporting
................................................

In order to ensure a properly aesthetic result when presenting report
messages to the user, certain stylistic conventions are recommended.

There are stylistic recommendations for the content of the messages
output by condition reporters, but there are no formal requirements on
those programs.  If a program violates the recommendations for some
message, the display of that message might be less aesthetic than if
the guideline had been observed, but the program is still considered a
conforming program.

The requirements on a program or implementation which invokes a
condition reporter are somewhat stronger.  A conforming program must be
permitted to assume that if these style guidelines are followed, proper
aesthetics will be maintained.  Where appropriate, any specific
requirements on such routines are explicitly mentioned below.

9.1.3.1.1 Capitalization and Punctuation in Condition Reports
.............................................................

It is recommended that a report message be a complete sentences, in the
proper case and correctly punctuated.  In English, for example, this
means the first letter should be uppercase, and there should be a
trailing period.

 (error "This is a message")  ; Not recommended
 (error "this is a message.") ; Not recommended

 (error "This is a message.") ; Recommended instead

9.1.3.1.2 Leading and Trailing Newlines in Condition Reports
............................................................

It is recommended that a report message not begin with any introductory
text, such as "‘Error: ’" or "‘Warning: ’" or even just freshline or
newline.  Such text is added, if appropriate to the context, by the
routine invoking the condition reporter.

It is recommended that a report message not be followed by a trailing
freshline or newline.  Such text is added, if appropriate to the
context, by the routine invoking the condition reporter.

 (error "This is a message.~%")   ; Not recommended
 (error "~&This is a message.")   ; Not recommended
 (error "~&This is a message.~%") ; Not recommended

 (error "This is a message.")     ; Recommended instead

9.1.3.1.3 Embedded Newlines in Condition Reports
................................................

Especially if it is long, it is permissible and appropriate for a
report message to contain one or more embedded newlines.

If the calling routine conventionally inserts some additional prefix
(such as "‘Error: ’" or "‘;; Error: ’") on the first line of the
message, it must also assure that an appropriate prefix will be added
to each subsequent line of the output, so that the left edge of the
message output by the condition reporter will still be properly aligned.

 (defun test ()
   (error "This is an error message.~%It has two lines."))

 ;; Implementation A
 (test)
 This is an error message.
 It has two lines.

 ;; Implementation B
 (test)
 ;; Error: This is an error message.
 ;;        It has two lines.

 ;; Implementation C
 (test)
 >> Error: This is an error message.
           It has two lines.

9.1.3.1.4 Note about Tabs in Condition Reports
..............................................

Because the indentation of a report message might be shifted to the
right or left by an arbitrary amount, special care should be taken with
the semi-standard character <Tab>  (in those implementations that
support such a character).  Unless the implementation specifically
defines its behavior in this context, its use should be avoided.

9.1.3.1.5 Mentioning Containing Function in Condition Reports
.............................................................

The name of the containing function should generally not be mentioned in
report messages.  It is assumed that the debugger will make this
information accessible in situations where it is necessary and
appropriate.


File: ansicl,  Node: Signaling and Handling Conditions,  Next: Assertions,  Prev: Printing Conditions,  Up: Condition System Concepts

9.1.4 Signaling and Handling Conditions
---------------------------------------

The operation of the condition system depends on the ordering of active
applicable handlers from most recent to least recent.

Each handler is associated with a type specifier that must designate a
subtype of type ‘condition’.  A handler is said to be applicable to a
condition if that condition is of the type designated by the associated
type specifier.

Active handlers are established by using ‘handler-bind’ (or an
abstraction based on ‘handler-bind’, such as ‘handler-case’ or
‘ignore-errors’).

Active handlers can be established within the dynamic scope of other
active handlers.  At any point during program execution, there is a set
of active handlers.  When a condition is signaled, the most recent
active applicable handler for that condition is selected from this set.
Given a condition, the order of recentness of active applicable
handlers is defined by the following two rules:

  1. Each handler in a set of active handlers H₁ is more recent than
     every handler in a set H₂ if the handlers in H₂ were active when
     the handlers in H₁ were established.

  2. Let h₁ and h₂ be two applicable active handlers established by the
     same form. Then h₁ is more recent than h₂ if h₁ was defined to the
     left of h₂ in the form that established them.

Once a handler in a handler binding form (such as ‘handler-bind’ or
‘handler-case’) has been selected, all handlers in that form become
inactive for the remainder of the signaling process.  While the
selected handler runs, no other handler established by that form is
active. That is, if the handler declines, no other handler established
by that form will be considered for possible invocation.

The next figure shows operators relating to the handling of conditions.

handler-bind   handler-case   ignore-errors

Figure 9.4: Operators relating to handling conditions.

9.1.4.1 Signaling
.................

When a condition is signaled, the most recent applicable active handler
is invoked.  Sometimes a handler will decline by simply returning
without a transfer of control.  In such cases, the next most recent
applicable active handler is invoked.

If there are no applicable handlers for a condition that has been
signaled, or if all applicable handlers decline, the condition is
unhandled.

The functions ‘cerror’ and ‘error’ invoke the interactive condition
handler (the debugger) rather than return if the condition being
signaled, regardless of its type, is unhandled.  In contrast, ‘signal’
returns ‘nil’ if the condition being signaled, regardless of its type,
is unhandled.

The variable ‘*break-on-signals*’ can be used to cause the debugger to
be entered before the signaling process begins.

The next figure shows defined names relating to the signaling of
conditions.

*break-on-signals*   error    warn
cerror               signal   

Figure 9.5: Defined names relating to signaling conditions.

9.1.4.1.1 Resignaling a Condition
.................................

During the dynamic extent of the signaling process for a particular
condition object, ‘signaling’ the same condition object again is
permitted if and only if the situation represented in both cases are
the same.

For example, a handler might legitimately signal the condition object
that is its argument in order to allow outer handlers first opportunity
to handle the condition.  (Such a handlers is sometimes called a
"default handler.")  This action is permitted because the situation
which the second signaling process is addressing is really the same
situation.

On the other hand, in an implementation that implemented asynchronous
keyboard events by interrupting the user process with a call to
‘signal’, it would not be permissible for two distinct asynchronous
keyboard events to signal identical condition objects at the same time
for different situations.

9.1.4.2 Restarts
................

The interactive condition handler returns only through non-local
transfer of control to specially defined restarts that can be set up
either by the system or by user code.  Transferring control to a
restart is called "invoking" the restart.  Like handlers, active
restarts are established dynamically, and only active restarts can be
invoked.  An active restart can be invoked by the user from the
debugger or by a program by using ‘invoke-restart’.

A restart contains a function to be called when the restart is invoked,
an optional name that can be used to find or invoke the restart, and an
optional set of interaction information for the debugger to use to
enable the user to manually invoke a restart.

The name of a restart is used by ‘invoke-restart’. Restarts that can be
invoked only within the debugger do not need names.

Restarts can be established by using ‘restart-bind’, ‘restart-case’,
and ‘with-simple-restart’.  A restart function can itself invoke any
other restart that was active at the time of establishment of the
restart of which the function is part.

The restarts established by a ‘restart-bind’ form, a ‘restart-case’
form, or a ‘with-simple-restart’ form have dynamic extent which extends
for the duration of that form's execution.

Restarts of the same name can be ordered from least recent to most
recent according to the following two rules:

  1. Each restart in a set of active restarts R₁ is more recent than
     every restart in a set R₂ if the restarts in R₂ were active when
     the  restarts in R₁ were established.

  2. Let r₁ and r₂ be two active restarts with the same name
     established by the same form. Then r₁ is more recent than r₂ if r₁
     was defined to the left of r₂ in the form that established them.

If a restart is invoked but does not transfer control, the values
resulting from the restart function are returned by the function that
invoked the restart, either ‘invoke-restart’ or
‘invoke-restart-interactively’.

9.1.4.2.1 Interactive Use of Restarts
.....................................

For interactive handling, two pieces of information are needed from a
restart: a report function and an interactive function.

The report function is used by a program such as the debugger to
present a description of the action the restart will take.  The report
function is specified and established by the :report-function keyword to
‘restart-bind’ or the :report keyword to ‘restart-case’.

The interactive function, which can be specified using the
:interactive-function keyword to ‘restart-bind’ or :interactive keyword
to ‘restart-case’, is used when the restart is invoked interactively,
such as from the debugger, to produce a suitable list of arguments.

‘invoke-restart’ invokes the most recently established restart whose
name is the same as the first argument to ‘invoke-restart’.  If a
restart is invoked interactively by the debugger and  does not transfer
control but rather returns values, the precise action of the debugger
on those values is implementation-defined.

9.1.4.2.2 Interfaces to Restarts
................................

Some restarts have functional interfaces, such as ‘abort’, ‘continue’,
‘muffle-warning’, ‘store-value’, and ‘use-value’.  They are ordinary
functions that use ‘find-restart’ and ‘invoke-restart’ internally, that
have the same name as the restarts they manipulate, and that are
provided simply for notational convenience.

The next figure shows defined names relating to restarts.

abort              invoke-restart-interactively   store-value
compute-restarts   muffle-warning                 use-value
continue           restart-bind                   with-simple-restart
find-restart       restart-case                   
invoke-restart     restart-name                   

Figure 9.6: Defined names relating to restarts.

9.1.4.2.3 Restart Tests
.......................

Each restart has an associated test, which is a function of one
argument (a condition or ‘nil’) which returns true if the restart
should be visible in the current situation.  This test is created by
the :test-function option to ‘restart-bind’ or the :test option to
‘restart-case’.

9.1.4.2.4 Associating a Restart with a Condition
................................................

A restart can be "associated with" a condition explicitly by
‘with-condition-restarts’, or implicitly by ‘restart-case’.  Such an
assocation has dynamic extent.

A single restart may be associated with several conditions at the same
time.  A single condition may have several associated restarts at the
same time.

Active restarts associated with a particular condition can be detected
by calling a function such as ‘find-restart’, supplying that condition
as the CONDITION argument.  Active restarts can also be detected
without regard to any associated condition by calling such a function
without a CONDITION argument, or by supplying a value of ‘nil’ for such
an argument.


File: ansicl,  Node: Assertions,  Next: Notes about the Condition System's Background,  Prev: Signaling and Handling Conditions,  Up: Condition System Concepts

9.1.5 Assertions
----------------

Conditional signaling of conditions based on such things as key match,
form evaluation, and type are handled by assertion operators.  The next
figure shows operators relating to assertions.

assert   check-type   ecase
ccase    ctypecase    etypecase

Figure 9.7: Operators relating to assertions.


File: ansicl,  Node: Notes about the Condition System's Background,  Prev: Assertions,  Up: Condition System Concepts

9.1.6 Notes about the Condition System's Background
---------------------------------------------------

For a background reference to the abstract concepts detailed in this
section, see `Exceptional Situations in Lisp'.  The details of that
paper are not binding on this document, but may be helpful in
establishing a conceptual basis for understanding this material.


File: ansicl,  Node: condition,  Next: warning,  Prev: Condition System Concepts,  Up: Conditions

condition (Condition Type)
==========================

Class Precedence List:
......................

‘condition’, ‘t’

Description:
............

All types of conditions, whether error or non-error, must inherit from
this type.

No additional subtype relationships among the specified subtypes of
type ‘condition’ are allowed, except when explicitly mentioned in the
text; however implementations are permitted to introduce additional
types and one of these types can be a subtype of any number of the
subtypes of type ‘condition’.

Whether a user-defined condition type has slots that are accessible by
with-slots is implementation-dependent.  Furthermore, even in an
implementation in which user-defined condition types would have slots,
it is implementation-dependent whether any condition types defined in
this document have such slots or, if they do, what their names might be;
only the reader functions documented by this specification may be relied
upon by portable code.

Conforming code must observe the following restrictions related to
conditions:

   * ‘define-condition’, not ‘defclass’, must be used to define new
     condition types.

   * ‘make-condition’, not ‘make-instance’, must be used to create
     condition objects explicitly.

   * The :report option of ‘define-condition’, not ‘defmethod’ for
     ‘print-object’, must be used to define a condition reporter.

   * ‘slot-value’, ‘slot-boundp’, ‘slot-makunbound’, and ‘with-slots’
     must not be used on condition objects.  Instead, the appropriate
     accessor functions (defined by ‘define-condition’) should be used.


File: ansicl,  Node: warning,  Next: style-warning,  Prev: condition,  Up: Conditions

warning (Condition Type)
========================

Class Precedence List:
......................

‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘warning’ consists of all types of warnings.

See Also:
.........

*note style-warning::


File: ansicl,  Node: style-warning,  Next: serious-condition,  Prev: warning,  Up: Conditions

style-warning (Condition Type)
==============================

Class Precedence List:
......................

‘style-warning’, ‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘style-warning’ includes those conditions that represent
situations involving code that is conforming code but that is
nevertheless considered to be faulty or substandard.

See Also:
.........

*note muffle-warning::

Notes:
......

An implementation might signal such a condition if it encounters code
that uses deprecated features or that appears unaesthetic or
inefficient.

An `unused variable' warning must be of type ‘style-warning’.

In general, the question of whether code is faulty or substandard is a
subjective decision to be made by the facility processing that code.
The intent is that whenever such a facility wishes to complain about
code on such subjective grounds, it should use this condition type so
that any clients who wish to redirect or muffle superfluous warnings
can do so without risking that they will be redirecting or muffling
other, more serious warnings.


File: ansicl,  Node: serious-condition,  Next: error (Condition Type),  Prev: style-warning,  Up: Conditions

serious-condition (Condition Type)
==================================

Class Precedence List:
......................

‘serious-condition’, ‘condition’, ‘t’

Description:
............

All conditions serious enough to require interactive intervention if
not handled should inherit from the type ‘serious-condition’.  This
condition type is provided primarily so that it may be included as a
superclass of other condition types; it is not intended to be signaled
directly.

Notes:
......

Signaling a serious condition does not itself force entry into the
debugger.   However, except in the unusual situation where the
programmer can assure that no harm will come from failing to handle a
serious condition, such a condition is usually signaled with ‘error’
rather than ‘signal’ in order to assure that the program does not
continue without handling the condition.  (And conversely, it is
conventional to use ‘signal’ rather than ‘error’ to signal conditions
which are not serious conditions, since normally the failure to handle
a non-serious condition is not reason enough for the debugger to be
entered.)


File: ansicl,  Node: error (Condition Type),  Next: cell-error,  Prev: serious-condition,  Up: Conditions

error (Condition Type)
======================

Class Precedence List:
......................

‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘error’ consists of all conditions that represent errors.


File: ansicl,  Node: cell-error,  Next: cell-error-name,  Prev: error (Condition Type),  Up: Conditions

cell-error (Condition Type)
===========================

Class Precedence List:
......................

‘cell-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘cell-error’ consists of error conditions that occur during a
location access.   The name of the offending cell is initialized by the
:name initialization argument to ‘make-condition’, and is accessed by
the function ‘cell-error-name’.

See Also:
.........

*note cell-error-name::


File: ansicl,  Node: cell-error-name,  Next: parse-error,  Prev: cell-error,  Up: Conditions

cell-error-name (Function)
==========================

Syntax:
.......

 -- Function: cell-error-name condition → name

Arguments and Values:
.....................

CONDITION--a condition of type ‘cell-error’.

NAME--an object.

Description:
............

Returns the name of the offending cell involved in the situation
represented by CONDITION.

The nature of the result depends on the specific type of CONDITION.
For example, if the CONDITION is of type ‘unbound-variable’, the result
is the name of the unbound variable which was being accessed, if the
CONDITION is of type ‘undefined-function’, this is the name of the
undefined function which was being accessed, and if the CONDITION is of
type ‘unbound-slot’, this is the name of the slot which was being
accessed.

See Also:
.........

*note cell-error::, *note unbound-slot::, *note unbound-variable::,
*note undefined-function::, *note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: ansicl,  Node: parse-error,  Next: storage-condition,  Prev: cell-error-name,  Up: Conditions

parse-error (Condition Type)
============================

Class Precedence List:
......................

‘parse-error’, ‘error’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘parse-error’ consists of error conditions that are related to
parsing.

See Also:
.........

*note parse-namestring::, *note reader-error::


File: ansicl,  Node: storage-condition,  Next: assert,  Prev: parse-error,  Up: Conditions

storage-condition (Condition Type)
==================================

Class Precedence List:
......................

‘storage-condition’, ‘serious-condition’, ‘condition’, ‘t’

Description:
............

The type ‘storage-condition’ consists of serious conditions that relate
to problems with memory management that are potentially due to
implementation-dependent limits rather than semantic errors in
conforming programs, and that typically warrant entry to the debugger
if not handled.  Depending on the details of the implementation, these
might include such problems as stack overflow, memory region overflow,
and storage exhausted.

Notes:
......

While some Common Lisp operations might signal storage-condition
because they are defined to create objects, it is unspecified whether
operations that are not defined to create objects create them anyway
and so might also signal ‘storage-condition’.  Likewise, the evaluator
itself might create objects and so might signal ‘storage-condition’.
(The natural assumption might be that such object creation is naturally
inefficient, but even that is implementation-dependent.)  In general,
the entire question of how storage allocation is done is
implementation-dependent, and so any operation might signal
‘storage-condition’ at any time.  Because such a condition is
indicative of a limitation of the implementation or of the image rather
than an error in a program, objects of type ‘storage-condition’ are not
of type ‘error’.


File: ansicl,  Node: assert,  Next: error (Function),  Prev: storage-condition,  Up: Conditions

assert (Macro)
==============

Syntax:
.......

 -- Macro: assert test-form [({place}*) [datum-form {argument-form}*]]
          → ‘nil’

Arguments and Values:
.....................

TEST-FORM--a form; always evaluated.

PLACE--a place; evaluated if an error is signaled.

DATUM-FORM--a form that evaluates to a DATUM.  Evaluated each time an
error is to be signaled, or not at all if no error is to be signaled.

ARGUMENT-FORM--a form that evaluates to an ARGUMENT.  Evaluated each
time an error is to be signaled, or not at all if no error is to be
signaled.

DATUM, ARGUMENTS--designators for a condition of default type ‘error’.
(These designators are the result of evaluating DATUM-FORM and each of
the ARGUMENT-FORMS.)

Description:
............

‘assert’ assures that TEST-FORM evaluates to true.  If TEST-FORM
evaluates to false, ‘assert’ signals a correctable error (denoted by
DATUM and ARGUMENTS).  Continuing from this error using the ‘continue’
restart makes it possible for the user to alter the values of the
PLACES before ‘assert’ evaluates TEST-FORM again.  If the value of
TEST-FORM is non-nil, ‘assert’ returns ‘nil’.

The PLACES are generalized references to data upon which TEST-FORM
depends, whose values can be changed by the user in attempting to
correct the error.  Subforms of each PLACE are only evaluated if an
error is signaled, and might be re-evaluated if the error is
re-signaled (after continuing without actually fixing the problem).
The order of evaluation of the PLACES is not specified; see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.  If
a PLACE form is supplied that produces more values than there are store
variables, the extra values are ignored. If the supplied form produces
fewer values than there are store variables, the missing values are set
to ‘nil’.

Examples:
.........

 (setq x (make-array '(3 5) :initial-element 3))
→ #2A((3 3 3 3 3) (3 3 3 3 3) (3 3 3 3 3))
 (setq y (make-array '(3 5) :initial-element 7))
→ #2A((7 7 7 7 7) (7 7 7 7 7) (7 7 7 7 7))
 (defun matrix-multiply (a b)
   (let ((*print-array* nil))
     (assert (and (= (array-rank a) (array-rank b) 2)
                  (= (array-dimension a 1) (array-dimension b 0)))
             (a b)
             "Cannot multiply ~S by ~S." a b)
            (really-matrix-multiply a b))) → MATRIX-MULTIPLY
 (matrix-multiply x y)
▷ Correctable error in MATRIX-MULTIPLY:
▷ Cannot multiply #<ARRAY ...> by #<ARRAY ...>.
▷ Restart options:
▷  1: You will be prompted for one or more new values.
▷  2: Top level.
▷ Debug> :continue 1
▷ Value for A: x
▷ Value for B: (make-array '(5 3) :initial-element 6)
→ #2A((54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54)
       (54 54 54 54 54))

 (defun double-safely (x) (assert (numberp x) (x)) (+ x x))
 (double-safely 4)
→ 8

 (double-safely t)
▷ Correctable error in DOUBLE-SAFELY: The value of (NUMBERP X) must be non-NIL.
▷ Restart options:
▷  1: You will be prompted for one or more new values.
▷  2: Top level.
▷ Debug> :continue 1
▷ Value for X: 7
→ 14

Affected By:
............

‘*break-on-signals*’

The set of active condition handlers.

See Also:
.........

*note check-type::, *note error (Function)::, *note Section 5.1
(Generalized Reference): Generalized Reference.

Notes:
......

The debugger need not include the TEST-FORM in the error message, and
the PLACES should not be included in the message, but they should be
made available for the user's perusal.  If the user gives the
"continue" command, the values of any of the references can be altered.
The details of this depend on the implementation's style of user
interface.


File: ansicl,  Node: error (Function),  Next: cerror,  Prev: assert,  Up: Conditions

error (Function)
================

Syntax:
.......

 -- Function: error datum &rest arguments →|

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
‘simple-error’.

Description:
............

‘error’ effectively invokes ‘signal’ on the denoted condition.

If the condition is not handled, ‘(invoke-debugger condition)’ is done.
As a consequence of calling ‘invoke-debugger’, ‘error’ cannot directly
return; the only exit from ‘error’ can come by non-local transfer of
control in a handler or by use of an interactive debugging command.

Examples:
.........

 (defun factorial (x)
   (cond ((or (not (typep x 'integer)) (minusp x))
          (error "~S is not a valid argument to FACTORIAL." x))
         ((zerop x) 1)
         (t (* x (factorial (- x 1))))))
→ FACTORIAL
(factorial 20)
→ 2432902008176640000
(factorial -1)
▷ Error: -1 is not a valid argument to FACTORIAL.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return to Lisp Toplevel.
▷ Debug>

 (setq a 'fred)
→ FRED
 (if (numberp a) (1+ a) (error "~S is not a number." A))
▷ Error: FRED is not a number.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return to Lisp Toplevel.
▷ Debug> :Continue 1
▷ Return to Lisp Toplevel.

 (define-condition not-a-number (error)
                   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))
→ NOT-A-NUMBER

 (if (numberp a) (1+ a) (error 'not-a-number :argument a))
▷ Error: FRED is not a number.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return to Lisp Toplevel.
▷ Debug> :Continue 1
▷ Return to Lisp Toplevel.

Side Effects:
.............

Handlers for the specified condition, if any, are invoked and might
have side effects.  Program execution might stop, and the debugger
might be entered.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’

Signals an error of type ‘type-error’ if DATUM and ARGUMENTS are not
designators for a condition

See Also:
.........

*note cerror::, *note signal::, *note format::, *note ignore-errors::,
*note *break-on-signals*::, *note handler-bind::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

Some implementations may provide debugger commands for interactively
returning from individual stack frames.  However, it should be possible
for the programmer to feel confident about writing code like:

 (defun wargames:no-win-scenario ()
   (if (error "pushing the button would be stupid."))
   (push-the-button))

In this scenario, there should be no chance that ‘error’ will return
and the button will get pushed.

While the meaning of this program is clear and it might be proven `safe'
by a formal theorem prover, such a proof is no guarantee that the
program is safe to execute.  Compilers have been known to have bugs,
computers to have signal glitches, and human beings to manually
intervene in ways that are not always possible to predict.  Those kinds
of errors, while beyond the scope of the condition system to formally
model, are not beyond the scope of things that should seriously be
considered when writing code that could have the kinds of sweeping
effects hinted at by this example.


File: ansicl,  Node: cerror,  Next: check-type,  Prev: error (Function),  Up: Conditions

cerror (Function)
=================

Syntax:
.......

 -- Function: cerror continue-format-control datum &rest arguments →
          ‘nil’

Arguments and Values:
.....................

CONTINUE-FORMAT-CONTROL--a format control.

DATUM, ARGUMENTS--designators for a condition of default type
‘simple-error’.

Description:
............

‘cerror’ effectively invokes ‘error’ on the condition named by DATUM.
As with any function that implicitly calls ‘error’, if the condition is
not handled, ‘(invoke-debugger condition)’ is executed.  While
signaling is going on, and while in the debugger if it is reached, it
is possible to continue code execution (i.e., to return from ‘cerror’)
using the ‘continue’ restart.

If DATUM is a condition, ARGUMENTS can be supplied, but are used only
in conjunction with the CONTINUE-FORMAT-CONTROL.

Examples:
.........

 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4)
→ 2.0

 (real-sqrt -9)
▷ Correctable error in REAL-SQRT: Tried to take sqrt(-9).
▷ Restart options:
▷  1: Return sqrt(9) instead.
▷  2: Top level.
▷ Debug> :continue 1
→ 3.0

 (define-condition not-a-number (error)
   ((argument :reader not-a-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a number."
                      (not-a-number-argument condition)))))

 (defun assure-number (n)
   (loop (when (numberp n) (return n))
         (cerror "Enter a number."
                 'not-a-number :argument n)
         (format t "~&Type a number: ")
         (setq n (read))
         (fresh-line)))

 (assure-number 'a)
▷ Correctable error in ASSURE-NUMBER: A is not a number.
▷ Restart options:
▷  1: Enter a number.
▷  2: Top level.
▷ Debug> :continue 1
▷ Type a number: 1/2
→ 1/2

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~:[~; a bit larger than ~D~]."
                 "~*~A is not a large number."
                 (numberp n) n)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))

 (assure-large-number 10000)
→ 10000

 (assure-large-number 'a)
▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
▷ Restart options:
▷  1: Enter a number.
▷  2: Top level.
▷ Debug> :continue 1
▷ Type a large number: 88
→ 88

 (assure-large-number 37)
▷ Correctable error in ASSURE-LARGE-NUMBER: 37 is not a large number.
▷ Restart options:
▷  1: Enter a number a bit larger than 37.
▷  2: Top level.
▷ Debug> :continue 1
▷ Type a large number: 259
→ 259

 (define-condition not-a-large-number (error)
   ((argument :reader not-a-large-number-argument :initarg :argument))
   (:report (lambda (condition stream)
              (format stream "~S is not a large number."
                      (not-a-large-number-argument condition)))))

 (defun assure-large-number (n)
   (loop (when (and (numberp n) (> n 73)) (return n))
         (cerror "Enter a number~3*~:[~; a bit larger than ~*~D~]."
                 'not-a-large-number
                 :argument n
                 :ignore (numberp n)
                 :ignore n
                 :allow-other-keys t)
         (format t "~&Type a large number: ")
         (setq n (read))
         (fresh-line)))


 (assure-large-number 'a)
▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
▷ Restart options:
▷  1: Enter a number.
▷  2: Top level.
▷ Debug> :continue 1
▷ Type a large number: 88
→ 88

 (assure-large-number 37)
▷ Correctable error in ASSURE-LARGE-NUMBER: A is not a large number.
▷ Restart options:
▷  1: Enter a number a bit larger than 37.
▷  2: Top level.
▷ Debug> :continue 1
▷ Type a large number: 259
→ 259

Affected By:
............

‘*break-on-signals*’.

Existing handler bindings.

See Also:
.........

*note error (Function)::, *note format::, *note handler-bind::, *note
*break-on-signals*::, *note simple-type-error::

Notes:
......

If DATUM is a condition type rather than a string, the ‘format’
directive ‘~*’ may be especially useful in the CONTINUE-FORMAT-CONTROL
in order to ignore the keywords in the initialization argument list.
For example:

(cerror "enter a new value to replace ~*~s"
        'not-a-number
        :argument a)


File: ansicl,  Node: check-type,  Next: simple-error,  Prev: cerror,  Up: Conditions

check-type (Macro)
==================

Syntax:
.......

 -- Macro: check-type place typespec [STRING] → ‘nil’

Arguments and Values:
.....................

PLACE--a place.

TYPESPEC--a type specifier.

STRING--a string; evaluated.

Description:
............

‘check-type’ signals a correctable error of type ‘type-error’ if the
contents of PLACE are not of the type TYPESPEC.

‘check-type’ can return only if the ‘store-value’ restart is invoked,
either explicitly from a handler or implicitly as one of the options
offered by the debugger.  If the ‘store-value’ restart is invoked,
‘check-type’ stores the new value that is the argument to the restart
invocation (or that is prompted for interactively by the debugger) in
PLACE and starts over, checking the type of the new value and signaling
another error if it is still not of the desired type.

The first time PLACE is evaluated, it is evaluated by normal evaluation
rules.  It is later evaluated as a place if the type check fails and
the ‘store-value’ restart is used; see *note Section 5.1.1.1
(Evaluation of Subforms to Places): GenRefSubFormEval.

string should be an English description of the type, starting with an
indefinite article ("a" or "an").  If string is not supplied, it is
computed automatically from TYPESPEC.  The automatically generated
message mentions PLACE, its contents, and the desired type.  An
implementation may choose to generate a somewhat differently worded
error message if it recognizes that PLACE is of a particular form, such
as one of the arguments to the function that called ‘check-type’.
string is allowed because some applications of ‘check-type’ may require
a more specific description of what is wanted than can be generated
automatically from TYPESPEC.

Examples:
.........

 (setq aardvarks '(sam harry fred))
→ (SAM HARRY FRED)
 (check-type aardvarks (array * (3)))
▷ Error: The value of AARDVARKS, (SAM HARRY FRED),
▷        is not a 3-long array.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a value to use instead.
▷  2: Return to Lisp Toplevel.
▷ Debug> :CONTINUE 1
▷ Use Value: #(SAM FRED HARRY)
→ NIL
 aardvarks
→ #<ARRAY-T-3 13571>
 (map 'list #'identity aardvarks)
→ (SAM FRED HARRY)
 (setq aardvark-count 'foo)
→ FOO
 (check-type aardvark-count (integer 0 *) "A positive integer")
▷ Error: The value of AARDVARK-COUNT, FOO, is not a positive integer.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a value to use instead.
▷  2: Top level.
▷ Debug> :CONTINUE 2

 (defmacro define-adder (name amount)
   (check-type name (and symbol (not null)) "a name for an adder function")
   (check-type amount integer)
   `(defun ,name (x) (+ x ,amount)))

 (macroexpand '(define-adder add3 3))
→ (defun add3 (x) (+ x 3))

 (macroexpand '(define-adder 7 7))
▷ Error: The value of NAME, 7, is not a name for an adder function.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a value to use instead.
▷  2: Top level.
▷ Debug> :Continue 1
▷ Specify a value to use instead.
▷ Type a form to be evaluated and used instead: 'ADD7
→ (defun add7 (x) (+ x 7))

 (macroexpand '(define-adder add5 something))
▷ Error: The value of AMOUNT, SOMETHING, is not an integer.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a value to use instead.
▷  2: Top level.
▷ Debug> :Continue 1
▷ Type a form to be evaluated and used instead: 5
→ (defun add5 (x) (+ x 5))

Control is transferred to a handler.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

The implementation.

See Also:
.........

*note Section 9.1 (Condition System Concepts): Condition System
Concepts.

Notes:
......

 (check-type PLACE TYPESPEC)
 ≡ (assert (typep PLACE 'TYPESPEC) (PLACE)
            'type-error :datum PLACE :expected-type 'TYPESPEC)


File: ansicl,  Node: simple-error,  Next: invalid-method-error,  Prev: check-type,  Up: Conditions

simple-error (Condition Type)
=============================

Class Precedence List:
......................

‘simple-error’, ‘simple-condition’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘simple-error’ consists of conditions that are signaled by
‘error’ or ‘cerror’ when a format control is supplied as the function's
first argument.


File: ansicl,  Node: invalid-method-error,  Next: method-combination-error,  Prev: simple-error,  Up: Conditions

invalid-method-error (Function)
===============================

Syntax:
.......

 -- Function: invalid-method-error method format-control &rest args →
          implementation-dependent

Arguments and Values:
.....................

METHOD--a method.

FORMAT-CONTROL--a format control.

ARGS--format arguments for the FORMAT-CONTROL.

Description:
............

The function ‘invalid-method-error’ is used to signal an error of type
‘error’ when there is an applicable method whose qualifiers are not
valid for the method combination type.  The error message is
constructed by using the FORMAT-CONTROL suitable for ‘format’ and any
ARGS to it.  Because an implementation may need to add additional
contextual information to the error message, ‘invalid-method-error’
should be called only within the dynamic extent of a method combination
function.

The function ‘invalid-method-error’ is called automatically when a
method fails to satisfy every qualifier pattern and predicate in a
‘define-method-combination’ form.  A method combination function that
imposes additional restrictions should call ‘invalid-method-error’
explicitly if it encounters a method it cannot accept.

Whether ‘invalid-method-error’ returns to its caller or exits via
‘throw’ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

See Also:
.........

*note define-method-combination::


File: ansicl,  Node: method-combination-error,  Next: signal,  Prev: invalid-method-error,  Up: Conditions

method-combination-error (Function)
===================================

Syntax:
.......

 -- Function: method-combination-error format-control &rest args →
          implementation-dependent

Arguments and Values:
.....................

FORMAT-CONTROL--a format control.

ARGS--format arguments for FORMAT-CONTROL.

Description:
............

The function ‘method-combination-error’ is used to signal an error in
method combination.

The error message is constructed by using a FORMAT-CONTROL suitable for
‘format’ and any ARGS to it.  Because an implementation may need to add
additional contextual information to the error message,
‘method-combination-error’ should be called only within the dynamic
extent of a method combination function.

Whether ‘method-combination-error’ returns to its caller or exits via
‘throw’ is implementation-dependent.

Side Effects:
.............

The debugger might be entered.

Affected By:
............

‘*break-on-signals*’

See Also:
.........

*note define-method-combination::


File: ansicl,  Node: signal,  Next: simple-condition,  Prev: method-combination-error,  Up: Conditions

signal (Function)
=================

Syntax:
.......

 -- Function: signal datum &rest arguments → ‘nil’

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
‘simple-condition’.

Description:
............

Signals the condition denoted by the given DATUM and ARGUMENTS.  If the
condition is not handled, ‘signal’ returns ‘nil’.

Examples:
.........

 (defun handle-division-conditions (condition)
   (format t "Considering condition for division condition handling~%")
   (when (and (typep condition 'arithmetic-error)
              (eq '/ (arithmetic-error-operation condition)))
     (invoke-debugger condition)))
HANDLE-DIVISION-CONDITIONS
 (defun handle-other-arithmetic-errors (condition)
   (format t "Considering condition for arithmetic condition handling~%")
   (when (typep condition 'arithmetic-error)
     (abort)))
HANDLE-OTHER-ARITHMETIC-ERRORS
 (define-condition a-condition-with-no-handler (condition) ())
A-CONDITION-WITH-NO-HANDLER
 (signal 'a-condition-with-no-handler)
NIL
 (handler-bind ((condition #'handle-division-conditions)
                  (condition #'handle-other-arithmetic-errors))
   (signal 'a-condition-with-no-handler))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
NIL
 (handler-bind ((arithmetic-error #'handle-division-conditions)
                  (arithmetic-error #'handle-other-arithmetic-errors))
   (signal 'arithmetic-error :operation '* :operands '(1.2 b)))
Considering condition for division condition handling
Considering condition for arithmetic condition handling
Back to Lisp Toplevel

Side Effects:
.............

The debugger might be entered due to ‘*break-on-signals*’.

Handlers for the condition being signaled might transfer control.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’

See Also:
.........

*note *break-on-signals*::, *note error (Function)::, *note
simple-condition::, *note Section 9.1.4 (Signaling and Handling
Conditions): Signaling and Handling Conditions.

Notes:
......

If ‘(typep DATUM *break-on-signals*)’ yields true, the debugger is
entered prior to beginning the signaling process.  the ‘continue’
restart can be used to continue with the signaling process.  This is
also true for all other functions and macros that should, might, or
must signal conditions.


File: ansicl,  Node: simple-condition,  Next: simple-condition-format-control; simple-condition-format-arguments,  Prev: signal,  Up: Conditions

simple-condition (Condition Type)
=================================

Class Precedence List:
......................

‘simple-condition’, ‘condition’, ‘t’

Description:
............

The type ‘simple-condition’ represents conditions that are signaled by
‘signal’ whenever a FORMAT-CONTROL is supplied as the function's first
argument.  The format control and format arguments are initialized with
the initialization arguments named :format-control and
:format-arguments to ‘make-condition’, and are accessed by the functions
‘simple-condition-format-control’ and
‘simple-condition-format-arguments’.  If format arguments are not
supplied to ‘make-condition’, ‘nil’ is used as a default.

See Also:
.........

*note simple-condition-format-control::, *note
simple-condition-format-arguments::


File: ansicl,  Node: simple-condition-format-control; simple-condition-format-arguments,  Next: warn,  Prev: simple-condition,  Up: Conditions

simple-condition-format-control, simple-condition-format-arguments (Function)
=============================================================================

Syntax:
.......

 -- Function: simple-condition-format-control condition → format-control

 -- Function: simple-condition-format-arguments condition →
          format-arguments

Arguments and Values:
.....................

CONDITION--a condition of type ‘simple-condition’.

FORMAT-CONTROL--a format control.

FORMAT-ARGUMENTS--a list.

Description:
............

‘simple-condition-format-control’ returns the format control needed to
process the CONDITION's format arguments.

‘simple-condition-format-arguments’ returns a list of format arguments
needed to process the CONDITION's format control.

Examples:
.........

 (setq foo (make-condition 'simple-condition
                          :format-control "Hi ~S"
                          :format-arguments '(ho)))
→ #<SIMPLE-CONDITION 26223553>
 (apply #'format nil (simple-condition-format-control foo)
                     (simple-condition-format-arguments foo))
→ "Hi HO"

See Also:
.........

*note simple-condition::, *note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: ansicl,  Node: warn,  Next: simple-warning,  Prev: simple-condition-format-control; simple-condition-format-arguments,  Up: Conditions

warn (Function)
===============

Syntax:
.......

 -- Function: warn datum &rest arguments → ‘nil’

Arguments and Values:
.....................

DATUM, ARGUMENTS--designators for a condition of default type
‘simple-warning’.

Description:
............

Signals a condition of type ‘warning’.  If the condition is not handled,
reports the condition to error output.

The precise mechanism for warning is as follows:

The warning condition is signaled
     While the ‘warning’ condition is being signaled, the
     ‘muffle-warning’ restart is established for use by a handler.  If
     invoked, this restart bypasses further action by ‘warn’, which in
     turn causes ‘warn’ to immediately return ‘nil’.

If no handler for the warning condition is found
     If no handlers for the warning condition are found, or if all such
     handlers decline, then the condition is reported to error output
     by ‘warn’ in an implementation-dependent format.

‘nil’ is returned
     The value returned by ‘warn’ if it returns is ‘nil’.

Examples:
.........

  (defun foo (x)
    (let ((result (* x 2)))
      (if (not (typep result 'fixnum))
          (warn "You're using very big numbers."))
      result))
→ FOO

  (foo 3)
→ 6

  (foo most-positive-fixnum)
▷ Warning: You're using very big numbers.
→ 4294967294

  (setq *break-on-signals* t)
→ T

  (foo most-positive-fixnum)
▷ Break: Caveat emptor.
▷ To continue, type :CONTINUE followed by an option number.
▷  1: Return from Break.
▷  2: Abort to Lisp Toplevel.
▷ Debug> :continue 1
▷ Warning: You're using very big numbers.
→ 4294967294

Side Effects:
.............

A warning is issued.  The debugger might be entered.

Affected By:
............

Existing handler bindings.

‘*break-on-signals*’, ‘*error-output*’.

Exceptional Situations:
.......................

If DATUM is a condition and if the condition is not of type ‘warning’,
or ARGUMENTS is non-nil, an error of type ‘type-error’ is signaled.

If DATUM is a condition type, the result of ‘(apply #'make-condition
datum arguments)’ must be of type ‘warning’ or an error of type
‘type-error’ is signaled.

See Also:
.........

*note *break-on-signals*::, *note muffle-warning::, *note signal::


File: ansicl,  Node: simple-warning,  Next: invoke-debugger,  Prev: warn,  Up: Conditions

simple-warning (Condition Type)
===============================

Class Precedence List:
......................

‘simple-warning’, ‘simple-condition’, ‘warning’, ‘condition’, ‘t’

Description:
............

The type ‘simple-warning’ represents conditions that are signaled by
‘warn’ whenever a format control is supplied as the function's first
argument.


File: ansicl,  Node: invoke-debugger,  Next: break,  Prev: simple-warning,  Up: Conditions

invoke-debugger (Function)
==========================

Syntax:
.......

 -- Function: invoke-debugger condition →|

Arguments and Values:
.....................

CONDITION--a condition object.

Description:
............

‘invoke-debugger’ attempts to enter the debugger with CONDITION.

If ‘*debugger-hook*’ is not ‘nil’, it should be a function (or the name
of a function) to be called prior to entry to the standard debugger.
The function is called with ‘*debugger-hook*’ bound to ‘nil’, and the
function must accept two arguments: the CONDITION and the value of
‘*debugger-hook*’ prior to binding it to ‘nil’.  If the function
returns normally, the standard debugger is entered.

The standard debugger never directly returns.  Return can occur only by
a non-local transfer of control, such as the use of a restart function.

Examples:
.........

 (ignore-errors ;Normally, this would suppress debugger entry
   (handler-bind ((error #'invoke-debugger)) ;But this forces debugger entry
     (error "Foo.")))
Debug: Foo.
To continue, type :CONTINUE followed by an option number:
 1: Return to Lisp Toplevel.
Debug>

Side Effects:
.............

‘*debugger-hook*’ is bound to ‘nil’, program execution is discontinued,
and the debugger is entered.

Affected By:
............

‘*debug-io*’ and ‘*debugger-hook*’.

See Also:
.........

*note error (Function)::, *note break::


File: ansicl,  Node: break,  Next: *debugger-hook*,  Prev: invoke-debugger,  Up: Conditions

break (Function)
================

Syntax:
.......

 -- Function: break &optional format-control &rest format-arguments →
          ‘nil’

Arguments and Values:
.....................

FORMAT-CONTROL--a format control.  The default is
implementation-dependent.

FORMAT-ARGUMENTS--format arguments for the FORMAT-CONTROL.

Description:
............

‘break’ formats FORMAT-CONTROL and FORMAT-ARGUMENTS and then goes
directly into the debugger without allowing any possibility of
interception by programmed error-handling facilities.

If the ‘continue’ restart is used while in the debugger, ‘break’
immediately returns ‘nil’ without taking any unusual recovery action.

‘break’ binds ‘*debugger-hook*’ to ‘nil’  before attempting to enter
the debugger.

Examples:
.........

 (break "You got here with arguments: ~:S." '(FOO 37 A))
▷ BREAK: You got here with these arguments: FOO, 37, A.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return from BREAK.
▷  2: Top level.
▷ Debug> :CONTINUE 1
▷ Return from BREAK.
→ NIL

Side Effects:
.............

The debugger is entered.

Affected By:
............

‘*debug-io*’.

See Also:
.........

*note error (Function)::, *note invoke-debugger::.

Notes:
......

‘break’ is used as a way of inserting temporary debugging "breakpoints"
in a program, not as a way of signaling errors.  For this reason,
‘break’ does not take the CONTINUE-FORMAT-CONTROL argument that
‘cerror’ takes.  This and the lack of any possibility of interception by
condition handling are the only program-visible differences between
‘break’ and ‘cerror’.

The user interface aspects of ‘break’ and ‘cerror’ are permitted to
vary more widely, in order to accomodate the interface needs of the
implementation. For example, it is permissible for a Lisp
read-eval-print loop to be entered by ‘break’ rather than the
conventional debugger.

‘break’ could be defined by:

 (defun break (&optional (format-control "Break") &rest format-arguments)
   (with-simple-restart (continue "Return from BREAK.")
     (let ((*debugger-hook* nil))
       (invoke-debugger
           (make-condition 'simple-condition
                           :format-control format-control
                           :format-arguments format-arguments))))
   nil)


File: ansicl,  Node: *debugger-hook*,  Next: *break-on-signals*,  Prev: break,  Up: Conditions

*debugger-hook* (Variable)
==========================

Value Type:
...........

a designator for a function of two arguments (a condition and the value
of ‘*debugger-hook*’ at the time the debugger was entered), or ‘nil’.

Initial Value:
..............

‘nil’.

Description:
............

When the value of ‘*debugger-hook*’ is non-nil, it is called prior to
normal entry into the debugger, either due to a call to
‘invoke-debugger’ or due to automatic entry into the debugger from a
call to ‘error’ or ‘cerror’ with a condition that is not handled.  The
function may either handle the condition (transfer control) or return
normally (allowing the standard debugger to run).  To minimize
recursive errors while debugging, ‘*debugger-hook*’ is bound to
‘nil’ by ‘invoke-debugger’ prior to calling the function.

Examples:
.........

 (defun one-of (choices &optional (prompt "Choice"))
   (let ((n (length choices)) (i))
     (do ((c choices (cdr c)) (i 1 (+ i 1)))
         ((null c))
       (format t "~&[~D] ~A~%" i (car c)))
     (do () ((typep i `(integer 1 ,n)))
       (format t "~&~A: " prompt)
       (setq i (read))
       (fresh-line))
     (nth (- i 1) choices)))

 (defun my-debugger (condition me-or-my-encapsulation)
   (format t "~&Fooey: ~A" condition)
   (let ((restart (one-of (compute-restarts))))
     (if (not restart) (error "My debugger got an error."))
     (let ((*debugger-hook* me-or-my-encapsulation))
       (invoke-restart-interactively restart))))

 (let ((*debugger-hook* #'my-debugger))
   (+ 3 'a))
▷ Fooey: The argument to +, A, is not a number.
▷  [1] Supply a replacement for A.
▷  [2] Return to Cloe Toplevel.
▷ Choice: 1
▷  Form to evaluate and use: (+ 5 'b)
▷  Fooey: The argument to +, B, is not a number.
▷  [1] Supply a replacement for B.
▷  [2] Supply a replacement for A.
▷  [3] Return to Cloe Toplevel.
▷ Choice: 1
▷  Form to evaluate and use: 1
→ 9

Affected By:
............

‘invoke-debugger’

Notes:
......

When evaluating code typed in by the user interactively, it is sometimes
useful to have the hook function bind ‘*debugger-hook*’ to the function
that was its second argument so that recursive errors can be handled
using the same interactive facility.


File: ansicl,  Node: *break-on-signals*,  Next: handler-bind,  Prev: *debugger-hook*,  Up: Conditions

*break-on-signals* (Variable)
=============================

Value Type:
...........

a type specifier.

Initial Value:
..............

‘nil’.

Description:
............

When ‘(typep condition *break-on-signals*)’ returns true, calls to
‘signal’, and to other operators such as ‘error’ that implicitly call
‘signal’, enter the debugger prior to signaling the condition.

the ‘continue’ restart can be used to continue with the normal
signaling process when a break occurs process due to
‘*break-on-signals*’.

Examples:
.........

 *break-on-signals* → NIL
 (ignore-errors (error 'simple-error :format-control "Fooey!"))
→ NIL, #<SIMPLE-ERROR 32207172>

 (let ((*break-on-signals* 'error))
   (ignore-errors (error 'simple-error :format-control "Fooey!")))
▷ Break: Fooey!
▷ BREAK entered because of *BREAK-ON-SIGNALS*.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Continue to signal.
▷  2: Top level.
▷ Debug> :CONTINUE 1
▷ Continue to signal.
→ NIL, #<SIMPLE-ERROR 32212257>

 (let ((*break-on-signals* 'error))
   (error 'simple-error :format-control "Fooey!"))
▷ Break: Fooey!
▷ BREAK entered because of *BREAK-ON-SIGNALS*.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Continue to signal.
▷  2: Top level.
▷ Debug> :CONTINUE 1
▷ Continue to signal.
▷ Error: Fooey!
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Top level.
▷ Debug> :CONTINUE 1
▷ Top level.

See Also:
.........

*note break::, *note signal::, *note warn::, *note error (Function)::,
*note typep::, *note Section 9.1 (Condition System Concepts): Condition
System Concepts.

Notes:
......

‘*break-on-signals*’ is intended primarily for use in debugging code
that does signaling.   When setting ‘*break-on-signals*’, the user is
encouraged to choose the most restrictive specification that suffices.
Setting ‘*break-on-signals*’ effectively violates the modular handling
of condition signaling.  In practice, the complete effect of setting
‘*break-on-signals*’ might be unpredictable in some cases since the user
might not be aware of the variety or number of calls to ‘signal’ that
are used in code called only incidentally.

‘*break-on-signals*’ enables an early entry to the debugger but such an
entry does not preclude an additional entry to the debugger in the case
of operations such as ‘error’ and ‘cerror’.


File: ansicl,  Node: handler-bind,  Next: handler-case,  Prev: *break-on-signals*,  Up: Conditions

handler-bind (Macro)
====================

Syntax:
.......

 -- Macro: handler-bind ({↓binding}*) {form}* → {result}*

BINDING::=
     (type handler)

Arguments and Values:
.....................

TYPE--a type specifier.

HANDLER--a form; evaluated to produce a HANDLER-FUNCTION.

HANDLER-FUNCTION--a designator for a function of one argument.

FORMS--an implicit progn.

RESULTS--the values returned by the forms.

Description:
............

Executes FORMS in a dynamic environment where the indicated HANDLER
bindings are in effect.

Each HANDLER should evaluate to a handler-function, which is used to
handle conditions of the given TYPE during execution of the FORMS.
This function should take a single argument, the condition being
signaled.

If more than one HANDLER binding is supplied, the HANDLER bindings are
searched sequentially from top to bottom in search of a match (by
visual analogy with ‘typecase’).  If an appropriate type is found, the
associated handler is run in a dynamic environment where none of these
HANDLER bindings are visible (to avoid recursive errors).  If the
handler declines, the search continues for another handler.

If no appropriate handler is found, other handlers are sought from
dynamically enclosing contours.  If no handler is found outside, then
‘signal’ returns or ‘error’ enters the debugger.

Examples:
.........

In the following code, if an unbound variable error is signaled in the
body (and not handled by an intervening handler), the first function is
called.

 (handler-bind ((unbound-variable #'(lambda ...))
                (error #'(lambda ...)))
   ...)

If any other kind of error is signaled, the second function is called.
In either case, neither handler is active while executing the code in
the associated function.

 (defun trap-error-handler (condition)
   (format *error-output* "~&~A~&" condition)
   (throw 'trap-errors nil))

 (defmacro trap-errors (&rest forms)
   `(catch 'trap-errors
      (handler-bind ((error #'trap-error-handler))
        ,@forms)))

 (list (trap-errors (signal "Foo.") 1)
       (trap-errors (error  "Bar.") 2)
       (+ 1 2))
▷ Bar.
→ (1 NIL 3)

Note that "Foo." is not printed because the condition made by ‘signal’
is a simple condition, which is not of type ‘error’, so it doesn't
trigger the handler for ‘error’ set up by ‘trap-errors’.

See Also:
.........

*note handler-case::


File: ansicl,  Node: handler-case,  Next: ignore-errors,  Prev: handler-bind,  Up: Conditions

handler-case (Macro)
====================

Syntax:
.......

 -- Macro: handler-case EXPRESSION 〚{↓error-clause}* |
          ↓no-error-clause〛 → {result}*

CLAUSE::=
     ↓error-clause | ↓no-error-clause

ERROR-CLAUSE::=
     (typespec ([var]) {declaration}* {form}*)

NO-ERROR-CLAUSE::=
     (:no-error LAMBDA-LIST {declaration}* {form}*)

Arguments and Values:
.....................

EXPRESSION--a form.

TYPESPEC--a type specifier.

VAR--a variable name.

LAMBDA-LIST--an ordinary lambda list.

DECLARATION--a declare expression; not evaluated.

FORM--a form.

RESULTS--In the normal situation, the values returned are those that
result from the evaluation of EXPRESSION; in the exceptional situation
when control is transferred to a CLAUSE, the value of the last FORM in
that CLAUSE is returned.

Description:
............

‘handler-case’ executes EXPRESSION in a dynamic environment where
various handlers are active.  Each error-clause specifies how to handle
a condition matching the indicated TYPESPEC.  A no-error-clause allows
the specification of a particular action if control returns normally.

If a condition is signaled for which there is an appropriate
error-clause during the execution of EXPRESSION (i.e., one for which
‘(typep condition 'TYPESPEC)’ returns true) and if there is no
intervening handler for a condition of that type, then control is
transferred to the body of the relevant error-clause.  In this case, the
dynamic state is unwound appropriately (so that the handlers established
around the EXPRESSION are no longer active), and VAR is bound to the
condition that had been signaled.  If more than one case is provided,
those cases are made accessible in parallel.  That is, in

  (handler-case form
    (typespec1 (var1) form1)
    (typespec2 (var2) form2))

if the first clause (containing form1) has been selected, the handler
for the second is no longer visible (or vice versa).

The clauses are searched sequentially from top to bottom. If there is
type overlap between TYPESPECS, the earlier of the clauses is selected.

If VAR is not needed, it can be omitted. That is, a clause such as:

  (TYPESPEC (VAR) (declare (ignore VAR)) FORM)

can be written ‘(TYPESPEC () FORM)’.

If there are no FORMS in a selected clause, the case, and therefore
‘handler-case’, returns ‘nil’.  If execution of EXPRESSION returns
normally and no no-error-clause exists, the values returned by
EXPRESSION are returned by ‘handler-case’.  If execution of EXPRESSION
returns normally and a no-error-clause does exist, the values returned
are used as arguments to the function described by constructing
‘(lambda LAMBDA-LIST {form}*)’ from the no-error-clause, and the values
of that function call are returned by ‘handler-case’.  The handlers
which were established around the EXPRESSION are no longer active at
the time of this call.

Examples:
.........

 (defun assess-condition (condition)
   (handler-case (signal condition)
     (warning () "Lots of smoke, but no fire.")
     ((or arithmetic-error control-error cell-error stream-error)
        (condition)
       (format nil "~S looks especially bad." condition))
     (serious-condition (condition)
       (format nil "~S looks serious." condition))
     (condition () "Hardly worth mentioning.")))
→ ASSESS-CONDITION
 (assess-condition (make-condition 'stream-error :stream *terminal-io*))
→ "#<STREAM-ERROR 12352256> looks especially bad."
 (define-condition random-condition (condition) ()
   (:report (lambda (condition stream)
              (declare (ignore condition))
              (princ "Yow" stream))))
→ RANDOM-CONDITION
 (assess-condition (make-condition 'random-condition))
→ "Hardly worth mentioning."

See Also:
.........

*note handler-bind::, *note ignore-errors::, *note Section 9.1
(Condition System Concepts): Condition System Concepts.

Notes:
......

 (handler-case form
   (type1 (var1) . body1)
   (type2 (var2) . body2) ...)

is approximately equivalent to:

 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
     (tagbody
       (handler-bind ((type1 #'(lambda (temp)
                                       (setq #1# temp)
                                       (go #3=#:g0003)))
                      (type2 #'(lambda (temp)
                                       (setq #2# temp)
                                       (go #4=#:g0004))) ...)
       (return-from #1# form))
         #3# (return-from #1# (let ((var1 #2#)) . body1))
         #4# (return-from #1# (let ((var2 #2#)) . body2)) ...)))

 (handler-case form
   (type1 (var1) . body1)
   ...
   (:no-error (varN-1 varN-2 ...) . bodyN))

is approximately equivalent to:


 (block #1=#:error-return
  (multiple-value-call #'(lambda (varN-1 varN-2 ...) . bodyN)
     (block #2=#:normal-return
       (return-from #1#
         (handler-case (return-from #2# form)
           (type1 (var1) . body1) ...)))))


File: ansicl,  Node: ignore-errors,  Next: define-condition,  Prev: handler-case,  Up: Conditions

ignore-errors (Macro)
=====================

Syntax:
.......

 -- Macro: ignore-errors {form}* → {result}*

Arguments and Values:
.....................

FORMS--an implicit progn.

RESULTS--In the normal situation, the values of the forms are returned;
in the exceptional situation, two values are returned: ‘nil’ and the
condition.

Description:
............

‘ignore-errors’ is used to prevent conditions of type ‘error’ from
causing entry into the debugger.

Specifically, ‘ignore-errors’ executes forms in a dynamic environment
where a handler for conditions of type ‘error’ has been established; if
invoked, it handles such conditions by returning two values, ‘nil’ and
the condition that was signaled, from the ‘ignore-errors’ form.

If a normal return from the forms occurs, any values returned are
returned by ‘ignore-errors’.

Examples:
.........

 (defun load-init-file (program)
   (let ((win nil))
     (ignore-errors ;if this fails, don't enter debugger
       (load (merge-pathnames (make-pathname :name program :type :lisp)
                              (user-homedir-pathname)))
       (setq win t))
     (unless win (format t "~&Init file failed to load.~%"))
     win))

 (load-init-file "no-such-program")
▷ Init file failed to load.
NIL

See Also:
.........

*note handler-case::, *note Section 9.1 (Condition System Concepts):
Condition System Concepts.

Notes:
......

 (ignore-errors . forms)

is equivalent to:

 (handler-case (progn . forms)
   (error (condition) (values nil condition)))

Because the second return value is a condition in the exceptional case,
it is common (but not required) to arrange for the second return value
in the normal case to be missing or ‘nil’ so that the two situations
can be distinguished.


File: ansicl,  Node: define-condition,  Next: make-condition,  Prev: ignore-errors,  Up: Conditions

define-condition (Macro)
========================

Syntax:
.......

 -- Macro: define-condition name ({parent-type}*) ({↓slot-spec}*)
          {option}* → name

SLOT-SPEC::=
     slot-name | (slot-name ↓slot-option)

SLOT-OPTION::=
     〚 {:reader symbol}* |
     {:writer ↓function-name}* |
     {:accessor symbol}* |
     {:allocation ↓allocation-type} |
     {:initarg symbol}* |
     {:initform form} |
     {:type TYPE-SPECIFIER} 〛

OPTION::=
     〚 (:default-initargs ‘.’ INITARG-LIST) |
     (:documentation string) |
     (:report report-name) 〛

FUNCTION-NAME::=
     {symbol | ‘(setf symbol)’}

ALLOCATION-TYPE::=
     :instance | :class

REPORT-NAME::=
     string | symbol | lambda expression

Arguments and Values:
.....................

NAME--a symbol.

PARENT-TYPE--a symbol naming a condition type.  If no PARENT-TYPES are
supplied, the PARENT-TYPES default to ‘(condition)’.

DEFAULT-INITARGS--a list of keyword/value pairs.

SLOT-SPEC--the name of a slot or a list consisting of the SLOT-NAME
followed by zero or more SLOT-OPTIONS.

SLOT-NAME--a slot name (a symbol), the list of a slot name, or the list
of slot name/slot form pairs.

OPTION--Any of the following:

:reader
     :reader can be supplied more than once for a given slot and cannot
     be ‘nil’.

:writer
     :writer can be supplied more than once for a given slot and must
     name a generic function.

:accessor
     :accessor can be supplied more than once for a given slot and
     cannot be ‘nil’.

:allocation
     :allocation can be supplied once at most for a given slot.  The
     default if :allocation is not supplied is :instance.

:initarg
     :initarg can be supplied more than once for a given slot.

:initform
     :initform can be supplied once at most for a given slot.

:type
     :type can be supplied once at most for a given slot.

:documentation
     :documentation can be supplied once at most for a given slot.

:report
     :report can be supplied once at most.

Description:
............

‘define-condition’ defines a new condition type called NAME, which is a
subtype of the type or types named by PARENT-TYPE.  Each PARENT-TYPE
argument specifies a direct supertype of the new condition. The new
condition inherits slots and methods from each of its direct
supertypes, and so on.

If a slot name/slot form pair is supplied, the slot form is a form that
can be evaluated by ‘make-condition’ to produce a default value when an
explicit value is not provided.  If no slot form is supplied, the
contents of the SLOT is initialized in an implementation-dependent way.

If the type being defined and some other type from which it inherits
have a slot by the same name, only one slot is allocated in the
condition, but the supplied slot form overrides any slot form that
might otherwise have been inherited from a PARENT-TYPE.  If no slot
form is supplied, the inherited slot form (if any) is still visible.

Accessors are created according to the same rules as used by ‘defclass’.

A description of SLOT-OPTIONS follows:

:reader
     The :reader slot option specifies that an unqualified method is to
     be defined on the generic function named by the argument to
     :reader to read the value of the given slot.

*
     The :initform slot option is used to provide a default initial
     value form to be used in the initialization of the slot.  This
     form is evaluated every time it is used to initialize the slot.
     The lexical environment in which this form is evaluated is the
     lexical environment in which the ‘define-condition’ form was
     evaluated.  Note that the lexical environment refers both to
     variables and to functions.  For local slots, the dynamic
     environment is the dynamic environment in which ‘make-condition’
     was called; for shared slots, the dynamic environment is the
     dynamic environment in which the ‘define-condition’ form was
     evaluated.

     No implementation is permitted to extend the syntax of
     ‘define-condition’ to allow ‘(SLOT-NAME FORM)’ as an abbreviation
     for ‘(SLOT-NAME :initform FORM)’.

:initarg
     The :initarg slot option declares an initialization argument named
     by its symbol argument and specifies that this initialization
     argument initializes the given slot.  If the initialization
     argument has a value in the call to ‘initialize-instance’, the
     value is stored into the given slot, and the slot's :initform slot
     option, if any, is not evaluated.  If none of the initialization
     arguments specified for a given slot has a value, the slot is
     initialized according to the :initform slot option, if specified.

:type
     The :type slot option specifies that the contents of the slot is
     always of the specified type.  It effectively declares the result
     type of the reader generic function when applied to an object of
     this condition type.  The consequences of attempting to store in a
     slot a value that does not satisfy the type of the slot is
     undefined.

:default-initargs
     This option is treated the same as it would be ‘defclass’.

:documentation
     The :documentation slot option provides a documentation string for
     the slot.

:report
     Condition reporting is mediated through the ‘print-object’ method
     for the condition type in question, with ‘*print-escape*’ always
     being ‘nil’. Specifying ‘(:report REPORT-NAME)’ in the definition
     of a condition type ‘C’ is equivalent to:

      (defmethod print-object ((x c) stream)
        (if *print-escape* (call-next-method) (REPORT-NAME x stream)))

     If the value supplied by the argument to :report (REPORT-NAME) is
     a symbol or a lambda expression, it must be acceptable to
     ‘function’. ‘(function REPORT-NAME)’ is evaluated in the current
     lexical environment.  It should return a function of two
     arguments, a condition and a stream, that prints on the stream a
     description of the condition.  This function is called whenever the
     condition is printed while ‘*print-escape*’ is ‘nil’.

     If REPORT-NAME is a string, it is a shorthand for

      (lambda (condition stream)
        (declare (ignore condition))
        (write-string REPORT-NAME stream))

     This option is processed after the new condition type has been
     defined, so use of the SLOT accessors within the :report function
     is permitted.  If this option is not supplied, information about
     how to report this type of condition is inherited from the
     PARENT-TYPE.

The consequences are unspecifed if an attempt is made to read a SLOT
that has not been explicitly initialized and that has not been given a
default value.

The consequences are unspecified if an attempt is made to assign the
SLOTS by using ‘setf’.

If a ‘define-condition’ form appears as a top level form, the compiler
must make NAME recognizable as a valid type name, and it must be
possible to reference the condition type as the PARENT-TYPE of another
condition type in a subsequent ‘define-condition’ form in the file
being compiled.

Examples:
.........

The following form defines a condition of type ‘peg/hole-mismatch’
which inherits from a condition type called ‘blocks-world-error’:

(define-condition peg/hole-mismatch
                  (blocks-world-error)
                  ((peg-shape  :initarg :peg-shape
                               :reader peg/hole-mismatch-peg-shape)
                   (hole-shape :initarg :hole-shape
                               :reader peg/hole-mismatch-hole-shape))
  (:report (lambda (condition stream)
             (format stream "A ~A peg cannot go in a ~A hole."
                     (peg/hole-mismatch-peg-shape  condition)
                     (peg/hole-mismatch-hole-shape condition)))))

The new type has slots ‘peg-shape’ and ‘hole-shape’, so
‘make-condition’ accepts ‘:peg-shape’ and ‘:hole-shape’ keywords.  The
readers ‘peg/hole-mismatch-peg-shape’ and ‘peg/hole-mismatch-hole-shape’
apply to objects of this type, as illustrated in the :report
information.

The following form defines a condition type named ‘machine-error’ which
inherits from ‘error’:

(define-condition machine-error
                  (error)
                  ((machine-name :initarg :machine-name
                                 :reader machine-error-machine-name))
  (:report (lambda (condition stream)
             (format stream "There is a problem with ~A."
                     (machine-error-machine-name condition)))))

Building on this definition, a new error condition can be defined which
is a subtype of ‘machine-error’ for use when machines are not available:

(define-condition machine-not-available-error (machine-error) ()
  (:report (lambda (condition stream)
             (format stream "The machine ~A is not available."
                     (machine-error-machine-name condition)))))

This defines a still more specific condition, built upon
‘machine-not-available-error’, which provides a slot initialization form
for ‘machine-name’ but which does not provide any new slots or report
information.  It just gives the ‘machine-name’ slot a default
initialization:

(define-condition my-favorite-machine-not-available-error
                  (machine-not-available-error)
  ((machine-name :initform "mc.lcs.mit.edu")))

Note that since no :report clause was given, the information inherited
from ‘machine-not-available-error’ is used to report this type of
condition.

 (define-condition ate-too-much (error)
     ((person :initarg :person :reader ate-too-much-person)
      (weight :initarg :weight :reader ate-too-much-weight)
      (kind-of-food :initarg :kind-of-food
                    :reader :ate-too-much-kind-of-food)))
→ ATE-TOO-MUCH
 (define-condition ate-too-much-ice-cream (ate-too-much)
   ((kind-of-food :initform 'ice-cream)
    (flavor       :initarg :flavor
                  :reader ate-too-much-ice-cream-flavor
                  :initform 'vanilla ))
   (:report (lambda (condition stream)
              (format stream "~A ate too much ~A ice-cream"
                      (ate-too-much-person condition)
                      (ate-too-much-ice-cream-flavor condition)))))
→ ATE-TOO-MUCH-ICE-CREAM
 (make-condition 'ate-too-much-ice-cream
                 :person 'fred
                 :weight 300
                 :flavor 'chocolate)
→ #<ATE-TOO-MUCH-ICE-CREAM 32236101>
 (format t "~A" *)
▷ FRED ate too much CHOCOLATE ice-cream
→ NIL

See Also:
.........

*note make-condition::, *note defclass::, *note Section 9.1 (Condition
System Concepts): Condition System Concepts.


File: ansicl,  Node: make-condition,  Next: restart,  Prev: define-condition,  Up: Conditions

make-condition (Function)
=========================

Syntax:
.......

 -- Function: make-condition type &rest slot-initializations → condition

Arguments and Values:
.....................

TYPE--a type specifier (for a subtype of ‘condition’).

SLOT-INITIALIZATIONS--an initialization argument list.

CONDITION--a condition.

Description:
............

Constructs and returns a condition of type TYPE using
SLOT-INITIALIZATIONS for the initial values of the slots.  The newly
created condition is returned.

Examples:
.........

 (defvar *oops-count* 0)

 (setq a (make-condition 'simple-error
                         :format-control "This is your ~:R error."
                         :format-arguments (list (incf *oops-count*))))
→ #<SIMPLE-ERROR 32245104>

 (format t "~&~A~%" a)
▷ This is your first error.
→ NIL

 (error a)
▷ Error: This is your first error.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return to Lisp Toplevel.
▷ Debug>

Affected By:
............

The set of defined condition types.

See Also:
.........

*note define-condition::, *note Section 9.1 (Condition System
Concepts): Condition System Concepts.


File: ansicl,  Node: restart,  Next: compute-restarts,  Prev: make-condition,  Up: Conditions

restart (System Class)
======================

Class Precedence List:
......................

‘restart’, ‘t’

Description:
............

An object of type ‘restart’ represents a function that can be called to
perform some form of recovery action, usually a transfer of control to
an outer point in the running program.

An implementation is free to implement a restart in whatever manner is
most convenient; a restart has only dynamic extent relative to the
scope of the binding form which establishes it.


File: ansicl,  Node: compute-restarts,  Next: find-restart,  Prev: restart,  Up: Conditions

compute-restarts (Function)
===========================

Syntax:
.......

 -- Function: compute-restarts &optional condition → restarts

Arguments and Values:
.....................

CONDITION--a condition object, or ‘nil’.

RESTARTS--a list of restarts.

Description:
............

‘compute-restarts’ uses the dynamic state of the program to compute a
list of the restarts which are currently active.

The resulting list is ordered so that the innermost (more-recently
established) restarts are nearer the head of the list.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

‘compute-restarts’ returns all applicable restarts, including anonymous
ones, even if some of them have the same name as others and would
therefore not be found by ‘find-restart’ when given a symbol argument.

Implementations are permitted, but not required, to return distinct
lists from repeated calls to ‘compute-restarts’ while in the same
dynamic environment.  The consequences are undefined if the list
returned by ‘compute-restarts’ is every modified.

Examples:
.........

 ;; One possible way in which an interactive debugger might present
 ;; restarts to the user.
 (defun invoke-a-restart ()
   (let ((restarts (compute-restarts)))
     (do ((i 0 (+ i 1)) (r restarts (cdr r))) ((null r))
       (format t "~&~D: ~A~%" i (car r)))
     (let ((n nil) (k (length restarts)))
       (loop (when (and (typep n 'integer) (>= n 0) (< n k))
               (return t))
             (format t "~&Option: ")
             (setq n (read))
             (fresh-line))
       (invoke-restart-interactively (nth n restarts)))))

 (restart-case (invoke-a-restart)
   (one () 1)
   (two () 2)
   (nil () :report "Who knows?" 'anonymous)
   (one () 'I)
   (two () 'II))
▷ 0: ONE
▷ 1: TWO
▷ 2: Who knows?
▷ 3: ONE
▷ 4: TWO
▷ 5: Return to Lisp Toplevel.
▷ Option: 4
→ II

 ;; Note that in addition to user-defined restart points, COMPUTE-RESTARTS
 ;; also returns information about any system-supplied restarts, such as
 ;; the "Return to Lisp Toplevel" restart offered above.

Affected By:
............

Existing restarts.

See Also:
.........

*note find-restart::, *note invoke-restart::, *note restart-bind::


File: ansicl,  Node: find-restart,  Next: invoke-restart,  Prev: compute-restarts,  Up: Conditions

find-restart (Function)
=======================

Syntax:
.......

 -- Function: find-restart identifier &optional condition → restart

Arguments and Values:
.....................

IDENTIFIER--a non-nil symbol, or a restart.

CONDITION--a condition object, or ‘nil’.

RESTART--a restart or ‘nil’.

Description:
............

‘find-restart’ searches for a particular restart in the current dynamic
environment.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

If IDENTIFIER is a symbol, then the innermost (most recently
established) applicable restart with that name is returned.  ‘nil’ is
returned if no such restart is found.

If IDENTIFIER is a currently active restart, then it is returned.
Otherwise, ‘nil’ is returned.

Examples:
.........

 (restart-case
     (let ((r (find-restart 'my-restart)))
       (format t "~S is named ~S" r (restart-name r)))
   (my-restart () nil))
▷ #<RESTART 32307325> is named MY-RESTART
→ NIL
 (find-restart 'my-restart)
→ NIL

Affected By:
............

Existing restarts.

‘restart-case’, ‘restart-bind’, ‘with-condition-restarts’.

See Also:
.........

*note compute-restarts::

Notes:
......

 (find-restart IDENTIFIER)
 ≡ (find IDENTIFIER (compute-restarts) :key :restart-name)

Although anonymous restarts have a name of ‘nil’, the consequences are
unspecified if ‘nil’ is given as an IDENTIFIER.  Occasionally,
programmers lament that ‘nil’ is not permissible as an IDENTIFIER
argument.  In most such cases, ‘compute-restarts’ can probably be used
to simulate the desired effect.


File: ansicl,  Node: invoke-restart,  Next: invoke-restart-interactively,  Prev: find-restart,  Up: Conditions

invoke-restart (Function)
=========================

Syntax:
.......

 -- Function: invoke-restart restart &rest arguments → {result}*

Arguments and Values:
.....................

RESTART--a restart designator.

ARGUMENT--an object.

RESULTS--the values returned by the function associated with RESTART,
if that function returns.

Description:
............

Calls the function associated with RESTART, passing ARGUMENTS to it.
RESTART must be valid in the current dynamic environment.

Examples:
.........

 (defun add3 (x) (check-type x number) (+ x 3))

 (foo 'seven)
▷ Error: The value SEVEN was not of type NUMBER.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a different value to use.
▷  2: Return to Lisp Toplevel.
▷ Debug> (invoke-restart 'store-value 7)
→ 10

Side Effects:
.............

A non-local transfer of control might be done by the restart.

Affected By:
............

Existing restarts.

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ‘control-error’ is signaled.

See Also:
.........

*note find-restart::, *note restart-bind::, *note restart-case::, *note
invoke-restart-interactively::

Notes:
......

The most common use for ‘invoke-restart’ is in a handler.  It might be
used explicitly, or implicitly through ‘invoke-restart-interactively’
or a restart function.

Restart functions call ‘invoke-restart’, not vice versa.  That is,
invoke-restart provides primitive functionality, and restart functions
are non-essential "syntactic sugar."


File: ansicl,  Node: invoke-restart-interactively,  Next: restart-bind,  Prev: invoke-restart,  Up: Conditions

invoke-restart-interactively (Function)
=======================================

Syntax:
.......

 -- Function: invoke-restart-interactively restart → {result}*

Arguments and Values:
.....................

RESTART--a restart designator.

RESULTS--the values returned by the function associated with RESTART,
if that function returns.

Description:
............

‘invoke-restart-interactively’ calls the function associated with
RESTART, prompting for any necessary arguments.  If RESTART is a name,
it must be valid in the current dynamic environment.

‘invoke-restart-interactively’ prompts for arguments by executing the
code provided in the :interactive keyword to ‘restart-case’ or
:interactive-function keyword to ‘restart-bind’.

If no such options have been supplied in the corresponding
‘restart-bind’ or ‘restart-case’, then the consequences are undefined
if the RESTART takes required arguments.  If the arguments are
optional, an argument list of ‘nil’ is used.

Once the arguments have been determined, ‘invoke-restart-interactively’
executes the following:

 (apply #'invoke-restart restart arguments)

Examples:
.........

 (defun add3 (x) (check-type x number) (+ x 3))

 (add3 'seven)
▷ Error: The value SEVEN was not of type NUMBER.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a different value to use.
▷  2: Return to Lisp Toplevel.
▷ Debug> (invoke-restart-interactively 'store-value)
▷ Type a form to evaluate and use: 7
→ 10

Side Effects:
.............

If prompting for arguments is necesary, some typeout may occur (on
query I/O).

A non-local transfer of control might be done by the restart.

Affected By:
............

‘*query-io*’, active restarts

Exceptional Situations:
.......................

If RESTART is not valid, an error of type ‘control-error’ is signaled.

See Also:
.........

*note find-restart::, *note invoke-restart::, *note restart-case::,
*note restart-bind::

Notes:
......

‘invoke-restart-interactively’ is used internally by the debugger and
may also be useful in implementing other portable, interactive debugging
tools.


File: ansicl,  Node: restart-bind,  Next: restart-case,  Prev: invoke-restart-interactively,  Up: Conditions

restart-bind (Macro)
====================

Syntax:
.......

 -- Macro: restart-bind ({(name function {↓key-val-pair}*)}) {form}* →
          {result}*

KEY-VAL-PAIR::=
     :interactive-function interactive-function |
     :report-function report-function |
     :test-function test-function

Arguments and Values:
.....................

NAME--a symbol; not evaluated.

FUNCTION--a form; evaluated.

FORMS--an implicit progn.

INTERACTIVE-FUNCTION--a form; evaluated.

REPORT-FUNCTION--a form; evaluated.

TEST-FUNCTION--a form; evaluated.

RESULTS--the values returned by the forms.

Description:
............

‘restart-bind’ executes the body of FORMS in a dynamic environment
where restarts with the given NAMES are in effect.

If a NAME is ‘nil’, it indicates an anonymous restart; if a NAME is a
non-nil symbol, it indicates a named restart.

The FUNCTION, INTERACTIVE-FUNCTION, and REPORT-FUNCTION are
unconditionally evaluated in the current lexical and dynamic environment
prior to evaluation of the body. Each of these forms must evaluate to a
function.

If ‘invoke-restart’ is done on that restart, the function which
resulted from evaluating FUNCTION is called, in the dynamic environment
of the ‘invoke-restart’, with the arguments given to ‘invoke-restart’.
The function may either perform a non-local transfer of control or may
return normally.

If the restart is invoked interactively from the debugger (using
‘invoke-restart-interactively’), the arguments are defaulted by calling
the function which resulted from evaluating INTERACTIVE-FUNCTION.  That
function may optionally prompt interactively on query I/O, and should
return a list of arguments to be used by ‘invoke-restart-interactively’
when invoking the restart.

If a restart is invoked interactively but no INTERACTIVE-FUNCTION is
used, then an argument list of ‘nil’ is used. In that case, the function
must be compatible with an empty argument list.

If the restart is presented interactively (e.g., by the debugger), the
presentation is done by calling the function which resulted from
evaluating REPORT-FUNCTION.  This function must be a function of one
argument, a stream.  It is expected to print a description of the
action that the restart takes to that stream.  This function is called
any time the restart is printed while ‘*print-escape*’ is ‘nil’.

In the case of interactive invocation, the result is dependent on the
value of :interactive-function as follows.

:interactive-function
     VALUE is evaluated in the current lexical environment and should
     return a function of no arguments which constructs a list of
     arguments to be used by ‘invoke-restart-interactively’ when
     invoking this restart.  The function may prompt interactively
     using query I/O if necessary.

:report-function
     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a stream, which prints on the
     stream a summary of the action that this restart takes.  This
     function is called whenever the restart is reported (printed while
     ‘*print-escape*’ is ‘nil’).  If no :report-function option is
     provided, the manner in which the restart is reported is
     implementation-dependent.

:test-function
     VALUE is evaluated in the current lexical environment and should
     return a function of one argument, a condition, which returns true
     if the restart is to be considered visible.

Affected By:
............

‘*query-io*’.

See Also:
.........

*note restart-case::, *note with-simple-restart::

Notes:
......

‘restart-bind’ is primarily intended to be used to implement
‘restart-case’ and  might be useful in implementing other macros.
Programmers who are uncertain about whether to use ‘restart-case’ or
‘restart-bind’ should prefer ‘restart-case’ for the cases where it is
powerful enough, using ‘restart-bind’ only in cases where its full
generality is really needed.


File: ansicl,  Node: restart-case,  Next: restart-name,  Prev: restart-bind,  Up: Conditions

restart-case (Macro)
====================

Syntax:
.......

 -- Macro: restart-case restartable-form {↓clause} → {result}*

CLAUSE::=
     ( case-name lambda-list
      〚:interactive interactive-expression | :report report-expression
     | :test test-expression〛
      {declaration}* {form}*)

Arguments and Values:
.....................

RESTARTABLE-FORM--a form.

CASE-NAME--a symbol or ‘nil’.

LAMBDA-LIST--an ordinary lambda list.

INTERACTIVE-EXPRESSION--a symbol or a lambda expression.

REPORT-EXPRESSION--a string, a symbol, or a lambda expression.

TEST-EXPRESSION--a symbol or a lambda expression.

DECLARATION--a declare expression; not evaluated.

FORM--a form.

RESULTS--the values resulting from the evaluation of RESTARTABLE-FORM,
or the values returned by the last FORM executed in a chosen clause, or
‘nil’.

Description:
............

‘restart-case’ evaluates RESTARTABLE-FORM in a dynamic environment
where the clauses have special meanings as points to which control may
be transferred.  If RESTARTABLE-FORM finishes executing and returns any
values, all values returned are returned by ‘restart-case’ and
processing has completed. While RESTARTABLE-FORM is executing, any code
may transfer control to one of the clauses (see ‘invoke-restart’).  If
a transfer occurs, the forms in the body of that clause is evaluated
and any values returned by the last such form are returned by
‘restart-case’.  In this case, the dynamic state is unwound
appropriately (so that the restarts established around the
RESTARTABLE-FORM are no longer active) prior to execution of the clause.

If there are no FORMS in a selected clause, ‘restart-case’ returns
‘nil’.

If CASE-NAME is a symbol, it names this restart.

It is possible to have more than one clause use the same CASE-NAME.  In
this case, the first clause with that name is found by ‘find-restart’.
The other clauses are accessible using ‘compute-restarts’.

Each ARGLIST is an ordinary lambda list to be bound during the
execution of its corresponding FORMS.  These parameters are used by the
‘restart-case’ clause to receive any necessary data from a call to
‘invoke-restart’.

By default, ‘invoke-restart-interactively’ passes no arguments and all
arguments must be optional in order to accomodate interactive
restarting.  However, the arguments need not be optional if the
:interactive keyword has been used to inform
‘invoke-restart-interactively’ about how to compute a proper argument
list.

KEYWORD options have the following meaning.

:interactive
     The VALUE supplied by ‘:interactive VALUE’ must be a suitable
     argument to ‘function’.  ‘(function VALUE)’ is evaluated in the
     current lexical environment.  It should return a function of no
     arguments which returns arguments to be used by
     ‘invoke-restart-interactively’ when it is invoked.
     ‘invoke-restart-interactively’ is called in the dynamic
     environment available prior to any restart attempt, and uses query
     I/O for user interaction.

     If a restart is invoked interactively but no :interactive option
     was supplied, the argument list used in the invocation is the empty
     list.

:report
     If the VALUE supplied by ‘:report VALUE’ is a lambda expression or
     a symbol, it must be acceptable to ‘function’.  ‘(function VALUE)’
     is evaluated in the current lexical environment.  It should return
     a function of one argument, a stream, which prints on the stream a
     description of the restart.  This function is called whenever the
     restart is printed while ‘*print-escape*’ is ‘nil’.

     If VALUE is a string, it is a shorthand for

      (lambda (stream) (write-string value stream))

     If a named restart is asked to report but no report information
     has been supplied, the name of the restart is used in generating
     default report text.

     When ‘*print-escape*’ is ‘nil’, the printer uses the report
     information for a restart.  For example, a debugger might announce
     the action of typing a "continue" command by:

      (format t "~&~S -- ~A~%" ':continue some-restart)

     which might then display as something like:

      :CONTINUE -- Return to command level

     The consequences are unspecified if an unnamed restart is specified
     but no :report option is provided.

:test
     The VALUE supplied by ‘:test VALUE’ must be a suitable argument to
     ‘function’.  ‘(function VALUE)’ is evaluated in the current lexical
     environment.  It should return a function of one argument, the
     condition, that returns true if the restart is to be considered
     visible.

     The default for this option is equivalent to ‘(lambda (c) (declare
     (ignore c)) t)’.

If the RESTARTABLE-FORM is a list whose car is any of the symbols
‘signal’, ‘error’, ‘cerror’, or ‘warn’ (or is a macro form which
macroexpands into such a list), then ‘with-condition-restarts’ is used
implicitly to associate the indicated restarts with the condition to be
signaled.

Examples:
.........

 (restart-case
     (handler-bind ((error #'(lambda (c)
                             (declare (ignore condition))
                             (invoke-restart 'my-restart 7))))
       (error "Foo."))
   (my-restart (&optional v) v))
→ 7

 (define-condition food-error (error) ())
→ FOOD-ERROR
 (define-condition bad-tasting-sundae (food-error)
   ((ice-cream :initarg :ice-cream :reader bad-tasting-sundae-ice-cream)
    (sauce :initarg :sauce :reader bad-tasting-sundae-sauce)
    (topping :initarg :topping :reader bad-tasting-sundae-topping))
   (:report (lambda (condition stream)
              (format stream "Bad tasting sundae with ~S, ~S, and ~S"
                      (bad-tasting-sundae-ice-cream condition)
                      (bad-tasting-sundae-sauce condition)
                      (bad-tasting-sundae-topping condition)))))
→ BAD-TASTING-SUNDAE
 (defun all-start-with-same-letter (symbol1 symbol2 symbol3)
   (let ((first-letter (char (symbol-name symbol1) 0)))
     (and (eql first-letter (char (symbol-name symbol2) 0))
          (eql first-letter (char (symbol-name symbol3) 0)))))
→ ALL-START-WITH-SAME-LETTER
 (defun read-new-value ()
   (format t "Enter a new value: ")
   (multiple-value-list (eval (read))))
→ READ-NEW-VALUE
 (defun verify-or-fix-perfect-sundae (ice-cream sauce topping)
   (do ()
      ((all-start-with-same-letter ice-cream sauce topping))
     (restart-case
       (error 'bad-tasting-sundae
              :ice-cream ice-cream
              :sauce sauce
              :topping topping)
       (use-new-ice-cream (new-ice-cream)
         :report "Use a new ice cream."
         :interactive read-new-value
         (setq ice-cream new-ice-cream))
       (use-new-sauce (new-sauce)
         :report "Use a new sauce."
         :interactive read-new-value
         (setq sauce new-sauce))
       (use-new-topping (new-topping)
         :report "Use a new topping."
         :interactive read-new-value
         (setq topping new-topping))))
   (values ice-cream sauce topping))
→ VERIFY-OR-FIX-PERFECT-SUNDAE
 (verify-or-fix-perfect-sundae 'vanilla 'caramel 'cherry)
▷ Error: Bad tasting sundae with VANILLA, CARAMEL, and CHERRY.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Use a new ice cream.
▷  2: Use a new sauce.
▷  3: Use a new topping.
▷  4: Return to Lisp Toplevel.
▷ Debug> :continue 1
▷ Use a new ice cream.
▷ Enter a new ice cream: 'chocolate
→ CHOCOLATE, CARAMEL, CHERRY

See Also:
.........

*note restart-bind::, *note with-simple-restart::.

Notes:
......

 (restart-case expression
    (name1 arglist1 ...options1... . body1)
    (name2 arglist2 ...options2... . body2))

is essentially equivalent to

 (block #1=#:g0001
   (let ((#2=#:g0002 nil))
        (tagbody
        (restart-bind ((name1 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #3=#:g0003))
                          ...slightly-transformed-options1...)
                       (name2 #'(lambda (&rest temp)
                                (setq #2# temp)
                                (go #4=#:g0004))
                          ...slightly-transformed-options2...))
        (return-from #1# expression))
          #3# (return-from #1#
                  (apply #'(lambda arglist1 . body1) #2#))
          #4# (return-from #1#
                  (apply #'(lambda arglist2 . body2) #2#)))))

Unnamed restarts are generally only useful interactively and an
interactive option which has no description is of little value.
Implementations are encouraged to warn if an unnamed restart is used
and no report information is provided at compilation    time.  At
runtime, this error might be noticed when entering the debugger.  Since
signaling an error would probably cause recursive entry into the
debugger (causing yet another recursive error, etc.) it is suggested
that the debugger print some indication of such problems when they
occur but not actually signal errors.

 (restart-case (signal fred)
   (a ...)
   (b ...))
 ≡
 (restart-case
     (with-condition-restarts fred
                              (list (find-restart 'a)
                                    (find-restart 'b))
       (signal fred))
   (a ...)
   (b ...))


File: ansicl,  Node: restart-name,  Next: with-condition-restarts,  Prev: restart-case,  Up: Conditions

restart-name (Function)
=======================

Syntax:
.......

 -- Function: restart-name restart → name

Arguments and Values:
.....................

RESTART--a restart.

NAME--a symbol.

Description:
............

Returns the name of the RESTART, or ‘nil’ if the RESTART is not named.

Examples:
.........

 (restart-case
     (loop for restart in (compute-restarts)
               collect (restart-name restart))
   (case1 () :report "Return 1." 1)
   (nil   () :report "Return 2." 2)
   (case3 () :report "Return 3." 3)
   (case1 () :report "Return 4." 4))
→ (CASE1 NIL CASE3 CASE1 ABORT)
 ;; In the example above the restart named ABORT was not created
 ;; explicitly, but was implicitly supplied by the system.

See Also:
.........

*note compute-restarts:: *note find-restart::


File: ansicl,  Node: with-condition-restarts,  Next: with-simple-restart,  Prev: restart-name,  Up: Conditions

with-condition-restarts (Macro)
===============================

Syntax:
.......

 -- Macro: with-condition-restarts condition-form restarts-form {form}*
          → {result}*

Arguments and Values:
.....................

CONDITION-FORM--a form; evaluated to produce a CONDITION.

CONDITION--a condition object resulting from the evaluation of
CONDITION-FORM.

RESTART-FORM--a form; evaluated to produce a RESTART-LIST.

RESTART-LIST--a list of restart objects resulting from the evaluation
of RESTART-FORM.

FORMS--an implicit progn; evaluated.

RESULTS--the values returned by FORMS.

Description:
............

First, the CONDITION-FORM and RESTARTS-FORM are evaluated in normal
left-to-right order; the primary values yielded by these evaluations
are respectively called the CONDITION and the RESTART-LIST.

Next, the FORMS are evaluated in a dynamic environment in which each
restart in RESTART-LIST is associated with the CONDITION.  See *note
Section 9.1.4.2.4 (Associating a Restart with a Condition):
AssocRestartWithCond.

See Also:
.........

*note restart-case::

Notes:
......

Usually this macro is not used explicitly in code, since ‘restart-case’
handles most of the common cases in a way that is syntactically more
concise.


File: ansicl,  Node: with-simple-restart,  Next: abort (Restart),  Prev: with-condition-restarts,  Up: Conditions

with-simple-restart (Macro)
===========================

Syntax:
.......

 -- Macro: with-simple-restart (name format-control {format-argument}*)
          {form}* → {result}*

Arguments and Values:
.....................

NAME--a symbol.

FORMAT-CONTROL--a format control.

FORMAT-ARGUMENT--an object (i.e., a format argument).

FORMS--an implicit progn.

RESULTS--in the normal situation, the values returned by the FORMS; in
the exceptional situation where the restart named NAME is invoked, two
values--‘nil’ and ‘t’.

Description:
............

‘with-simple-restart’ establishes a restart.

If the restart designated by NAME is not invoked while executing FORMS,
all values returned by the last of FORMS are returned.  If the restart
designated by NAME is invoked, control is transferred to
‘with-simple-restart’, which returns two values, ‘nil’ and ‘t’.

If NAME is ‘nil’, an anonymous restart is established.

The FORMAT-CONTROL and FORMAT-ARGUMENTS are used report the restart.

Examples:
.........

 (defun read-eval-print-loop (level)
   (with-simple-restart (abort "Exit command level ~D." level)
     (loop
       (with-simple-restart (abort "Return to command level ~D." level)
         (let ((form (prog2 (fresh-line) (read) (fresh-line))))
           (prin1 (eval form)))))))
→ READ-EVAL-PRINT-LOOP
 (read-eval-print-loop 1)
 (+ 'a 3)
▷ Error: The argument, A, to the function + was of the wrong type.
▷        The function expected a number.
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Specify a value to use this time.
▷  2: Return to command level 1.
▷  3: Exit command level 1.
▷  4: Return to Lisp Toplevel.

 (defun compute-fixnum-power-of-2 (x)
   (with-simple-restart (nil "Give up on computing 2^~D." x)
     (let ((result 1))
       (dotimes (i x result)
         (setq result (* 2 result))
         (unless (fixnump result)
           (error "Power of 2 is too large."))))))
COMPUTE-FIXNUM-POWER-OF-2
 (defun compute-power-of-2 (x)
   (or (compute-fixnum-power-of-2 x) 'something big))
COMPUTE-POWER-OF-2
 (compute-power-of-2 10)
1024
 (compute-power-of-2 10000)
▷ Error: Power of 2 is too large.
▷ To continue, type :CONTINUE followed by an option number.
▷  1: Give up on computing 2^10000.
▷  2: Return to Lisp Toplevel
▷ Debug> :continue 1
→ SOMETHING-BIG

See Also:
.........

*note restart-case::

Notes:
......

‘with-simple-restart’ is shorthand for one of the most common uses of
‘restart-case’.

‘with-simple-restart’ could be defined by:

 (defmacro with-simple-restart ((restart-name format-control
                                              &rest format-arguments)
                                &body forms)
   `(restart-case (progn ,@forms)
      (,restart-name ()
          :report (lambda (stream)
                    (format stream ,format-control ,@format-arguments))
         (values nil t))))

Because the second return value is ‘t’ in the exceptional case, it is
common (but not required) to arrange for the second return value in the
normal case to be missing or ‘nil’ so that the two situations can be
distinguished.


File: ansicl,  Node: abort (Restart),  Next: continue (Restart),  Prev: with-simple-restart,  Up: Conditions

abort (Restart)
===============

Data Arguments Required:
........................

None.

Description:
............

The intent of the abort restart is to allow return to the innermost
"command level."  Implementors are encouraged to make sure that there
is always a restart named ‘abort’ around any user code so that user
code can call ‘abort’ at any time and expect something reasonable to
happen; exactly what the reasonable thing is may vary somewhat.
Typically, in an interactive listener, the invocation of ‘abort’
returns to the Lisp reader phase of the Lisp read-eval-print loop,
though in some batch or multi-processing situations there may be
situations in which having it kill the running process is more
appropriate.

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note abort:: (function)


File: ansicl,  Node: continue (Restart),  Next: muffle-warning (Restart),  Prev: abort (Restart),  Up: Conditions

continue (Restart)
==================

Data Arguments Required:
........................

None.

Description:
............

the ‘continue’ restart is generally part of protocols where there is a
single "obvious" way to continue, such as in ‘break’ and ‘cerror’.  Some
user-defined protocols may also wish to incorporate it for similar
reasons.  In general, however, it is more reliable to design a special
purpose restart with a name that more directly suits the particular
application.

Examples:
.........

 (let ((x 3))
   (handler-bind ((error #'(lambda (c)
                             (let ((r (find-restart 'continue c)))
                               (when r (invoke-restart r))))))
     (cond ((not (floatp x))
            (cerror "Try floating it." "~D is not a float." x)
            (float x))
           (t x)))) → 3.0

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note continue:: (function), *note assert::, *note cerror::


File: ansicl,  Node: muffle-warning (Restart),  Next: store-value (Restart),  Prev: continue (Restart),  Up: Conditions

muffle-warning (Restart)
========================

Data Arguments Required:
........................

None.

Description:
............

This restart is established by ‘warn’ so that handlers of ‘warning’
conditions have a way to tell ‘warn’ that a warning has already been
dealt with and that no further action is warranted.

Examples:
.........

 (defvar *all-quiet* nil) → *ALL-QUIET*
 (defvar *saved-warnings* '()) → *SAVED-WARNINGS*
 (defun quiet-warning-handler (c)
   (when *all-quiet*
     (let ((r (find-restart 'muffle-warning c)))
       (when r
         (push c *saved-warnings*)
         (invoke-restart r)))))
→ CUSTOM-WARNING-HANDLER
 (defmacro with-quiet-warnings (&body forms)
   `(let ((*all-quiet* t)
          (*saved-warnings* '()))
      (handler-bind ((warning #'quiet-warning-handler))
        ,@forms
        *saved-warnings*)))
→ WITH-QUIET-WARNINGS
 (setq saved
   (with-quiet-warnings
     (warn "Situation #1.")
     (let ((*all-quiet* nil))
       (warn "Situation #2."))
     (warn "Situation #3.")))
▷ Warning: Situation #2.
→ (#<SIMPLE-WARNING 42744421> #<SIMPLE-WARNING 42744365>)
 (dolist (s saved) (format t "~&~A~%" s))
▷ Situation #3.
▷ Situation #1.
→ NIL

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note muffle-warning:: (function), *note warn::


File: ansicl,  Node: store-value (Restart),  Next: use-value (Restart),  Prev: muffle-warning (Restart),  Up: Conditions

store-value (Restart)
=====================

Data Arguments Required:
........................

a value to use instead (on an ongoing basis).

Description:
............

the ‘store-value’ restart is generally used by handlers trying to
recover from errors of types such as ‘cell-error’ or ‘type-error’,
which may wish to supply a replacement datum to be stored permanently.

Examples:
.........

 (defun type-error-auto-coerce (c)
   (when (typep c 'type-error)
     (let ((r (find-restart 'store-value c)))
       (handler-case (let ((v (coerce (type-error-datum c)
                                      (type-error-expected-type c))))
                       (invoke-restart r v))
         (error ()))))) → TYPE-ERROR-AUTO-COERCE
 (let ((x 3))
   (handler-bind ((type-error #'type-error-auto-coerce))
     (check-type x float)
     x)) → 3.0

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note store-value:: (function), *note ccase::, *note check-type::,
*note ctypecase::, *note use-value:: (function and restart)


File: ansicl,  Node: use-value (Restart),  Next: abort; continue; muffle-warning; store-value; use-value,  Prev: store-value (Restart),  Up: Conditions

use-value (Restart)
===================

Data Arguments Required:
........................

a value to use instead (once).

Description:
............

the ‘use-value’ restart is generally used by handlers trying to recover
from errors of types such as ‘cell-error’, where the handler may wish
to supply a replacement datum for one-time use.

See Also:
.........

*note Section 9.1.4.2 (Restarts): Restarts, *note Section 9.1.4.2.2
(Interfaces to Restarts): InterfacesToRestarts, *note invoke-restart::,
*note use-value:: (function), *note store-value:: (function and restart)


File: ansicl,  Node: abort; continue; muffle-warning; store-value; use-value,  Prev: use-value (Restart),  Up: Conditions

abort, continue, muffle-warning, store-value, use-value (Function)
==================================================================

Syntax:
.......

 -- Function: abort &optional condition →|

 -- Function: continue &optional condition → ‘nil’

 -- Function: muffle-warning &optional condition →|

 -- Function: store-value value &optional condition → ‘nil’

 -- Function: use-value value &optional condition → ‘nil’

Arguments and Values:
.....................

VALUE--an object.

CONDITION--a condition object, or ‘nil’.

Description:
............

Transfers control to the most recently established applicable restart
having the same name as the function.  That is, the function ‘abort’
searches for an applicable abort    restart, the function ‘continue’
searches for an applicable continue restart, and so on.

If no such restart exists, the functions ‘continue’, ‘store-value’, and
‘use-value’ return ‘nil’, and the functions ‘abort’ and ‘muffle-warning’
signal an error of type ‘control-error’.

When CONDITION is non-nil, only those restarts are considered that are
either explicitly associated with that CONDITION, or not associated
with any condition; that is, the excluded restarts are those that are
associated with a non-empty set of conditions of which the given
CONDITION is not an element.  If CONDITION is ‘nil’, all restarts are
considered.

Examples:
.........

;;; Example of the ABORT retart

 (defmacro abort-on-error (&body forms)
   `(handler-bind ((error #'abort))
      ,@forms)) → ABORT-ON-ERROR
 (abort-on-error (+ 3 5)) → 8
 (abort-on-error (error "You lose."))
▷ Returned to Lisp Top Level.

;;; Example of the CONTINUE restart

 (defun real-sqrt (n)
   (when (minusp n)
     (setq n (- n))
     (cerror "Return sqrt(~D) instead." "Tried to take sqrt(-~D)." n))
   (sqrt n))

 (real-sqrt 4) → 2
 (real-sqrt -9)
▷ Error: Tried to take sqrt(-9).
▷ To continue, type :CONTINUE followed by an option number:
▷  1: Return sqrt(9) instead.
▷  2: Return to Lisp Toplevel.
▷ Debug> (continue)
▷ Return sqrt(9) instead.
→ 3

 (handler-bind ((error #'(lambda (c) (continue))))
   (real-sqrt -9)) → 3

;;; Example of the MUFFLE-WARNING restart

 (defun count-down (x)
   (do ((counter x (1- counter)))
       ((= counter 0) 'done)
     (when (= counter 1)
       (warn "Almost done"))
     (format t "~&~D~%" counter)))
→ COUNT-DOWN
 (count-down 3)
▷ 3
▷ 2
▷ Warning: Almost done
▷ 1
→ DONE
 (defun ignore-warnings-while-counting (x)
   (handler-bind ((warning #'ignore-warning))
     (count-down x)))
→ IGNORE-WARNINGS-WHILE-COUNTING
 (defun ignore-warning (condition)
   (declare (ignore condition))
   (muffle-warning))
→ IGNORE-WARNING
 (ignore-warnings-while-counting 3)
▷ 3
▷ 2
▷ 1
→ DONE

;;; Example of the STORE-VALUE and USE-VALUE restarts

 (defun careful-symbol-value (symbol)
   (check-type symbol symbol)
   (restart-case (if (boundp symbol)
                     (return-from careful-symbol-value
                                  (symbol-value symbol))
                     (error 'unbound-variable
                            :name symbol))
     (use-value (value)
       :report "Specify a value to use this time."
       value)
     (store-value (value)
       :report "Specify a value to store and use in the future."
       (setf (symbol-value symbol) value))))
 (setq a 1234) → 1234
 (careful-symbol-value 'a) → 1234
 (makunbound 'a) → A
 (careful-symbol-value 'a)
▷ Error: A is not bound.
▷ To continue, type :CONTINUE followed by an option number.
▷  1: Specify a value to use this time.
▷  2: Specify a value to store and use in the future.
▷  3: Return to Lisp Toplevel.
▷ Debug> (use-value 12)
→ 12
 (careful-symbol-value 'a)
▷ Error: A is not bound.
▷ To continue, type :CONTINUE followed by an option number.
▷   1: Specify a value to use this time.
▷   2: Specify a value to store and use in the future.
▷   3: Return to Lisp Toplevel.
▷ Debug> (store-value 24)
→ 24
 (careful-symbol-value 'a)
→ 24

;;; Example of the USE-VALUE restart

 (defun add-symbols-with-default (default &rest symbols)
   (handler-bind ((sys:unbound-symbol
                    #'(lambda (c)
                        (declare (ignore c))
                        (use-value default))))
     (apply #'+ (mapcar #'careful-symbol-value symbols))))
→ ADD-SYMBOLS-WITH-DEFAULT
 (setq x 1 y 2) → 2
 (add-symbols-with-default 3 'x 'y 'z) → 6

Side Effects:
.............

A transfer of control may occur if an appropriate restart is available,
or (in the case of the function ‘abort’ or the function
‘muffle-warning’) execution may be stopped.

Affected By:
............

Each of these functions can be affected by the presence of a restart
having the same name.

Exceptional Situations:
.......................

If an appropriate abort restart is not available for the function
‘abort’, or an appropriate muffle-warning restart is not available for
the function ‘muffle-warning’, an error of type ‘control-error’ is
signaled.

See Also:
.........

*note invoke-restart::, *note Section 9.1.4.2 (Restarts): Restarts,
*note Section 9.1.4.2.2 (Interfaces to Restarts): InterfacesToRestarts,
*note assert::, *note ccase::, *note cerror::, *note check-type::,
*note ctypecase::, *note use-value::, *note warn::

Notes:
......

 (abort condition) ≡ (invoke-restart 'abort)
 (muffle-warning)  ≡ (invoke-restart 'muffle-warning)
 (continue)        ≡ (let ((r (find-restart 'continue))) (if r (invoke-restart r)))
 (use-value X) ≡ (let ((r (find-restart 'use-value))) (if r (invoke-restart r X)))
 (store-value x) ≡ (let ((r (find-restart 'store-value))) (if r (invoke-restart r X)))

No functions defined in this specification are required to provide a
use-value restart.


File: ansicl,  Node: Symbols,  Next: Packages,  Prev: Conditions,  Up: Top

10 Symbols
**********

* Menu:

* Symbol Concepts::

Dictionary

* symbol::
* keyword::
* symbolp::
* keywordp::
* make-symbol::
* copy-symbol::
* gensym::
* *gensym-counter*::
* gentemp::
* symbol-function::
* symbol-name::
* symbol-package::
* symbol-plist::
* symbol-value::
* get::
* remprop::
* boundp::
* makunbound::
* set::
* unbound-variable::


File: ansicl,  Node: Symbol Concepts,  Next: symbol,  Up: Symbols

10.1 Symbol Concepts
====================

The next figure lists some defined names that are applicable to the
property lists of symbols.

get   remprop   symbol-plist

Figure 10.1: Property list defined names

The next figure lists some defined names that are applicable to the
creation of and inquiry about symbols.

copy-symbol   keywordp      symbol-package
gensym        make-symbol   symbol-value
gentemp       symbol-name   

Figure 10.2: Symbol creation and inquiry defined names


File: ansicl,  Node: symbol,  Next: keyword,  Prev: Symbol Concepts,  Up: Symbols

symbol (System Class)
=====================

Class Precedence List:
......................

‘symbol’, ‘t’

Description:
............

Symbols are used for their object identity to name various entities in
Common Lisp, including (but not limited to) linguistic entities such as
variables and functions.

Symbols can be collected together into packages.  A symbol is said to
be interned in a package if it is accessible in that package; the same
symbol can be interned in more than one package.  If a symbol is not
interned in any package, it is called uninterned.

An interned symbol is uniquely identifiable by its name from any
package in which it is accessible.

Symbols have the following attributes.  For historical reasons, these
are sometimes referred to as cells, although the actual internal
representation of symbols and their attributes is
implementation-dependent.

Name
     The name of a symbol is a string used to identify the symbol.
     Every symbol has a name, and the consequences are undefined if
     that name is altered.  The name is used as part of the external,
     printed representation of the symbol; see *note Section 2.1
     (Character Syntax): Character Syntax.  The function ‘symbol-name’
     returns the name of a given symbol.  A symbol may have any
     character in its name.

Package
     The object in this cell is called the home package of the symbol.
     If the home package is ‘nil’, the symbol is sometimes said to have
     no home package.

     When a symbol is first created, it has no home package.  When it
     is first interned, the package in which it is initially interned
     becomes its home package.  The home package of a symbol can be
     accessed by using the function ‘symbol-package’.

     If a symbol is uninterned from the package which is its home
     package, its home package is set to ‘nil’.  Depending on whether
     there is another package in which the symbol is interned, the
     symbol might or might not really be an uninterned symbol.  A
     symbol with no home package is therefore called apparently
     uninterned.

     The consequences are undefined if an attempt is made to alter the
     home package of a symbol external in the ‘COMMON-LISP’ package or
     the ‘KEYWORD’ package.

Property list
     The property list of a symbol provides a mechanism for associating
     named attributes with that symbol.  The operations for adding and
     removing entries are destructive to the property list.  Common
     Lisp provides operators both for direct manipulation of property
     list objects (e.g., see ‘getf’, ‘remf’, and ‘symbol-plist’) and
     for implicit manipulation of a symbol's property list by reference
     to the symbol (e.g., see ‘get’ and ‘remprop’).  The property list
     associated with a fresh symbol is initially null.

Value
     If a symbol has a value attribute, it is said to be bound, and
     that fact can be detected by the function ‘boundp’.  The object
     contained in the value cell of a bound symbol is the value of the
     global variable named by that symbol, and can be accessed by the
     function ‘symbol-value’.  A symbol can be made to be unbound by
     the function ‘makunbound’.

     The consequences are undefined if an attempt is made to change the
     value of a symbol that names a constant variable, or to make such a
     symbol be unbound.

Function
     If a symbol has a function attribute, it is said to be fbound, and
     that fact can be detected by the function ‘fboundp’.  If the
     symbol is the name of a function in the global environment, the
     function cell contains the function, and can be accessed by the
     function ‘symbol-function’.  If the symbol is the name of either a
     macro in the global environment (see ‘macro-function’) or a
     special operator (see ‘special-operator-p’), the symbol is fbound,
     and can be accessed by the function ‘symbol-function’, but the
     object which the function cell contains is of
     implementation-dependent type and purpose.  A symbol can be made
     to be funbound by the function ‘fmakunbound’.

     The consequences are undefined if an attempt is made to change the
     functional value of a symbol that names a special form.

Operations on a symbol's value cell and function cell are sometimes
described in terms of their effect on the symbol itself, but the user
should keep in mind that there is an intimate relationship between the
contents of those cells and the global variable or global function
definition, respectively.

Symbols are used as identifiers for lexical variables and lexical
function definitions, but in that role, only their object identity is
significant.  Common Lisp provides no operation on a symbol that can
have any effect on a lexical variable or on a lexical function
definition.

See Also:
.........

*note Section 2.3.4 (Symbols as Tokens): Symbols as Tokens, *note
Section 2.3.1.1 (Potential Numbers as Tokens): PotentialNumbersAsTokens,
*note Section 22.1.3.3 (Printing Symbols): PrintingSymbols.


File: ansicl,  Node: keyword,  Next: symbolp,  Prev: symbol,  Up: Symbols

keyword (Type)
==============

Supertypes:
...........

‘keyword’, ‘symbol’, ‘t’

Description:
............

The type ‘keyword’ includes all symbols interned the ‘KEYWORD’ package.

Interning a symbol in the ‘KEYWORD’ package has three automatic effects:

  1. It causes the symbol to become bound to itself.

  2. It causes the symbol to become an external symbol of the ‘KEYWORD’
     package.

  3. It causes the symbol to become a constant variable.

See Also:
.........

*note keywordp::


File: ansicl,  Node: symbolp,  Next: keywordp,  Prev: keyword,  Up: Symbols

symbolp (Function)
==================

Syntax:
.......

 -- Function: symbolp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘symbol’; otherwise, returns false.

Examples:
.........

 (symbolp 'elephant) → true
 (symbolp 12) → false
 (symbolp nil) → true
 (symbolp '()) → true
 (symbolp :test) → true
 (symbolp "hello") → false

See Also:
.........

*note keywordp::, *note symbol::, *note typep::

Notes:
......

 (symbolp OBJECT) ≡ (typep OBJECT 'symbol)


File: ansicl,  Node: keywordp,  Next: make-symbol,  Prev: symbolp,  Up: Symbols

keywordp (Function)
===================

Syntax:
.......

 -- Function: keywordp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is a keyword₁; otherwise, returns false.

Examples:
.........

 (keywordp 'elephant) → false
 (keywordp 12) → false
 (keywordp :test) → true
 (keywordp ':test) → true
 (keywordp nil) → false
 (keywordp :nil) → true
 (keywordp '(:test)) → false
 (keywordp "hello") → false
 (keywordp ":hello") → false
 (keywordp '&optional) → false

See Also:
.........

*note constantp::, *note keyword::, *note symbolp::, *note
symbol-package::


File: ansicl,  Node: make-symbol,  Next: copy-symbol,  Prev: keywordp,  Up: Symbols

make-symbol (Function)
======================

Syntax:
.......

 -- Function: make-symbol name → new-symbol

Arguments and Values:
.....................

NAME--a string.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

‘make-symbol’ creates and returns a fresh, uninterned symbol whose name
is the given NAME.  The NEW-SYMBOL is neither bound nor fbound and has
a null property list.

It is implementation-dependent whether the string that becomes the
NEW-SYMBOL's name is the given NAME or a copy of it.  Once a string has
been given as the NAME argument to make-symbol, the consequences are
undefined if a subsequent attempt is made to alter that string.

Examples:
.........

 (setq temp-string "temp") → "temp"
 (setq temp-symbol (make-symbol temp-string)) → #:|temp|
 (symbol-name temp-symbol) → "temp"
 (eq (symbol-name temp-symbol) temp-string) → implementation-dependent
 (find-symbol "temp") → NIL, NIL
 (eq (make-symbol temp-string) (make-symbol temp-string)) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if NAME is not a string.

See Also:
.........

*note copy-symbol::

Notes:
......

No attempt is made by ‘make-symbol’ to convert the case of the name to
uppercase.  The only case conversion which ever occurs for symbols is
done by the Lisp reader.  The program interface to symbol creation
retains case, and the program interface to interning symbols is
case-sensitive.


File: ansicl,  Node: copy-symbol,  Next: gensym,  Prev: make-symbol,  Up: Symbols

copy-symbol (Function)
======================

Syntax:
.......

 -- Function: copy-symbol symbol &optional copy-properties → new-symbol

Arguments and Values:
.....................

SYMBOL--a symbol.

COPY-PROPERTIES--a generalized boolean.  The default is false.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

‘copy-symbol’ returns a fresh, uninterned symbol, the name of which is
‘string=’ to and possibly the same as the name of the given SYMBOL.

If COPY-PROPERTIES is false, the NEW-SYMBOL is neither bound nor fbound
and has a null property list.  If COPY-PROPERTIES is true, then the
initial value of NEW-SYMBOL is the value of SYMBOL, the initial
function definition of NEW-SYMBOL is the functional value of SYMBOL,
and the property list of NEW-SYMBOL is a copy₂ of the property list of
SYMBOL.

Examples:
.........

 (setq fred 'fred-smith) → FRED-SMITH
 (setf (symbol-value fred) 3) → 3
 (setq fred-clone-1a (copy-symbol fred nil)) → #:FRED-SMITH
 (setq fred-clone-1b (copy-symbol fred nil)) → #:FRED-SMITH
 (setq fred-clone-2a (copy-symbol fred t))   → #:FRED-SMITH
 (setq fred-clone-2b (copy-symbol fred t))   → #:FRED-SMITH
 (eq fred fred-clone-1a) → false
 (eq fred-clone-1a fred-clone-1b) → false
 (eq fred-clone-2a fred-clone-2b) → false
 (eq fred-clone-1a fred-clone-2a) → false
 (symbol-value fred) → 3
 (boundp fred-clone-1a) → false
 (symbol-value fred-clone-2a) → 3
 (setf (symbol-value fred-clone-2a) 4) → 4
 (symbol-value fred) → 3
 (symbol-value fred-clone-2a) → 4
 (symbol-value fred-clone-2b) → 3
 (boundp fred-clone-1a) → false
 (setf (symbol-function fred) #'(lambda (x) x)) → #<FUNCTION anonymous>
 (fboundp fred) → true
 (fboundp fred-clone-1a) → false
 (fboundp fred-clone-2a) → false

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note make-symbol::

Notes:
......

Implementors are encouraged not to copy the string which is the
symbol's name unnecessarily.  Unless there is a good reason to do so,
the normal implementation strategy is for the NEW-SYMBOL's name to be
identical to the given SYMBOL's name.


File: ansicl,  Node: gensym,  Next: *gensym-counter*,  Prev: copy-symbol,  Up: Symbols

gensym (Function)
=================

Syntax:
.......

 -- Function: gensym &optional x → new-symbol

Arguments and Values:
.....................

X--a string or a non-negative integer.  Complicated defaulting
behavior; see below.

NEW-SYMBOL--a fresh, uninterned symbol.

Description:
............

Creates and returns a fresh, uninterned symbol, as if by calling
‘make-symbol’.  (The only difference between ‘gensym’ and ‘make-symbol’
is in how the NEW-SYMBOL's name is determined.)

The name of the NEW-SYMBOL is the concatenation of a prefix, which
defaults to ‘"G"’, and a suffix, which is the decimal representation of
a number that defaults to the value of ‘*gensym-counter*’.

If X is supplied, and is a string, then that string is used as a prefix
instead of ‘"G"’ for this call to ‘gensym’ only.

If X is supplied, and is an integer, then that integer, instead of the
value of ‘*gensym-counter*’, is used as the suffix for this call to
‘gensym’ only.

If and only if no explicit suffix is supplied, ‘*gensym-counter*’ is
incremented after it is used.

Examples:
.........

 (setq sym1 (gensym)) → #:G3142
 (symbol-package sym1) → NIL
 (setq sym2 (gensym 100)) → #:G100
 (setq sym3 (gensym 100)) → #:G100
 (eq sym2 sym3) → false
 (find-symbol "G100") → NIL, NIL
 (gensym "T") → #:T3143
 (gensym) → #:G3144

Side Effects:
.............

Might increment ‘*gensym-counter*’.

Affected By:
............

‘*gensym-counter*’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if X is not a string or a
non-negative integer.

See Also:
.........

*note gentemp::, *note *gensym-counter*::

Notes:
......

The ability to pass a numeric argument to ‘gensym’ has been deprecated;
explicitly binding ‘*gensym-counter*’ is now stylistically preferred.
(The somewhat baroque conventions for the optional argument are
historical in nature, and supported primarily for compatibility with
older dialects of Lisp.   In modern code, it is recommended that the
only kind of argument used be a string prefix.  In general, though, to
obtain more flexible control of the NEW-SYMBOL's name, consider using
‘make-symbol’ instead.)


File: ansicl,  Node: *gensym-counter*,  Next: gentemp,  Prev: gensym,  Up: Symbols

*gensym-counter* (Variable)
===========================

Value Type:
...........

a non-negative integer.

Initial Value:
..............

implementation-dependent.

Description:
............

A number which will be used in constructing the name of the next symbol
generated by the function ‘gensym’.

‘*gensym-counter*’ can be either assigned or bound at any time, but its
value must always be a non-negative integer.

Affected By:
............

‘gensym’.

See Also:
.........

*note gensym::

Notes:
......

The ability to pass a numeric argument to ‘gensym’ has been deprecated;
explicitly binding ‘*gensym-counter*’ is now stylistically preferred.


File: ansicl,  Node: gentemp,  Next: symbol-function,  Prev: *gensym-counter*,  Up: Symbols

gentemp (Function)
==================

Syntax:
.......

 -- Function: gentemp &optional prefix package → new-symbol

Arguments and Values:
.....................

PREFIX--a string.  The default is ‘"T"’.

PACKAGE--a package designator.  The default is the current package.

NEW-SYMBOL--a fresh, interned symbol.

Description:
............

‘gentemp’ creates and returns a fresh symbol, interned in the indicated
PACKAGE.  The symbol is guaranteed to be one that was not previously
accessible in PACKAGE.  It is neither bound nor fbound, and has a null
property list.

The name of the NEW-SYMBOL is the concatenation of the PREFIX and a
suffix, which is taken from an internal counter used only by ‘gentemp’.
(If a symbol by that name is already accessible in PACKAGE, the counter
is incremented as many times as is necessary to produce a name that is
not already the name of a symbol accessible in PACKAGE.)

Examples:
.........

 (gentemp) → T1298
 (gentemp "FOO") → FOO1299
 (find-symbol "FOO1300") → NIL, NIL
 (gentemp "FOO") → FOO1300
 (find-symbol "FOO1300") → FOO1300, :INTERNAL
 (intern "FOO1301") → FOO1301, :INTERNAL
 (gentemp "FOO") → FOO1302
 (gentemp) → T1303

Side Effects:
.............

Its internal counter is incremented one or more times.

Interns the NEW-SYMBOL in PACKAGE.

Affected By:
............

The current state of its internal counter, and the current state of the
PACKAGE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if PREFIX is not a string.
Should signal an error of type ‘type-error’ if PACKAGE is not a package
designator.

See Also:
.........

*note gensym::

Notes:
......

The function ‘gentemp’ is deprecated.

If PACKAGE is the ‘KEYWORD’ package, the result is an external symbol
of PACKAGE.  Otherwise, the result is an internal symbol of PACKAGE.

The ‘gentemp’ internal counter is independent of ‘*gensym-counter*’,
the counter used by ‘gensym’.  There is no provision for accessing the
‘gentemp’ internal counter.

Just because ‘gentemp’ creates a symbol which did not previously exist
does not mean that such a symbol might not be seen in the future (e.g.,
in a data file--perhaps even created by the same program in another
session).  As such, this symbol is not truly unique in the same sense
as a gensym would be.  In particular, programs which do automatic code
generation should be careful not to attach global attributes to such
generated symbols (e.g., ‘special’ declarations) and then write them
into a file because such global attributes might, in a different
session, end up applying to other symbols that were automatically
generated on another day for some other purpose.


File: ansicl,  Node: symbol-function,  Next: symbol-name,  Prev: gentemp,  Up: Symbols

symbol-function (Accessor)
==========================

Syntax:
.......

 -- Function: symbol-function symbol → contents

(setf (symbol-function symbol) new-contents)

Arguments and Values:
.....................

SYMBOL--a symbol.

CONTENTS-- If the SYMBOL is globally defined as a macro or a special
operator, an object of implementation-dependent nature and identity is
returned.  If the SYMBOL is not globally defined as either a macro or a
special operator, and if the SYMBOL is fbound, a function object is
returned.

NEW-CONTENTS--a function.

Description:
............

Accesses the symbol's function cell.

Examples:
.........

 (symbol-function 'car) → #<FUNCTION CAR>
 (symbol-function 'twice) is an error   ;because TWICE isn't defined.
 (defun twice (n) (* n 2)) → TWICE
 (symbol-function 'twice) → #<FUNCTION TWICE>
 (list (twice 3)
       (funcall (function twice) 3)
       (funcall (symbol-function 'twice) 3))
→ (6 6 6)
 (flet ((twice (x) (list x x)))
   (list (twice 3)
         (funcall (function twice) 3)
         (funcall (symbol-function 'twice) 3)))
→ ((3 3) (3 3) 6)
 (setf (symbol-function 'twice) #'(lambda (x) (list x x)))
→ #<FUNCTION anonymous>
 (list (twice 3)
       (funcall (function twice) 3)
       (funcall (symbol-function 'twice) 3))
→ ((3 3) (3 3) (3 3))
 (fboundp 'defun) → true
 (symbol-function 'defun)
→ implementation-dependent
 (functionp (symbol-function 'defun))
→ implementation-dependent
 (defun symbol-function-or-nil (symbol)
   (if (and (fboundp symbol)
            (not (macro-function symbol))
            (not (special-operator-p symbol)))
       (symbol-function symbol)
       nil)) → SYMBOL-FUNCTION-OR-NIL
 (symbol-function-or-nil 'car) → #<FUNCTION CAR>
 (symbol-function-or-nil 'defun) → NIL

Affected By:
............

‘defun’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

Should signal ‘undefined-function’ if SYMBOL is not fbound and an
attempt is made to read its definition.  (No such error is signaled on
an attempt to write its definition.)

See Also:
.........

*note fboundp::, *note fmakunbound::, *note macro-function::, *note
special-operator-p::

Notes:
......

‘symbol-function’ cannot access the value of a lexical function name
produced by ‘flet’ or ‘labels’; it can access only the global function
value.

‘setf’ may be used with ‘symbol-function’ to replace a global function
definition when the symbol's function definition does not represent a
special operator.

(symbol-function SYMBOL) ≡ (fdefinition SYMBOL)

However, ‘fdefinition’ accepts arguments other than just symbols.


File: ansicl,  Node: symbol-name,  Next: symbol-package,  Prev: symbol-function,  Up: Symbols

symbol-name (Function)
======================

Syntax:
.......

 -- Function: symbol-name symbol → name

Arguments and Values:
.....................

SYMBOL--a symbol.

NAME--a string.

Description:
............

‘symbol-name’ returns the name of SYMBOL.  The consequences are
undefined if NAME is ever modified.

Examples:
.........

 (symbol-name 'temp) → "TEMP"
 (symbol-name :start) → "START"
 (symbol-name (gensym)) → "G1234" ;for example

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.


File: ansicl,  Node: symbol-package,  Next: symbol-plist,  Prev: symbol-name,  Up: Symbols

symbol-package (Function)
=========================

Syntax:
.......

 -- Function: symbol-package symbol → contents

Arguments and Values:
.....................

SYMBOL--a symbol.

CONTENTS--a package object or ‘nil’.

Description:
............

Returns the home package of SYMBOL.

Examples:
.........

 (in-package "CL-USER") → #<PACKAGE "COMMON-LISP-USER">
 (symbol-package 'car) → #<PACKAGE "COMMON-LISP">
 (symbol-package 'bus) → #<PACKAGE "COMMON-LISP-USER">
 (symbol-package :optional) → #<PACKAGE "KEYWORD">
 ;; Gensyms are uninterned, so have no home package.
 (symbol-package (gensym)) → NIL
 (make-package 'pk1) → #<PACKAGE "PK1">
 (intern "SAMPLE1" "PK1") → PK1::SAMPLE1, NIL
 (export (find-symbol "SAMPLE1" "PK1") "PK1") → T
 (make-package 'pk2 :use '(pk1)) → #<PACKAGE "PK2">
 (find-symbol "SAMPLE1" "PK2") → PK1:SAMPLE1, :INHERITED
 (symbol-package 'pk1::sample1) → #<PACKAGE "PK1">
 (symbol-package 'pk2::sample1) → #<PACKAGE "PK1">
 (symbol-package 'pk1::sample2) → #<PACKAGE "PK1">
 (symbol-package 'pk2::sample2) → #<PACKAGE "PK2">
 ;; The next several forms create a scenario in which a symbol
 ;; is not really uninterned, but is "apparently uninterned",
 ;; and so SYMBOL-PACKAGE still returns NIL.
 (setq s3 'pk1::sample3) → PK1::SAMPLE3
 (import s3 'pk2) → T
 (unintern s3 'pk1) → T
 (symbol-package s3) → NIL
 (eq s3 'pk2::sample3) → T

Affected By:
............

‘import’, ‘intern’, ‘unintern’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note intern::


File: ansicl,  Node: symbol-plist,  Next: symbol-value,  Prev: symbol-package,  Up: Symbols

symbol-plist (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-plist symbol → plist

(setf (symbol-plist symbol) new-plist)

Arguments and Values:
.....................

SYMBOL--a symbol.

PLIST, NEW-PLIST--a property list.

Description:
............

Accesses the property list of SYMBOL.

Examples:
.........

 (setq sym (gensym)) → #:G9723
 (symbol-plist sym) → ()
 (setf (get sym 'prop1) 'val1) → VAL1
 (symbol-plist sym) → (PROP1 VAL1)
 (setf (get sym 'prop2) 'val2) → VAL2
 (symbol-plist sym) → (PROP2 VAL2 PROP1 VAL1)
 (setf (symbol-plist sym) (list 'prop3 'val3)) → (PROP3 VAL3)
 (symbol-plist sym) → (PROP3 VAL3)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note get::, *note remprop::

Notes:
......

The use of ‘setf’ should be avoided, since a symbol's property list is
a global resource that can contain information established and depended
upon by unrelated programs in the same Lisp image.


File: ansicl,  Node: symbol-value,  Next: get,  Prev: symbol-plist,  Up: Symbols

symbol-value (Accessor)
=======================

Syntax:
.......

 -- Function: symbol-value symbol → value

(setf (symbol-value symbol) new-value)

Arguments and Values:
.....................

SYMBOL--a symbol that must have a value.

VALUE, NEW-VALUE--an object.

Description:
............

Accesses the symbol's value cell.

Examples:
.........

 (setf (symbol-value 'a) 1) → 1
 (symbol-value 'a) → 1
 ;; SYMBOL-VALUE cannot see lexical variables.
 (let ((a 2)) (symbol-value 'a)) → 1
 (let ((a 2)) (setq a 3) (symbol-value 'a)) → 1
 ;; SYMBOL-VALUE can see dynamic variables.
 (let ((a 2))
   (declare (special a))
   (symbol-value 'a)) → 2
 (let ((a 2))
   (declare (special a))
   (setq a 3)
   (symbol-value 'a)) → 3
 (let ((a 2))
   (setf (symbol-value 'a) 3)
   a) → 2
 a → 3
 (symbol-value 'a) → 3
 (let ((a 4))
   (declare (special a))
   (let ((b (symbol-value 'a)))
     (setf (symbol-value 'a) 5)
     (values a b))) → 5, 4
 a → 3
 (symbol-value :any-keyword) → :ANY-KEYWORD
 (symbol-value 'nil) → NIL
 (symbol-value '()) → NIL
 ;; The precision of this next one is implementation-dependent.
 (symbol-value 'pi) → 3.141592653589793d0

Affected By:
............

‘makunbound’, ‘set’, ‘setq’

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

Should signal ‘unbound-variable’ if SYMBOL is unbound and an attempt is
made to read its value.  (No such error is signaled on an attempt to
write its value.)

See Also:
.........

*note boundp::, *note makunbound::, *note set::, *note setq::

Notes:
......

‘symbol-value’ can be used to get the value of a constant variable.
‘symbol-value’ cannot access the value of a lexical variable.


File: ansicl,  Node: get,  Next: remprop,  Prev: symbol-value,  Up: Symbols

get (Accessor)
==============

Syntax:
.......

 -- Function: get symbol indicator &optional default → value

(setf (get symbol indicator &optional default) new-value)

Arguments and Values:
.....................

SYMBOL--a symbol.

INDICATOR--an object.

DEFAULT--an object.  The default is ‘nil’.

VALUE--if the indicated property exists, the object that is its value;
otherwise, the specified DEFAULT.

NEW-VALUE--an object.

Description:
............

‘get’ finds a property on the property list₂ of SYMBOL whose property
indicator is identical to INDICATOR, and returns its corresponding
property value.  If there are multiple properties₁ with that property
indicator, ‘get’ uses the first such property.  If there is no property
with that property indicator, DEFAULT is returned.

‘setf’ of ‘get’ may be used to associate a new object with an existing
indicator already on the SYMBOL's property list, or to create a new
assocation if none exists.  If there are multiple properties₁ with that
property indicator, ‘setf’ of ‘get’ associates the NEW-VALUE with the
first such property.  When a ‘get’ form is used as a ‘setf’ PLACE, any
DEFAULT which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.

Examples:
.........

 (defun make-person (first-name last-name)
   (let ((person (gensym "PERSON")))
     (setf (get person 'first-name) first-name)
     (setf (get person 'last-name) last-name)
     person)) → MAKE-PERSON
 (defvar *john* (make-person "John" "Dow")) → *JOHN*
 *john* → #:PERSON4603
 (defvar *sally* (make-person "Sally" "Jones")) → *SALLY*
 (get *john* 'first-name) → "John"
 (get *sally* 'last-name) → "Jones"
 (defun marry (man woman married-name)
   (setf (get man 'wife) woman)
   (setf (get woman 'husband) man)
   (setf (get man 'last-name) married-name)
   (setf (get woman 'last-name) married-name)
   married-name) → MARRY
 (marry *john* *sally* "Dow-Jones") → "Dow-Jones"
 (get *john* 'last-name) → "Dow-Jones"
 (get (get *john* 'wife) 'first-name) → "Sally"
 (symbol-plist *john*)
→ (WIFE #:PERSON4604 LAST-NAME "Dow-Jones" FIRST-NAME "John")
 (defmacro age (person &optional (default ''thirty-something))
   `(get ,person 'age ,default)) → AGE
 (age *john*) → THIRTY-SOMETHING
 (age *john* 20) → 20
 (setf (age *john*) 25) → 25
 (age *john*) → 25
 (age *john* 20) → 25

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note getf::, *note symbol-plist::, *note remprop::

Notes:
......

 (get x y) ≡ (getf (symbol-plist x) y)

Numbers and characters are not recommended for use as INDICATORS in
portable code since ‘get’ tests with ‘eq’ rather than ‘eql’, and
consequently the effect of using such INDICATORS is
implementation-dependent.

There is no way using ‘get’ to distinguish an absent property from one
whose value is DEFAULT.  However, see ‘get-properties’.


File: ansicl,  Node: remprop,  Next: boundp,  Prev: get,  Up: Symbols

remprop (Function)
==================

Syntax:
.......

 -- Function: remprop symbol indicator → generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

INDICATOR--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘remprop’ removes from the property list₂ of SYMBOL a property₁ with a
property indicator identical to INDICATOR.  If there are multiple
properties₁ with the identical key, ‘remprop’ only removes the first
such property.  ‘remprop’ returns false if no such property was found,
or true if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.  The
permissible side-effects correspond to those permitted for ‘remf’, such
that:

 (remprop x y) ≡ (remf (symbol-plist x) y)

Examples:
.........

 (setq test (make-symbol "PSEUDO-PI")) → #:PSEUDO-PI
 (symbol-plist test) → ()
 (setf (get test 'constant) t) → T
 (setf (get test 'approximation) 3.14) → 3.14
 (setf (get test 'error-range) 'noticeable) → NOTICEABLE
 (symbol-plist test)
→ (ERROR-RANGE NOTICEABLE APPROXIMATION 3.14 CONSTANT T)
 (setf (get test 'approximation) nil) → NIL
 (symbol-plist test)
→ (ERROR-RANGE NOTICEABLE APPROXIMATION NIL CONSTANT T)
 (get test 'approximation) → NIL
 (remprop test 'approximation) → true
 (get test 'approximation) → NIL
 (symbol-plist test)
→ (ERROR-RANGE NOTICEABLE CONSTANT T)
 (remprop test 'approximation) → NIL
 (symbol-plist test)
→ (ERROR-RANGE NOTICEABLE CONSTANT T)
 (remprop test 'error-range) → true
 (setf (get test 'approximation) 3) → 3
 (symbol-plist test)
→ (APPROXIMATION 3 CONSTANT T)

Side Effects:
.............

The property list of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note remf::, *note symbol-plist::

Notes:
......

Numbers and characters are not recommended for use as INDICATORS in
portable code since ‘remprop’ tests with ‘eq’ rather than ‘eql’, and
consequently the effect of using such INDICATORS is
implementation-dependent.  Of course, if you've gotten as far as
needing to remove such a property, you don't have much choice--the time
to have been thinking about this was when you used ‘setf’ of ‘get’ to
establish the property.


File: ansicl,  Node: boundp,  Next: makunbound,  Prev: remprop,  Up: Symbols

boundp (Function)
=================

Syntax:
.......

 -- Function: boundp symbol → generalized-boolean

Arguments and Values:
.....................

SYMBOL--a symbol.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if SYMBOL is bound; otherwise, returns false.

Examples:
.........

 (setq x 1) → 1
 (boundp 'x) → true
 (makunbound 'x) → X
 (boundp 'x) → false
 (let ((x 2)) (boundp 'x)) → false
 (let ((x 2)) (declare (special x)) (boundp 'x)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note set::, *note setq::, *note symbol-value::, *note makunbound::

Notes:
......

The function ‘bound’ determines only whether a symbol has a value in
the global environment; any lexical bindings are ignored.


File: ansicl,  Node: makunbound,  Next: set,  Prev: boundp,  Up: Symbols

makunbound (Function)
=====================

Syntax:
.......

 -- Function: makunbound symbol → symbol

Arguments and Values:
.....................

SYMBOL--a symbol

Description:
............

Makes the SYMBOL be unbound, regardless of whether it was previously
bound.

Examples:
.........

 (setf (symbol-value 'a) 1)
 (boundp 'a) → true
 a → 1
 (makunbound 'a) → A
 (boundp 'a) → false

Side Effects:
.............

The value cell of SYMBOL is modified.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SYMBOL is not a symbol.

See Also:
.........

*note boundp::, *note fmakunbound::


File: ansicl,  Node: set,  Next: unbound-variable,  Prev: makunbound,  Up: Symbols

set (Function)
==============

Syntax:
.......

 -- Function: set symbol value → value

Arguments and Values:
.....................

SYMBOL--a symbol.

VALUE--an object.

Description:
............

‘set’ changes the contents of the value cell of symbol to the given
value.

(set SYMBOL VALUE) ≡ (setf (symbol-value SYMBOL) VALUE)

Examples:
.........

 (setf (symbol-value 'n) 1) → 1
 (set 'n 2) → 2
 (symbol-value 'n) → 2
 (let ((n 3))
   (declare (special n))
   (setq n (+ n 1))
   (setf (symbol-value 'n) (* n 10))
   (set 'n (+ (symbol-value 'n) n))
   n) → 80
 n → 2
 (let ((n 3))
   (setq n (+ n 1))
   (setf (symbol-value 'n) (* n 10))
   (set 'n (+ (symbol-value 'n) n))
   n) → 4
 n → 44
 (defvar *n* 2)
 (let ((*n* 3))
   (setq *n* (+ *n* 1))
   (setf (symbol-value '*n*) (* *n* 10))
   (set '*n* (+ (symbol-value '*n*) *n*))
   *n*) → 80
  *n* → 2
 (defvar *even-count* 0) → *EVEN-COUNT*
 (defvar *odd-count* 0) → *ODD-COUNT*
 (defun tally-list (list)
   (dolist (element list)
     (set (if (evenp element) '*even-count* '*odd-count*)
          (+ element (if (evenp element) *even-count* *odd-count*)))))
 (tally-list '(1 9 4 3 2 7)) → NIL
 *even-count* → 6
 *odd-count* → 20

Side Effects:
.............

The value of SYMBOL is changed.

See Also:
.........

*note setq::, *note progv::, *note symbol-value::

Notes:
......

The function ‘set’ is deprecated.

‘set’ cannot change the value of a lexical variable.


File: ansicl,  Node: unbound-variable,  Prev: set,  Up: Symbols

unbound-variable (Condition Type)
=================================

Class Precedence List:
......................

‘unbound-variable’, ‘cell-error’, ‘error’, ‘serious-condition’,
‘condition’, ‘t’

Description:
............

The type ‘unbound-variable’ consists of error conditions that represent
attempts to read the value of an unbound variable.

The name of the cell (see ‘cell-error’) is the name of the variable
that was unbound.

See Also:
.........

*note cell-error-name::


File: ansicl,  Node: Packages,  Next: Numbers,  Prev: Symbols,  Up: Top

11 Packages
***********

* Menu:

* Package Concepts::

Dictionary

* package::
* export::
* find-symbol::
* find-package::
* find-all-symbols::
* import::
* list-all-packages::
* rename-package::
* shadow::
* shadowing-import::
* delete-package::
* make-package::
* with-package-iterator::
* unexport::
* unintern::
* in-package::
* unuse-package::
* use-package::
* defpackage::
* do-symbols; do-external-symbols; do-all-symbols::
* intern::
* package-name::
* package-nicknames::
* package-shadowing-symbols::
* package-use-list::
* package-used-by-list::
* packagep::
* *package*::
* package-error::
* package-error-package::


File: ansicl,  Node: Package Concepts,  Next: package,  Up: Packages

11.1 Package Concepts
=====================

* Menu:

* Introduction to Packages::
* Standardized Packages::


File: ansicl,  Node: Introduction to Packages,  Next: Standardized Packages,  Up: Package Concepts

11.1.1 Introduction to Packages
-------------------------------

A "package" establishes a mapping from names to symbols.  At any given
time, one package is current.  The "current package" is the one that is
the value of ‘*package*’.  When using the Lisp reader, it is possible
to refer to symbols in packages other than the current one through the
use of package prefixes in the printed representation of the symbol.

The next figure lists some defined names that are applicable to
packages.  Where an operator takes an argument that is either a symbol
or a list of symbols, an argument of ‘nil’ is treated as an empty list
of symbols.  Any PACKAGE argument may be either a string, a symbol, or
a package.  If a symbol is supplied, its name will be used as the
package name.

*modules*             import                      provide
*package*             in-package                  rename-package
defpackage            intern                      require
do-all-symbols        list-all-packages           shadow
do-external-symbols   make-package                shadowing-import
do-symbols            package-name                unexport
export                package-nicknames           unintern
find-all-symbols      package-shadowing-symbols   unuse-package
find-package          package-use-list            use-package
find-symbol           package-used-by-list        

Figure 11.1: Some Defined Names related to Packages

11.1.1.1 Package Names and Nicknames
....................................

Each package has a name (a string) and perhaps some nicknames (also
strings).  These are assigned when the package is created and can be
changed later.

There is a single namespace for packages.  The function ‘find-package’
translates a package name or nickname into the associated package.  The
function ‘package-name’ returns the name of a package.  The function
‘package-nicknames’ returns a list of all nicknames for a package.
‘rename-package’ removes a package's current name and nicknames and
replaces them with new ones specified by the caller.

11.1.1.2 Symbols in a Package
.............................

11.1.1.2.1 Internal and External Symbols
........................................

The mappings in a package are divided into two classes, external and
internal.  The symbols targeted by these different mappings are called
external symbols and internal symbols of the package. Within a package,
a name refers to one symbol or to none; if it does refer to a symbol,
then it is either external or internal in that package, but not both.  "External
symbols" are part of the package's public interface to other packages.
Symbols become external symbols of a given package if they have been
exported from that package.

A symbol has the same name no matter what package it is present in, but
it might be an external symbol of some packages and an internal symbol
of others.

11.1.1.2.2 Package Inheritance
..............................

Packages can be built up in layers.  From one point of view, a package
is a single collection of mappings from strings into internal symbols
and external symbols.  However, some of these mappings might be
established within the package itself, while other mappings are
inherited from other packages via ‘use-package’.  A symbol is said to
be "present" in a package if the mapping is in the package itself and is
not inherited from somewhere else.

There is no way to inherit the internal symbols of another package; to
refer to an internal symbol using the Lisp reader, a package containing
the symbol must be made to be the current package, a package prefix
must be used, or the symbol must be imported into the current package.

11.1.1.2.3 Accessibility of Symbols in a Package
................................................

A symbol becomes "accessible" in a package if that is its home package
when it is created, or if it is imported into that package, or by
inheritance via ‘use-package’.

If a symbol is accessible in a package, it can be referred to when
using the Lisp reader without a package prefix when that package is the
current package, regardless of whether it is present or inherited.

Symbols from one package can be made accessible in another package in
two ways.

   - Any individual symbol can be added to a package by use of
     ‘import’.  After the call to ‘import’ the symbol is present in the
     importing package.  The status of the symbol in the package it
     came from (if any) is unchanged, and the home package for this
     symbol is unchanged.  Once imported, a symbol is present in the
     importing package and can be removed only by calling ‘unintern’.

     A symbol is shadowed₃ by another symbol in some package if the
     first symbol would be accessible by inheritance if not for the
     presence of the second symbol.  See ‘shadowing-import’.

   - The second mechanism for making symbols from one package
     accessible in another is provided by ‘use-package’.  All of the
     external symbols of the used package are inherited by the using
     package.  The function ‘unuse-package’ undoes the effects of a
     previous ‘use-package’.

11.1.1.2.4 Locating a Symbol in a Package
.........................................

When a symbol is to be located in a given package the following occurs:

   - The external symbols and internal symbols of the package are
     searched for the symbol.

   - The external symbols of the used packages are searched in some
     unspecified order.  The order does not matter; see the rules for
     handling name conflicts listed below.

11.1.1.2.5 Prevention of Name Conflicts in Packages
...................................................

Within one package, any particular name can refer to at most one
symbol.  A name conflict is said to occur when there would be more than
one candidate symbol.  Any time a name conflict is about to occur, a
correctable error is signaled.

The following rules apply to name conflicts:

   - Name conflicts are detected when they become possible, that is,
     when the package structure is altered.  Name conflicts are not
     checked during every name lookup.

   - If the same symbol is accessible to a package through more than
     one path, there is no name conflict.  A symbol cannot conflict
     with itself.  Name conflicts occur only between distinct symbols
     with the same name (under ‘string=’).

   - Every package has a list of shadowing symbols.  A shadowing symbol
     takes precedence over any other symbol of the same name that would
     otherwise be accessible in the package.  A name conflict involving
     a shadowing symbol is always resolved in favor of the shadowing
     symbol, without signaling an error (except for one exception
     involving ‘import’).  See ‘shadow’ and ‘shadowing-import’.

   - The functions ‘use-package’, ‘import’, and ‘export’ check for name
     conflicts.

   - ‘shadow’ and ‘shadowing-import’ never signal a name-conflict error.

   - ‘unuse-package’ and ‘unexport’ do not need to do any name-conflict
     checking.  ‘unintern’ does name-conflict checking only when a
     symbol being uninterned is a shadowing symbol .

   - Giving a shadowing symbol to ‘unintern’ can uncover a name
     conflict that had previously been resolved by the shadowing.

   - Package functions signal name-conflict errors of type
     ‘package-error’ before making any change to the package structure.
     When multiple changes are to be made, it is permissible for the
     implementation to process each change separately.  For example,
     when ‘export’ is given a list of symbols, aborting from a name
     conflict caused by the second symbol in the list might still
     export the first symbol in the list.  However, a name-conflict
     error caused by ‘export’ of a single symbol will be signaled before
     that symbol's accessibility in any package is changed.

   - Continuing from a name-conflict error must offer the user a chance
     to resolve the name conflict in favor of either of the candidates.
     The package structure should be altered to reflect the resolution
     of the name conflict, via ‘shadowing-import’, ‘unintern’, or
     ‘unexport’.

   - A name conflict in ‘use-package’ between a symbol present in the
     using package and an external symbol of the used package is
     resolved in favor of the first symbol by making it a shadowing
     symbol, or in favor of the second symbol by uninterning the first
     symbol from the using package.

   - A name conflict in ‘export’ or ‘unintern’ due to a package's
     inheriting two distinct symbols with the same name (under
     ‘string=’) from two other packages can be resolved in favor of
     either symbol by importing it into the using package and making it
     a shadowing symbol , just as with ‘use-package’.


File: ansicl,  Node: Standardized Packages,  Prev: Introduction to Packages,  Up: Package Concepts

11.1.2 Standardized Packages
----------------------------

This section describes the packages that are available in every
conforming implementation.  A summary of the names and nicknames of
those standardized packages is given in the next figure.

Name                 Nicknames
--------------------------------- 
‘COMMON-LISP’        ‘CL’
‘COMMON-LISP-USER’   ‘CL-USER’
‘KEYWORD’            none

Figure 11.2: Standardized Package Names

11.1.2.1 The COMMON-LISP Package
................................

The ‘COMMON-LISP’ package contains the primitives of the Common
Lisp system as defined by this specification.  Its external symbols
include all of the defined names (except for defined names in the
‘KEYWORD’ package) that are present in the Common Lisp system, such as
‘car’, ‘cdr’,  ‘*package*’, etc.  The ‘COMMON-LISP’ package has the
nickname ‘CL’.

The ‘COMMON-LISP’ package has as external symbols those symbols
enumerated in the figures in *note Section 1.9 (Symbols in the
COMMON-LISP Package): Symbols in the COMMON-LISP Package, and no others.
These external symbols are present in the ‘COMMON-LISP’ package but
their home package need not be the ‘COMMON-LISP’ package.

For example, the symbol ‘HELP’ cannot be an external symbol of the
‘COMMON-LISP’ package because it is not mentioned in *note Section 1.9
(Symbols in the COMMON-LISP Package): Symbols in the COMMON-LISP
Package.  In contrast, the symbol variable must be an external symbol
of the ‘COMMON-LISP’ package even though it has no definition because
it is listed in that section (to support its use as a valid second
argument to the function ‘documentation’).

The ‘COMMON-LISP’ package can have additional internal symbols.

11.1.2.1.1 Constraints on the COMMON-LISP Package for Conforming Implementations
................................................................................

In a conforming implementation, an external symbol of the ‘COMMON-LISP’
package can have a function, macro, or special operator definition, a
global variable definition (or other status as a dynamic variable due
to a ‘special’ proclamation), or a type definition only if explicitly
permitted in this standard.  For example, ‘fboundp’ yields false for
any external symbol of the ‘COMMON-LISP’ package that is not the name
of a standardized function, macro or special operator, and ‘boundp’
returns false for any external symbol of the ‘COMMON-LISP’ package that
is not the name of a standardized global variable.  It also follows that
conforming programs can use external symbols of the ‘COMMON-LISP’
package as the names of local lexical variables with confidence that
those names have not been proclaimed ‘special’ by the implementation
unless those symbols are names of standardized global variables.

A conforming implementation must not place any property on an external
symbol of the ‘COMMON-LISP’ package using a property indicator that is
either an external symbol of any standardized package or a symbol that
is otherwise accessible in the ‘COMMON-LISP-USER’ package.

11.1.2.1.2 Constraints on the COMMON-LISP Package for Conforming Programs
.........................................................................

Except where explicitly allowed, the consequences are undefined if any
of the following actions are performed on an external symbol of the
‘COMMON-LISP’ package:

  1. Binding or altering its value (lexically or dynamically).  (Some
     exceptions are noted below.)

  2. Defining, undefining, or binding it as a function.  (Some
     exceptions are noted below.)

  3. Defining, undefining, or binding it as a macro or compiler macro.
     (Some exceptions are noted below.)

  4. Defining it as a type specifier (via ‘defstruct’, ‘defclass’,
     ‘deftype’, ‘define-condition’).

  5. Defining it as a structure (via ‘defstruct’).

  6. Defining it as a declaration with a ‘declaration’ proclamation.

  7. Defining it as a symbol macro.

  8. Altering its home package.

  9. Tracing it  (via ‘trace’).

 10. Declaring or proclaiming it ‘special’ (via declare, ‘declaim’, or
     ‘proclaim’).

 11. Declaring or proclaiming its ‘type’ or ‘ftype’ (via declare,
     ‘declaim’, or ‘proclaim’).  (Some exceptions are noted below.)

 12. Removing it from the ‘COMMON-LISP’ package.

 13. Defining a setf expander for it (via ‘defsetf’ or
     ‘define-setf-method’).

 14. Defining, undefining, or binding its setf function name.

 15. Defining it as a method combination type (via
     ‘define-method-combination’).

 16. Using it as the class-name argument to ‘setf’ of ‘find-class’.

 17. Binding it as a catch tag.

 18. Binding it as a restart name.

 19. Defining a method for a standardized generic function which is
     applicable when all of the arguments are direct instances of
     standardized classes.


11.1.2.1.2.1 Some Exceptions to Constraints on the COMMON-LISP Package for Conforming Programs
..............................................................................................

If an external symbol of the ‘COMMON-LISP’ package is not globally
defined as a standardized dynamic variable or constant variable, it is
allowed to lexically bind it and to declare the ‘type’ of that binding,
and it is allowed to locally establish it as a symbol macro (e.g., with
‘symbol-macrolet’).

Unless explicitly specified otherwise, if an external symbol of the
‘COMMON-LISP’ package is globally defined as a standardized dynamic
variable, it is permitted to bind or assign that dynamic variable
provided that the "Value Type" constraints on the dynamic variable are
maintained, and that the new value of the variable is consistent with
the stated purpose of the variable.

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a function (e.g., with ‘flet’), to declare the
‘ftype’ of that binding, and (in implementations which provide the
ability to do so) to ‘trace’ that binding.

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind it as a macro (e.g., with ‘macrolet’).

If an external symbol of the ‘COMMON-LISP’ package is not defined as a
standardized function, macro, or special operator, it is allowed to
lexically bind its setf function name as a function, and to declare the
‘ftype’ of that binding.

11.1.2.2 The COMMON-LISP-USER Package
.....................................

The ‘COMMON-LISP-USER’ package is the current package when a Common
Lisp system starts up.  This package uses the ‘COMMON-LISP’ package.
The ‘COMMON-LISP-USER’ package has the nickname ‘CL-USER’.  The
‘COMMON-LISP-USER’ package can have additional symbols interned within
it; it can use other implementation-defined packages.

11.1.2.3 The KEYWORD Package
............................

The ‘KEYWORD’ package contains symbols, called keywords₁, that are
typically used as special markers in programs and their associated data
expressions₁.

Symbol tokens that start with a package marker are parsed by the Lisp
reader as symbols in the ‘KEYWORD’ package; see *note Section 2.3.4
(Symbols as Tokens): Symbols as Tokens.  This makes it notationally
convenient to use keywords when communicating between programs in
different packages.  For example, the mechanism for passing keyword
parameters in a call uses keywords₁ to name the corresponding arguments;
see *note Section 3.4.1 (Ordinary Lambda Lists): Ordinary Lambda Lists.

Symbols in the ‘KEYWORD’ package are, by definition, of type ‘keyword’.

11.1.2.3.1 Interning a Symbol in the KEYWORD Package
....................................................

The ‘KEYWORD’ package is treated differently than other packages in
that special actions are taken when a symbol is interned in it.  In
particular, when a symbol is interned in the ‘KEYWORD’ package, it is
automatically made to be an external symbol and is automatically made
to be a constant variable with itself as a value.

11.1.2.3.2 Notes about The KEYWORD Package
..........................................

It is generally best to confine the use of keywords to situations in
which there are a finitely enumerable set of names to be selected
between.  For example, if there were two states of a light switch, they
might be called :on and :off.

In situations where the set of names is not finitely enumerable (i.e.,
where name conflicts might arise) it is frequently best to use symbols
in some package other than ‘KEYWORD’ so that conflicts will be
naturally avoided.  For example, it is generally not wise for a program
to use a keyword₁ as a property indicator, since if there were ever
another program that did the same thing, each would clobber the other's
data.

11.1.2.4 Implementation-Defined Packages
........................................

Other, implementation-defined packages might be present in the initial
Common Lisp environment.

It is recommended, but not required, that the documentation for a
conforming implementation contain a full list of all package names
initially present in that implementation but not specified in this
specification.  (See also the function ‘list-all-packages’.)



Local Variables:
coding: utf-8
End:
