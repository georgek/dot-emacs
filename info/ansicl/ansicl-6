This is ansicl, produced by makeinfo version 4.13 from temp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* ANSI Common Lisp: (ansicl).    Draft ANSI Common Lisp standard (dpANS3R).
END-INFO-DIR-ENTRY


File: ansicl,  Node: revappend; nreconc,  Next: butlast; nbutlast,  Prev: append,  Up: Conses

revappend, nreconc (Function)
=============================

Syntax:
.......

 -- Function: revappend list tail → result-list

 -- Function: nreconc list tail → result-list

Arguments and Values:
.....................

LIST--a proper list.

TAIL--an object.

RESULT-LIST--an object.

Description:
............

‘revappend’ constructs a copy₂ of LIST, but with the elements in
reverse order.  It then appends (as if by ‘nconc’) the TAIL to that
reversed list and returns the result.

‘nreconc’ reverses the order of elements in LIST (as if by ‘nreverse’).
It then appends (as if by ‘nconc’) the TAIL to that reversed list and
returns the result.

The resulting list shares list structure with TAIL.

Examples:
.........

 (let ((list-1 (list 1 2 3))
       (list-2 (list 'a 'b 'c)))
   (print (revappend list-1 list-2))
   (print (equal list-1 '(1 2 3)))
   (print (equal list-2 '(a b c))))
▷ (3 2 1 A B C)
▷ T
▷ T
→ T

 (revappend '(1 2 3) '()) → (3 2 1)
 (revappend '(1 2 3) '(a . b)) → (3 2 1 A . B)
 (revappend '() '(a b c)) → (A B C)
 (revappend '(1 2 3) 'a) → (3 2 1 . A)
 (revappend '() 'a) → A   ;degenerate case

 (let ((list-1 '(1 2 3))
       (list-2 '(a b c)))
   (print (nreconc list-1 list-2))
   (print (equal list-1 '(1 2 3)))
   (print (equal list-2 '(a b c))))
▷ (3 2 1 A B C)
▷ NIL
▷ T
→ T

Side Effects:
.............

‘revappend’ does not modify either of its arguments.  ‘nreconc’ is
permitted to modify LIST but not TAIL.

Although it might be implemented differently, ‘nreconc’ is constrained
to have side-effect behavior equivalent to:

 (nconc (nreverse LIST) TAIL)

See Also:
.........

*note reverse::, *note nreverse::, *note nconc::

Notes:
......

The following functional equivalences are true, although good
implementations will typically use a faster algorithm for achieving the
same effect:

 (revappend LIST TAIL) ≡ (nconc (reverse LIST) TAIL)
 (nreconc LIST TAIL) ≡ (nconc (nreverse LIST) TAIL)


File: ansicl,  Node: butlast; nbutlast,  Next: last,  Prev: revappend; nreconc,  Up: Conses

butlast, nbutlast (Function)
============================

Syntax:
.......

 -- Function: butlast list &optional n → result-list

 -- Function: nbutlast list &optional n → result-list

Arguments and Values:
.....................

LIST--a list, which might be a dotted list but must not be a circular
list.

N--a non-negative integer.

RESULT-LIST--a list.

Description:
............

‘butlast’ returns a copy of LIST from which the last N conses have been
omitted.  If N is not supplied, its value is 1.  If there are fewer
than N conses in LIST, ‘nil’ is returned and, in the case of ‘nbutlast’,
LIST is not modified.

‘nbutlast’ is like ‘butlast’, but ‘nbutlast’ may modify LIST.  It
changes the cdr of the cons N+1 from the end of the LIST to ‘nil’.

Examples:
.........

 (setq lst '(1 2 3 4 5 6 7 8 9)) → (1 2 3 4 5 6 7 8 9)
 (butlast lst) → (1 2 3 4 5 6 7 8)
 (butlast lst 5) → (1 2 3 4)
 (butlast lst (+ 5 5)) → NIL
 lst → (1 2 3 4 5 6 7 8 9)
 (nbutlast lst 3) → (1 2 3 4 5 6)
 lst → (1 2 3 4 5 6)
 (nbutlast lst 99) → NIL
 lst → (1 2 3 4 5 6)
 (butlast '(a b c d)) → (A B C)
 (butlast '((a b) (c d))) → ((A B))
 (butlast '(a)) → NIL
 (butlast nil) → NIL
 (setq foo (list 'a 'b 'c 'd)) → (A B C D)
 (nbutlast foo) → (A B C)
 foo → (A B C)
 (nbutlast (list 'a)) → NIL
 (nbutlast '()) → NIL

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if LIST is not a proper
list or a dotted list.  Should signal an error of type ‘type-error’ if
N is not a non-negative integer.

Notes:
......

 (butlast LIST N) ≡ (ldiff LIST (last LIST N))


File: ansicl,  Node: last,  Next: ldiff; tailp,  Prev: butlast; nbutlast,  Up: Conses

last (Function)
===============

Syntax:
.......

 -- Function: last list &optional n → tail

Arguments and Values:
.....................

LIST--a list, which might be a dotted list but must not be a circular
list.

N--a non-negative integer.  The default is ‘1’.

TAIL--an object.

Description:
............

‘last’ returns the last N conses (not the last N elements) of LIST).
If LIST is (), ‘last’ returns ().

If N is zero, the atom that terminates LIST is returned.  If N is
greater than or equal to the number of cons cells in LIST, the result
is LIST.

Examples:
.........

 (last nil) → NIL
 (last '(1 2 3)) → (3)
 (last '(1 2 . 3)) → (2 . 3)
 (setq x (list 'a 'b 'c 'd)) → (A B C D)
 (last x) → (D)
 (rplacd (last x) (list 'e 'f)) x → (A B C D E F)
 (last x) → (F)

 (last '(a b c))   → (C)

 (last '(a b c) 0) → ()
 (last '(a b c) 1) → (C)
 (last '(a b c) 2) → (B C)
 (last '(a b c) 3) → (A B C)
 (last '(a b c) 4) → (A B C)

 (last '(a . b) 0) → B
 (last '(a . b) 1) → (A . B)
 (last '(a . b) 2) → (A . B)

Exceptional Situations:
.......................

The consequences are undefined if LIST is a circular list.  Should
signal an error of type ‘type-error’ if N is not a non-negative integer.

See Also:
.........

*note butlast::, *note nth::

Notes:
......

The following code could be used to define ‘last’.

 (defun last (list &optional (n 1))
   (check-type n (integer 0))
   (do ((l list (cdr l))
        (r list)
        (i 0 (+ i 1)))
       ((atom l) r)
     (if (>= i n) (pop r))))


File: ansicl,  Node: ldiff; tailp,  Next: nthcdr,  Prev: last,  Up: Conses

ldiff, tailp (Function)
=======================

Syntax:
.......

 -- Function: ldiff list object → result-list

 -- Function: tailp object list → generalized-boolean

Arguments and Values:
.....................

LIST--a list, which might be a dotted list.

OBJECT--an object.

RESULT-LIST--a list.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

If OBJECT is the same as some tail of LIST, ‘tailp’ returns true;
otherwise, it returns false.

If OBJECT is the same as some tail of LIST, ‘ldiff’ returns a fresh list
of the elements of list that precede ‘object’ in the list structure of
LIST; otherwise, it returns a copy₂ of LIST.

Examples:
.........

 (let ((lists '#((a b c) (a b c . d))))
   (dotimes (i (length lists)) ()
     (let ((list (aref lists i)))
       (format t "~2&list=~S ~21T(tailp object list)~
                  ~44T(ldiff list object)~%" list)
         (let ((objects (vector list (cddr list) (copy-list (cddr list))
                                '(f g h) '() 'd 'x)))
           (dotimes (j (length objects)) ()
             (let ((object (aref objects j)))
               (format t "~& object=~S ~21T~S ~44T~S"
                       object (tailp object list) (ldiff list object))))))))
▷
▷ list=(A B C)         (tailp object list)    (ldiff list object)
▷  object=(A B C)      T                      NIL
▷  object=(C)          T                      (A B)
▷  object=(C)          NIL                    (A B C)
▷  object=(F G H)      NIL                    (A B C)
▷  object=NIL          T                      (A B C)
▷  object=D            NIL                    (A B C)
▷  object=X            NIL                    (A B C)
▷
▷ list=(A B C . D)     (tailp object list)    (ldiff list object)
▷  object=(A B C . D)  T                      NIL
▷  object=(C . D)      T                      (A B)
▷  object=(C . D)      NIL                    (A B C . D)
▷  object=(F G H)      NIL                    (A B C . D)
▷  object=NIL          NIL                    (A B C . D)
▷  object=D            T                      (A B C)
▷  object=X            NIL                    (A B C . D)
→ NIL

Side Effects:
.............

Neither ‘ldiff’ nor ‘tailp’ modifies either of its arguments.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list or a dotted list.

See Also:
.........

*note set-difference::

Notes:
......

If the LIST is a circular list, ‘tailp’ will reliably yield a value
only if the given OBJECT is in fact a tail of LIST.  Otherwise, the
consequences are unspecified: a given implementation which detects the
circularity must return false, but since an implementation is not
obliged to detect such a situation, ‘tailp’ might just loop
indefinitely without returning in that case.

‘tailp’ could be defined as follows:

 (defun tailp (object list)
   (do ((list list (cdr list)))
       ((atom list) (eql list object))
      (if (eql object list)
          (return t))))

and ‘ldiff’ could be defined by:

(defun ldiff (list object)
  (do ((list list (cdr list))
       (r '() (cons (car list) r)))
      ((atom list)
       (if (eql list object) (nreverse r) (nreconc r list)))
    (when (eql object list)
      (return (nreverse r)))))


File: ansicl,  Node: nthcdr,  Next: rest,  Prev: ldiff; tailp,  Up: Conses

nthcdr (Function)
=================

Syntax:
.......

 -- Function: nthcdr n list → tail

Arguments and Values:
.....................

N--a non-negative integer.

LIST--a list, which might be a dotted list or a circular list.

TAIL--an object.

Description:
............

Returns the tail of LIST that would be obtained by calling ‘cdr’ N
times in succession.

Examples:
.........

 (nthcdr 0 '()) → NIL
 (nthcdr 3 '()) → NIL
 (nthcdr 0 '(a b c)) → (A B C)
 (nthcdr 2 '(a b c)) → (C)
 (nthcdr 4 '(a b c)) → ()
 (nthcdr 1 '(0 . 1)) → 1

 (locally (declare (optimize (safety 3)))
   (nthcdr 3 '(0 . 1)))
 Error: Attempted to take CDR of 1.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if N is not a non-negative
integer.

For N being an integer greater than ‘1’, the error checking done by
‘(nthcdr N LIST)’ is the same as for ‘(nthcdr (- N 1) (cdr LIST))’; see
the function *note cdr::.

See Also:
.........

*note cdr::, *note nth::, *note rest::


File: ansicl,  Node: rest,  Next: member; member-if; member-if-not,  Prev: nthcdr,  Up: Conses

rest (Accessor)
===============

Syntax:
.......

 -- Function: rest list → tail

(setf (rest list) new-tail)

Arguments and Values:
.....................

LIST--a list, which might be a dotted list or a circular list.

TAIL--an object.

Description:
............

‘rest’ performs the same operation as ‘cdr’, but mnemonically
complements ‘first’.  Specifically,

 (rest LIST) ≡ (cdr LIST)
 (setf (rest LIST) NEW-TAIL) ≡ (setf (cdr LIST) NEW-TAIL)

Examples:
.........

 (rest '(1 2)) → (2)
 (rest '(1 . 2)) → 2
 (rest '(1)) → NIL
 (setq *cons* '(1 . 2)) → (1 . 2)
 (setf (rest *cons*) "two") → "two"
 *cons* → (1 . "two")

See Also:
.........

*note cdr::, *note nthcdr::

Notes:
......

‘rest’ is often preferred stylistically over ‘cdr’ when the argument is
to being subjectively viewed as a list rather than as a cons.


File: ansicl,  Node: member; member-if; member-if-not,  Next: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Prev: rest,  Up: Conses

member, member-if, member-if-not (Function)
===========================================

Syntax:
.......

 -- Function: member item list &key key test test-not → tail

 -- Function: member-if predicate list &key key → tail

 -- Function: member-if-not predicate list &key key → tail

Arguments and Values:
.....................

ITEM--an object.

LIST--a proper list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

TAIL--a list.

Description:
............

‘member’, ‘member-if’, and ‘member-if-not’ each search LIST for ITEM or
for a top-level element that satisfies the test.  The argument to the
PREDICATE function is an element of LIST.

If some element satisfies the test, the tail of LIST beginning with
this element is returned; otherwise ‘nil’ is returned.

LIST is searched on the top level only.

Examples:
.........

 (member 2 '(1 2 3)) → (2 3)
 (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) → ((3 . 4))
 (member 'e '(a b c d)) → NIL

 (member-if #'listp '(a b nil c d)) → (NIL C D)
 (member-if #'numberp '(a #\Space 5/3 foo)) → (5/3 FOO)
 (member-if-not #'zerop
                 '(3 6 9 11 . 12)
                 :key #'(lambda (x) (mod x 3))) → (11 . 12)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list.

See Also:
.........

*note find::, *note position::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘member-if-not’ is deprecated.

In the following

 (member 'a '(g (a y) c a d e a f)) → (A D E A F)

the value returned by ‘member’ is identical to the portion of the list
beginning with ‘a’.  Thus ‘rplaca’ on the result of ‘member’ can be
used to alter the part of the list where ‘a’ was found (assuming a
check has been made that ‘member’ did not return ‘nil’).


File: ansicl,  Node: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Next: acons,  Prev: member; member-if; member-if-not,  Up: Conses

mapc, mapcar, mapcan, mapl, maplist, mapcon (Function)
======================================================

Syntax:
.......

 -- Function: mapc function &rest lists+ → list-1

 -- Function: mapcar function &rest lists+ → result-list

 -- Function: mapcan function &rest lists+ → concatenated-results

 -- Function: mapl function &rest lists+ → list-1

 -- Function: maplist function &rest lists+ → result-list

 -- Function: mapcon function &rest lists+ → concatenated-results

Arguments and Values:
.....................

FUNCTION--a designator for a function that must take as many arguments
as there are LISTS.

LIST--a proper list.

LIST-1--the first LIST (which must be a proper list).

RESULT-LIST--a list.

CONCATENATED-RESULTS--a list.

Description:
............

The mapping operation involves applying FUNCTION to successive sets of
arguments in which one argument is obtained from each sequence.  Except
for ‘mapc’ and ‘mapl’, the result contains the results returned by
FUNCTION.  In the cases of ‘mapc’ and ‘mapl’, the resulting sequence is
LIST.

FUNCTION is called first on all the elements with index ‘0’, then on
all those with index ‘1’, and so on.  RESULT-TYPE specifies the type of
the resulting sequence.  If FUNCTION is a symbol, it is ‘coerce’d to a
function as if by ‘symbol-function’.

‘mapcar’ operates on successive elements of the LISTS.  FUNCTION is
applied to the first element of each LIST, then to the second element
of each LIST, and so on.  The iteration terminates when the shortest
LIST runs out, and excess elements in other lists are ignored.  The
value returned by ‘mapcar’ is a list of the results of successive calls
to FUNCTION.

‘mapc’ is like ‘mapcar’ except that the results of applying FUNCTION
are not accumulated.  The LIST argument is returned.

‘maplist’ is like ‘mapcar’ except that FUNCTION is applied to
successive sublists of the LISTS.  FUNCTION is first applied to the
LISTS themselves, and then to the cdr of each LIST, and then to the cdr
of the cdr of each LIST, and so on.

‘mapl’ is like ‘maplist’ except that the results of applying FUNCTION
are not accumulated; LIST-1 is returned.

‘mapcan’ and ‘mapcon’ are like ‘mapcar’ and ‘maplist’ respectively,
except that the results of applying FUNCTION are combined into a list
by the use of ‘nconc’ rather than ‘list’.  That is,

 (mapcon f x1 ... xn)
   ≡ (apply #'nconc (maplist f x1 ... xn))

and similarly for the relationship between ‘mapcan’ and ‘mapcar’.

Examples:
.........

 (mapcar #'car '((1 a) (2 b) (3 c))) → (1 2 3)
 (mapcar #'abs '(3 -4 2 -5 -6)) → (3 4 2 5 6)
 (mapcar #'cons '(a b c) '(1 2 3)) → ((A . 1) (B . 2) (C . 3))

 (maplist #'append '(1 2 3 4) '(1 2) '(1 2 3))
→ ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3))
 (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
→ ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
 (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
→ (0 0 1 0 1 1 1)
;An entry is 1 if the corresponding element of the input
;  list was the last instance of that element in the input list.

 (setq dummy nil) → NIL
 (mapc #'(lambda (&rest x) (setq dummy (append dummy x)))
        '(1 2 3 4)
        '(a b c d e)
        '(x y z)) → (1 2 3 4)
 dummy → (1 A X 2 B Y 3 C Z)

 (setq dummy nil) → NIL
 (mapl #'(lambda (x) (push x dummy)) '(1 2 3 4)) → (1 2 3 4)
 dummy → ((4) (3 4) (2 3 4) (1 2 3 4))

 (mapcan #'(lambda (x y) (if (null x) nil (list x y)))
          '(nil nil nil d e)
          '(1 2 3 4 5 6)) → (D 4 E 5)
 (mapcan #'(lambda (x) (and (numberp x) (list x)))
          '(a 1 b c 3 4 d 5))
→ (1 3 4 5)

In this case the function serves as a filter; this is a standard
Lisp idiom using ‘mapcan’.

 (mapcon #'list '(1 2 3 4)) → ((1 2 3 4) (2 3 4) (3 4) (4))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if any LIST
is not a proper list.

See Also:
.........

*note dolist::, *note map::, *note Section 3.6 (Traversal Rules and
Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: acons,  Next: assoc; assoc-if; assoc-if-not,  Prev: mapc; mapcar; mapcan; mapl; maplist; mapcon,  Up: Conses

acons (Function)
================

Syntax:
.......

 -- Function: acons key datum alist → new-alist

Arguments and Values:
.....................

KEY--an object.

DATUM--an object.

ALIST--an association list.

NEW-ALIST--an association list.

Description:
............

Creates a fresh cons, the cdr of which is ALIST and the car of which is
another fresh cons, the car of which is KEY and the cdr of which is
DATUM.

Examples:
.........

 (setq alist '()) → NIL
 (acons 1 "one" alist) → ((1 . "one"))
 alist → NIL
 (setq alist (acons 1 "one" (acons 2 "two" alist))) → ((1 . "one") (2 . "two"))
 (assoc 1 alist) → (1 . "one")
 (setq alist (acons 1 "uno" alist)) → ((1 . "uno") (1 . "one") (2 . "two"))
 (assoc 1 alist) → (1 . "uno")

See Also:
.........

*note assoc::, *note pairlis::

Notes:
......

(acons KEY DATUM ALIST) ≡ (cons (cons KEY DATUM) ALIST)


File: ansicl,  Node: assoc; assoc-if; assoc-if-not,  Next: copy-alist,  Prev: acons,  Up: Conses

assoc, assoc-if, assoc-if-not (Function)
========================================

Syntax:
.......

 -- Function: assoc item alist &key key test test-not → entry

 -- Function: assoc-if predicate alist &key key → entry

 -- Function: assoc-if-not predicate alist &key key → entry

Arguments and Values:
.....................

ITEM--an object.

ALIST--an association list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

ENTRY--a cons that is an element of ALIST, or ‘nil’.

Description:
............

‘assoc’, ‘assoc-if’, and ‘assoc-if-not’ return the first cons in ALIST
whose car satisfies the test, or ‘nil’ if no such cons is found.

For ‘assoc’, ‘assoc-if’, and ‘assoc-if-not’, if ‘nil’ appears in ALIST
in place of a pair, it is ignored.

Examples:
.........

 (setq values '((x . 100) (y . 200) (z . 50))) → ((X . 100) (Y . 200) (Z . 50))
 (assoc 'y values) → (Y . 200)
 (rplacd (assoc 'y values) 201) → (Y . 201)
 (assoc 'y values) → (Y . 201)
 (setq alist '((1 . "one")(2 . "two")(3 . "three")))
→ ((1 . "one") (2 . "two") (3 . "three"))
 (assoc 2 alist) → (2 . "two")
 (assoc-if #'evenp alist) → (2 . "two")
 (assoc-if-not #'(lambda(x) (< x 3)) alist) → (3 . "three")
 (setq alist '(("one" . 1)("two" . 2))) → (("one" . 1) ("two" . 2))
 (assoc "one" alist) → NIL
 (assoc "one" alist :test #'equalp) → ("one" . 1)
 (assoc "two" alist :key #'(lambda(x) (char x 2))) → NIL
 (assoc #\o alist :key #'(lambda(x) (char x 2))) → ("two" . 2)
 (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) →  (R . X)
 (assoc 'goo '((foo . bar) (zoo . goo))) → NIL
 (assoc '2 '((1 a b c) (2 b c d) (-7 x y z))) → (2 B C D)
 (setq alist '(("one" . 1) ("2" . 2) ("three" . 3)))
→ (("one" . 1) ("2" . 2) ("three" . 3))
 (assoc-if-not #'alpha-char-p alist
               :key #'(lambda (x) (char x 0))) → ("2" . 2)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if ALIST is
not an association list.

See Also:
.........

*note rassoc::, *note find::, *note member::, *note position::, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘assoc-if-not’ is deprecated.

It is possible to ‘rplacd’ the result of ‘assoc’, provided that it is
not ‘nil’, in order to "update" ALIST.

The two expressions

 (assoc item list :test fn)

and

 (find item list :test fn :key #'car)

are equivalent in meaning with one exception: if ‘nil’ appears in ALIST
in place of a pair, and ITEM is ‘nil’, ‘find’ will compute the car of
the ‘nil’ in ALIST, find that it is equal to ITEM, and return ‘nil’,
whereas ‘assoc’ will ignore the ‘nil’ in ALIST and continue to search
for an actual cons whose car is ‘nil’.


File: ansicl,  Node: copy-alist,  Next: pairlis,  Prev: assoc; assoc-if; assoc-if-not,  Up: Conses

copy-alist (Function)
=====================

Syntax:
.......

 -- Function: copy-alist alist → new-alist

Arguments and Values:
.....................

ALIST--an association list.

NEW-ALIST--an association list.

Description:
............

‘copy-alist’ returns a copy of ALIST.

The list structure of ALIST is copied, and the elements of ALIST which
are conses are also copied (as conses only).  Any other objects which
are referred to, whether directly or indirectly, by the ALIST continue
to be shared.

Examples:
.........

(defparameter *alist* (acons 1 "one" (acons 2 "two" '())))
*alist* → ((1 . "one") (2 . "two"))
(defparameter *list-copy* (copy-list *alist*))
*list-copy* → ((1 . "one") (2 . "two"))
(defparameter *alist-copy* (copy-alist *alist*))
*alist-copy* → ((1 . "one") (2 . "two"))
(setf (cdr (assoc 2 *alist-copy*)) "deux") → "deux"
*alist-copy* → ((1 . "one") (2 . "deux"))
*alist* → ((1 . "one") (2 . "two"))
(setf (cdr (assoc 1 *list-copy*)) "uno") → "uno"
*list-copy* → ((1 . "uno") (2 . "two"))
*alist* → ((1 . "uno") (2 . "two"))

See Also:
.........

*note copy-list::


File: ansicl,  Node: pairlis,  Next: rassoc; rassoc-if; rassoc-if-not,  Prev: copy-alist,  Up: Conses

pairlis (Function)
==================

Syntax:
.......

 -- Function: pairlis keys data &optional alist → new-alist

Arguments and Values:
.....................

KEYS--a proper list.

DATA--a proper list.

ALIST--an association list.  The default is the empty list.

NEW-ALIST--an association list.

Description:
............

Returns an association list that associates elements of KEYS to
corresponding elements of DATA.  The consequences are undefined if KEYS
and DATA are not of the same length.

If ALIST is supplied, ‘pairlis’ returns a modified ALIST with the new
pairs prepended to it.  The new pairs may appear in the resulting
association list in either forward or backward order.  The result of

 (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))

might be

 ((one . 1) (two . 2) (three . 3) (four . 19))

or

 ((two . 2) (one . 1) (three . 3) (four . 19))

Examples:
.........

 (setq keys '(1 2 3)
        data '("one" "two" "three")
        alist '((4 . "four"))) → ((4 . "four"))
 (pairlis keys data) → ((3 . "three") (2 . "two") (1 . "one"))
 (pairlis keys data alist)
→ ((3 . "three") (2 . "two") (1 . "one") (4 . "four"))
 alist → ((4 . "four"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if KEYS AND
DATA are not proper lists.

See Also:
.........

*note acons::


File: ansicl,  Node: rassoc; rassoc-if; rassoc-if-not,  Next: get-properties,  Prev: pairlis,  Up: Conses

rassoc, rassoc-if, rassoc-if-not (Function)
===========================================

Syntax:
.......

 -- Function: rassoc item alist &key key test test-not → entry

 -- Function: rassoc-if predicate alist &key key → entry

 -- Function: rassoc-if-not predicate alist &key key → entry

Arguments and Values:
.....................

ITEM--an object.

ALIST--an association list.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

ENTRY--a cons that is an element of the ALIST, or ‘nil’.

Description:
............

‘rassoc’, ‘rassoc-if’, and ‘rassoc-if-not’ return the first cons whose
cdr satisfies the test.  If no such cons is found, ‘nil’ is returned.

If ‘nil’ appears in ALIST in place of a pair, it is  ignored.

Examples:
.........

 (setq alist '((1 . "one") (2 . "two") (3 . 3)))
→ ((1 . "one") (2 . "two") (3 . 3))
 (rassoc 3 alist) → (3 . 3)
 (rassoc "two" alist) → NIL
 (rassoc "two" alist :test 'equal) → (2 . "two")
 (rassoc 1 alist :key #'(lambda (x) (if (numberp x) (/ x 3)))) → (3 . 3)
 (rassoc 'a '((a . b) (b . c) (c . a) (z . a))) → (C . A)
 (rassoc-if #'stringp alist) → (1 . "one")
 (rassoc-if-not #'vectorp alist) → (3 . 3)

See Also:
.........

*note assoc::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

The function ‘rassoc-if-not’ is deprecated.

It is possible to ‘rplaca’ the result of ‘rassoc’, provided that it is
not ‘nil’, in order to "update" ALIST.

The expressions

 (rassoc item list :test fn)

and

 (find item list :test fn :key #'cdr)

are equivalent in meaning, except when the ‘item’ is ‘nil’ and
‘nil’ appears in place of a pair in the ALIST.  See the function *note
assoc::.


File: ansicl,  Node: get-properties,  Next: getf,  Prev: rassoc; rassoc-if; rassoc-if-not,  Up: Conses

get-properties (Function)
=========================

Syntax:
.......

 -- Function: get-properties plist indicator-list → indicator, value,
          tail

Arguments and Values:
.....................

PLIST--a property list.

INDICATOR-LIST--a proper list (of indicators).

INDICATOR--an object that is an element of INDICATOR-LIST.

VALUE--an object.

TAIL--a list.

Description:
............

‘get-properties’ is used to look up any of several property list
entries all at once.

It searches the PLIST for the first entry whose indicator is identical
to one of the objects in INDICATOR-LIST.  If such an entry is found,
the INDICATOR and VALUE returned are the property indicator and its
associated property value, and the TAIL returned is the tail of the
PLIST that begins with the found entry (i.e., whose car is the
INDICATOR).  If no such entry is found, the INDICATOR, VALUE, and TAIL
are all ‘nil’.

Examples:
.........

 (setq x '()) → NIL
 (setq *indicator-list* '(prop1 prop2)) → (PROP1 PROP2)
 (getf x 'prop1) → NIL
 (setf (getf x 'prop1) 'val1) → VAL1
 (eq (getf x 'prop1) 'val1) → true
 (get-properties x *indicator-list*) → PROP1, VAL1, (PROP1 VAL1)
 x → (PROP1 VAL1)

See Also:
.........

*note get::, *note getf::


File: ansicl,  Node: getf,  Next: remf,  Prev: get-properties,  Up: Conses

getf (Accessor)
===============

Syntax:
.......

 -- Function: getf plist indicator &optional default → value

(setf (getf place indicator &optional default) new-value)

Arguments and Values:
.....................

PLIST--a property list.

PLACE--a place, the value of which is a property list.

INDICATOR--an object.

DEFAULT--an object.  The default is ‘nil’.

VALUE--an object.

NEW-VALUE--an object.

Description:
............

‘getf’ finds a property on the PLIST whose property indicator is
identical to INDICATOR, and returns its corresponding property value.
If there are multiple properties₁ with that property indicator, ‘getf’
uses the first such property.  If there is no property with that
property indicator, DEFAULT is returned.

‘setf’ of ‘getf’ may be used to associate a new object with an existing
indicator in the property list held by PLACE, or to create a new
assocation if none exists.  If there are multiple properties₁ with that
property indicator, ‘setf’ of ‘getf’ associates the NEW-VALUE with the
first such property.  When a ‘getf’ form is used as a ‘setf’ PLACE, any
DEFAULT which is supplied is evaluated according to normal
left-to-right evaluation rules, but its value is ignored.

‘setf’ of ‘getf’ is permitted to either write the value of PLACE itself,
or modify of any part, car or cdr, of the list structure held by PLACE.

Examples:
.........

 (setq x '()) → NIL
 (getf x 'prop1) → NIL
 (getf x 'prop1 7) → 7
 (getf x 'prop1) → NIL
 (setf (getf x 'prop1) 'val1) → VAL1
 (eq (getf x 'prop1) 'val1) → true
 (getf x 'prop1) → VAL1
 (getf x 'prop1 7) → VAL1
 x → (PROP1 VAL1)

;; Examples of implementation variation permitted.
 (setq foo (list 'a 'b 'c 'd 'e 'f)) → (A B C D E F)
 (setq bar (cddr foo)) → (C D E F)
 (remf foo 'c) → true
 foo → (A B E F)
 bar
→ (C D E F)
or→ (C)
or→ (NIL)
or→ (C NIL)
or→ (C D)

See Also:
.........

*note get::, *note get-properties::, *note setf::, *note Section
5.1.2.2 (Function Call Forms as Places): FnFormsAsGenRefs.

Notes:
......

There is no way (using ‘getf’) to distinguish an absent property from
one whose value is DEFAULT; but see ‘get-properties’.

Note that while supplying a default argument to ‘getf’ in a ‘setf’
situation is sometimes not very interesting, it is still important
because some macros, such as ‘push’ and ‘incf’, require a PLACE
argument which data is both read from and written to.  In such a
context, if a default argument is to be supplied for the read
situation, it must be syntactically valid for the write situation as
well. For example,

 (let ((plist '()))
   (incf (getf plist 'count 0))
   plist) → (COUNT 1)


File: ansicl,  Node: remf,  Next: intersection; nintersection,  Prev: getf,  Up: Conses

remf (Macro)
============

Syntax:
.......

 -- Macro: remf place indicator → generalized-boolean

Arguments and Values:
.....................

PLACE--a place.

INDICATOR--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘remf’ removes from the property list stored in PLACE a property₁ with
a property indicator identical to INDICATOR.  If there are multiple
properties₁ with the identical key, ‘remf’ only removes the first such
property.  ‘remf’ returns false if no such property was found, or true
if a property was found.

The property indicator and the corresponding property value are removed
in an undefined order by destructively splicing the property list.
‘remf’ is permitted to either ‘setf’ PLACE or to ‘setf’ any part, ‘car’
or ‘cdr’, of the list structure held by that PLACE.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

Examples:
.........

 (setq x (cons () ())) → (NIL)
 (setf (getf (car x) 'prop1) 'val1) → VAL1
 (remf (car x) 'prop1) → true
 (remf (car x) 'prop1) → false

Side Effects:
.............

The property list stored in PLACE is modified.

See Also:
.........

*note remprop::, *note getf::


File: ansicl,  Node: intersection; nintersection,  Next: adjoin,  Prev: remf,  Up: Conses

intersection, nintersection (Function)
======================================

Syntax:
.......

 -- Function: intersection list-1 list-2 &key key test test-not →
          result-list

 -- Function: nintersection list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-LIST--a list.

Description:
............

‘intersection’ and ‘nintersection’ return a list that contains every
element that occurs in both LIST-1 and LIST-2.

‘nintersection’ is the destructive version of ‘intersection’.  It
performs the same operation, but may destroy LIST-1 using its cells to
construct the result.  LIST-2 is not destroyed.

The intersection operation is described as follows.  For all possible
ordered pairs consisting of one element from LIST-1 and one element
from LIST-2, :test or :test-not are used to determine whether they
satisfy the test.  The first argument to the :test or :test-not
function is an element of LIST-1; the second argument is an element of
LIST-2.  If :test or :test-not is not supplied, ‘eql’ is used.  It is
an error if :test and :test-not are supplied in the same function call.

If :key is supplied (and not ‘nil’), it is used to extract the part to
be tested from the LIST element.  The argument to the :key function is
an element of either LIST-1 or LIST-2; the :key function typically
returns part of the supplied element.  If :key is not supplied or
‘nil’, the LIST-1 and LIST-2 elements are used.

For every pair that satifies the test, exactly one of the two elements
of the pair will be put in the result.  No element from either list
appears in the result that does not satisfy the test for an element
from the other list.  If one of the lists contains duplicate elements,
there may be duplication in the result.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The
result list may share cells with, or be ‘eq’ to, either LIST-1 or LIST-2
if appropriate.

Examples:
.........

 (setq list1 (list 1 1 2 3 4 a b c "A" "B" "C" "d")
       list2 (list 1 4 5 b c d "a" "B" "c" "D"))
  → (1 4 5 B C D "a" "B" "c" "D")
 (intersection list1 list2) → (C B 4 1 1)
 (intersection list1 list2 :test 'equal) → ("B" C B 4 1 1)
 (intersection list1 list2 :test #'equalp) → ("d" "C" "B" "A" C B 4 1 1)
 (nintersection list1 list2) → (1 1 4 B C)
 list1 → implementation-dependent ;e.g., (1 1 4 B C)
 list2 → implementation-dependent ;e.g., (1 4 5 B C D "a" "B" "c" "D")
 (setq list1 (copy-list '((1 . 2) (2 . 3) (3 . 4) (4 . 5))))
→ ((1 . 2) (2 . 3) (3 . 4) (4 . 5))
 (setq list2 (copy-list '((1 . 3) (2 . 4) (3 . 6) (4 . 8))))
→ ((1 . 3) (2 . 4) (3 . 6) (4 . 8))
 (nintersection list1 list2 :key #'cdr) → ((2 . 3) (3 . 4))
 list1 → implementation-dependent ;e.g., ((1 . 2) (2 . 3) (3 . 4))
 list2 → implementation-dependent ;e.g., ((1 . 3) (2 . 4) (3 . 6) (4 . 8))

Side Effects:
.............

‘nintersection’ can modify LIST-1, but not LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*note union::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nintersection’ side effect is not required, it should not be
used in for-effect-only positions in portable code.


File: ansicl,  Node: adjoin,  Next: pushnew,  Prev: intersection; nintersection,  Up: Conses

adjoin (Function)
=================

Syntax:
.......

 -- Function: adjoin item list &key key test test-not → new-list

Arguments and Values:
.....................

ITEM--an object.

LIST--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

NEW-LIST--a list.

Description:
............

Tests whether ITEM is the same as an existing element of LIST.  If the
ITEM is not an existing element, ‘adjoin’ adds it to LIST (as if by
‘cons’) and returns the resulting list; otherwise, nothing is added and
the original LIST is returned.

The TEST, TEST-NOT, and KEY affect how it is determined whether ITEM is
the same as an element of LIST.  For details, *note Satisfying a
Two-Argument Test: SatisfyingTheTwoArgTest.

Examples:
.........

 (setq slist '()) → NIL
 (adjoin 'a slist) → (A)
 slist → NIL
 (setq slist (adjoin '(test-item 1) slist)) → ((TEST-ITEM 1))
 (adjoin '(test-item 1) slist) → ((TEST-ITEM 1) (TEST-ITEM 1))
 (adjoin '(test-item 1) slist :test 'equal) → ((TEST-ITEM 1))
 (adjoin '(new-test-item 1) slist :key #'cadr) → ((TEST-ITEM 1))
 (adjoin '(new-test-item 1) slist) → ((NEW-TEST-ITEM 1) (TEST-ITEM 1))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST is
not a proper list.

See Also:
.........

*note pushnew::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

 (adjoin item list :key fn)
   ≡ (if (member (fn item) list :key fn) list (cons item list))


File: ansicl,  Node: pushnew,  Next: set-difference; nset-difference,  Prev: adjoin,  Up: Conses

pushnew (Macro)
===============

Syntax:
.......

 -- Macro: pushnew item place &key key test test-not → new-place-value

Arguments and Values:
.....................

ITEM--an object.

PLACE--a place, the value of which is a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

NEW-PLACE-VALUE--a list (the new value of PLACE).

Description:
............

‘pushnew’ tests whether  ITEM is the same as any existing element of
the list stored in PLACE.  If ITEM is not, it is prepended to the list,
and the new list is stored in PLACE.

‘pushnew’ returns the new list that is stored in PLACE.

Whether or not ITEM is already a member of the list that is in PLACE is
determined by comparisons using :test or :test-not.  The first argument
to the :test or :test-not function is ITEM; the second argument is an
element of the list in PLACE as returned by the :key function (if
supplied).

If :key is supplied, it is used to extract the part to be tested from
both ITEM and the list element, as for ‘adjoin’.

The argument to the :key function is an element of the list stored in
PLACE. The :key function typically returns part part of the element of
the list.  If :key is not supplied or ‘nil’, the list element is used.

For information about the evaluation of subforms of PLACE, see *note
Section 5.1.1.1 (Evaluation of Subforms to Places): GenRefSubFormEval.

It is implementation-dependent whether or not ‘pushnew’ actually
executes the storing form for its PLACE in the situation where the ITEM
is already a member of the list held by PLACE.

Examples:
.........

 (setq x '(a (b c) d)) → (A (B C) D)
 (pushnew 5 (cadr x)) → (5 B C)
 x → (A (5 B C) D)
 (pushnew 'b (cadr x)) → (5 B C)
 x → (A (5 B C) D)
 (setq lst '((1) (1 2) (1 2 3))) → ((1) (1 2) (1 2 3))
 (pushnew '(2) lst) → ((2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst) → ((1) (2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst :test 'equal) → ((1) (2) (1) (1 2) (1 2 3))
 (pushnew '(1) lst :key #'car) → ((1) (2) (1) (1 2) (1 2 3))

Side Effects:
.............

The contents of PLACE may be modified.

See Also:
.........

*note push::, *note adjoin::, *note Section 5.1 (Generalized
Reference): Generalized Reference.

Notes:
......

The effect of
 (pushnew item place :test p)

is roughly equivalent to
 (setf place (adjoin item place :test p))

except that the subforms of ‘place’ are evaluated only once, and ‘item’
is evaluated before ‘place’.


File: ansicl,  Node: set-difference; nset-difference,  Next: set-exclusive-or; nset-exclusive-or,  Prev: pushnew,  Up: Conses

set-difference, nset-difference (Function)
==========================================

Syntax:
.......

 -- Function: set-difference list-1 list-2 &key key test test-not →
          result-list

 -- Function: nset-difference list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-LIST--a list.

Description:
............

‘set-difference’ returns a list of elements of LIST-1 that do not
appear in LIST-2.

‘nset-difference’ is the destructive version of ‘set-difference’.  It
may destroy LIST-1.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.  The first argument to the
:test or :test-not function is the part of an element of LIST-1 that is
returned by the :key function (if supplied); the second argument is the
part of an element of LIST-2 that is returned by the :key function (if
supplied).

If :key is supplied, its argument is a LIST-1 or LIST-2 element. The
:key function typically returns part of the supplied element.  If :key
is not supplied, the LIST-1 or LIST-2 element is used.

An element of LIST-1 appears in the result if and only if it does not
match any element of LIST-2.

There is no guarantee that the order of elements in the result will
reflect the ordering of the arguments in any particular way.  The
result list may share cells with, or be ‘eq’ to, either of LIST-1 or
LIST-2, if appropriate.

Examples:
.........

 (setq lst1 (list "A" "b" "C" "d")
       lst2 (list "a" "B" "C" "d")) → ("a" "B" "C" "d")
 (set-difference lst1 lst2) → ("d" "C" "b" "A")
 (set-difference lst1 lst2 :test 'equal) → ("b" "A")
 (set-difference lst1 lst2 :test #'equalp) → NIL
 (nset-difference lst1 lst2 :test #'string=) → ("A" "b")
 (setq lst1 '(("a" . "b") ("c" . "d") ("e" . "f")))
→ (("a" . "b") ("c" . "d") ("e" . "f"))
 (setq lst2 '(("c" . "a") ("e" . "b") ("d" . "a")))
→ (("c" . "a") ("e" . "b") ("d" . "a"))
 (nset-difference lst1 lst2 :test #'string= :key #'cdr)
→ (("c" . "d") ("e" . "f"))
 lst1 → (("a" . "b") ("c" . "d") ("e" . "f"))
 lst2 → (("c" . "a") ("e" . "b") ("d" . "a"))

;; Remove all flavor names that contain "c" or "w".
 (set-difference '("strawberry" "chocolate" "banana"
                  "lemon" "pistachio" "rhubarb")
          '(#\c #\w)
          :test #'(lambda (s c) (find c s)))
→ ("banana" "rhubarb" "lemon")    ;One possible ordering.

Side Effects:
.............

‘nset-difference’ may destroy LIST-1.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: set-exclusive-or; nset-exclusive-or,  Next: subsetp,  Prev: set-difference; nset-difference,  Up: Conses

set-exclusive-or, nset-exclusive-or (Function)
==============================================

Syntax:
.......

 -- Function: set-exclusive-or list-1 list-2 &key key test test-not →
          result-list

 -- Function: nset-exclusive-or list-1 list-2 &key key test test-not →
          result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-LIST--a list.

Description:
............

‘set-exclusive-or’ returns a list of elements that appear in exactly
one of LIST-1 and LIST-2.

‘nset-exclusive-or’ is the destructive version of ‘set-exclusive-or’.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, the :test or :test-not function is used to
determine whether they satisfy the test.

If :key is supplied, it is used to extract the part to be tested from
the LIST-1 or LIST-2 element.  The first argument to the :test or
:test-not function is the part of an element of LIST-1 extracted by the
:key function (if supplied); the second argument  is the part of an
element of LIST-2 extracted by the :key function (if supplied).  If
:key is not supplied or ‘nil’, the LIST-1 or LIST-2 element is used.

The result contains precisely those elements of LIST-1 and LIST-2 that
appear in no matching pair.

The result list of ‘set-exclusive-or’ might share storage with one of
LIST-1 or LIST-2.

Examples:
.........

 (setq lst1 (list 1 "a" "b")
       lst2 (list 1 "A" "b")) → (1 "A" "b")
 (set-exclusive-or lst1 lst2) → ("b" "A" "b" "a")
 (set-exclusive-or lst1 lst2 :test #'equal) → ("A" "a")
 (set-exclusive-or lst1 lst2 :test 'equalp) → NIL
 (nset-exclusive-or lst1 lst2) → ("a" "b" "A" "b")
 (setq lst1 (list (("a" . "b") ("c" . "d") ("e" . "f"))))
→ (("a" . "b") ("c" . "d") ("e" . "f"))
 (setq lst2 (list (("c" . "a") ("e" . "b") ("d" . "a"))))
→ (("c" . "a") ("e" . "b") ("d" . "a"))
 (nset-exclusive-or lst1 lst2 :test #'string= :key #'cdr)
→ (("c" . "d") ("e" . "f") ("c" . "a") ("d" . "a"))
 lst1 → (("a" . "b") ("c" . "d") ("e" . "f"))
 lst2 → (("c" . "a") ("d" . "a"))

Side Effects:
.............

‘nset-exclusive-or’ is permitted to modify any part, car or cdr, of the
list structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nset-exclusive-or’ side effect is not required, it should
not be used in for-effect-only positions in portable code.


File: ansicl,  Node: subsetp,  Next: union; nunion,  Prev: set-exclusive-or; nset-exclusive-or,  Up: Conses

subsetp (Function)
==================

Syntax:
.......

 -- Function: subsetp list-1 list-2 &key key test test-not →
          generalized-boolean

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

‘subsetp’ returns true if every element of LIST-1 matches some element
of LIST-2, and false otherwise.

Whether a list element is the same as another list element is
determined by the functions specified by the keyword arguments.  The
first argument to the :test or :test-not function is typically part of
an element of LIST-1 extracted by the :key function; the second
argument is  typically part of an element of LIST-2 extracted by the
:key function.

The argument to the :key function is an element of either LIST-1 or
LIST-2; the return value is part of the element of the supplied list
element.  If :key is not supplied or ‘nil’, the LIST-1 or LIST-2
element itself is supplied to the :test or :test-not function.

Examples:
.........

 (setq cosmos '(1 "a" (1 2))) → (1 "a" (1 2))
 (subsetp '(1) cosmos) → true
 (subsetp '((1 2)) cosmos) → false
 (subsetp '((1 2)) cosmos :test 'equal) → true
 (subsetp '(1 "A") cosmos :test #'equalp) → true
 (subsetp '((1) (2)) '((1) (2))) → false
 (subsetp '((1) (2)) '((1) (2)) :key #'car) → true

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not parameter is deprecated.


File: ansicl,  Node: union; nunion,  Prev: subsetp,  Up: Conses

union, nunion (Function)
========================

Syntax:
.......

 -- Function: union list-1 list-2 &key key test test-not → result-list

 -- Function: nunion list-1 list-2 &key key test test-not → result-list

Arguments and Values:
.....................

LIST-1--a proper list.

LIST-2--a proper list.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-LIST--a list.

Description:
............

‘union’ and ‘nunion’ return a list that contains every element that
occurs in either LIST-1 or LIST-2.

For all possible ordered pairs consisting of one element from LIST-1
and one element from LIST-2, :test or  :test-not is used to determine
whether they satisfy the test.  The first argument to the :test or
:test-not function is the part of the element of LIST-1 extracted by the
:key function (if supplied); the second argument is the part of the
element of LIST-2 extracted by the :key function (if supplied).

The argument to the :key function is an element of LIST-1 or LIST-2;
the return value is part of the supplied element.  If :key is not
supplied or ‘nil’, the element of LIST-1 or LIST-2 itself is supplied
to the :test or :test-not function.

For every matching pair, one of the two elements of the pair will be in
the result.  Any element from either LIST-1 or LIST-2 that matches no
element of the other will appear in the result.

If there is a duplication between LIST-1 and LIST-2, only one of the
duplicate instances will be in the result.  If either LIST-1 or LIST-2
has duplicate entries within it, the redundant entries might or might
not appear in the result.

The order of elements in the result do not have to reflect the ordering
of LIST-1 or LIST-2 in any way.  The result list may be ‘eq’ to either
LIST-1 or LIST-2 if appropriate.

Examples:
.........

 (union '(a b c) '(f a d))
→ (A B C F D)
or→ (B C F A D)
or→ (D F A B C)
 (union '((x 5) (y 6)) '((z 2) (x 4)) :key #'car)
→ ((X 5) (Y 6) (Z 2))
or→ ((X 4) (Y 6) (Z 2))

 (setq lst1 (list 1 2 '(1 2) "a" "b")
       lst2 (list 2 3 '(2 3) "B" "C"))
→ (2 3 (2 3) "B" "C")
 (nunion lst1 lst2)
→ (1 (1 2) "a" "b" 2 3 (2 3) "B" "C")
or→ (1 2 (1 2) "a" "b" "C" "B" (2 3) 3)

Side Effects:
.............

‘nunion’ is permitted to modify any part, car or cdr, of the list
structure of LIST-1 or LIST-2.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if LIST-1
AND LIST-2 are not proper lists.

See Also:
.........

*note intersection::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology, *note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not parameter is deprecated.

Since the ‘nunion’ side effect is not required, it should not be used
in for-effect-only positions in portable code.


File: ansicl,  Node: Arrays,  Next: Strings,  Prev: Conses,  Up: Top

15 Arrays
*********

* Menu:

* Array Concepts::

Dictionary

* array::
* simple-array::
* vector (System Class)::
* simple-vector::
* bit-vector::
* simple-bit-vector::
* make-array::
* adjust-array::
* adjustable-array-p::
* aref::
* array-dimension::
* array-dimensions::
* array-element-type::
* array-has-fill-pointer-p::
* array-displacement::
* array-in-bounds-p::
* array-rank::
* array-row-major-index::
* array-total-size::
* arrayp::
* fill-pointer::
* row-major-aref::
* upgraded-array-element-type::
* array-dimension-limit::
* array-rank-limit::
* array-total-size-limit::
* simple-vector-p::
* svref::
* vector (Function)::
* vector-pop::
* vector-push; vector-push-extend::
* vectorp::
* bit; sbit::
* bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+::
* bit-vector-p::
* simple-bit-vector-p::


File: ansicl,  Node: Array Concepts,  Next: array,  Up: Arrays

15.1 Array Concepts
===================

* Menu:

* Array Elements::
* Specialized Arrays::


File: ansicl,  Node: Array Elements,  Next: Specialized Arrays,  Up: Array Concepts

15.1.1 Array Elements
---------------------

An array contains a set of objects called elements that can be
referenced individually according to a rectilinear coordinate system.

15.1.1.1 Array Indices
......................

An array element is referred to by a (possibly empty) series of indices.
The length of the series must equal the rank of the array.  Each index
must be a non-negative fixnum less than the corresponding array
dimension.  Array indexing is zero-origin.

15.1.1.2 Array Dimensions
.........................

An axis of an array is called a "dimension".

Each dimension is a non-negative fixnum; if any dimension of an array
is zero, the array has no elements.  It is permissible for a dimension
to be zero, in which case the array has no elements, and any attempt to
access an element is an error.  However, other properties of the array,
such as the dimensions themselves, may be used.

15.1.1.2.1 Implementation Limits on Individual Array Dimensions
...............................................................

An implementation may impose a limit on dimensions of an array, but
there is a minimum requirement on that limit.  See the variable *note
array-dimension-limit::.

15.1.1.3 Array Rank
...................

An array can have any number of dimensions (including zero).  The
number of dimensions is called the "rank".

If the rank of an array is zero then the array is said to have no
dimensions, and the product of the dimensions (see ‘array-total-size’)
is then 1; a zero-rank array therefore has a single element.

15.1.1.3.1 Vectors
..................

An array of rank one (i.e., a one-dimensional array) is called a "vector".

15.1.1.3.1.1 Fill Pointers
..........................

A "fill pointer" is a non-negative integer no larger than the total
number of elements in a vector.  Not all vectors have fill pointers.
See the functions *note make-array:: and ‘adjust-array’.

An element of a vector is said to be "active" if it has an index that
is greater than or equal to zero, but less than the fill pointer (if
any).  For an array that has no fill pointer, all elements are
considered active.

Only vectors may have fill pointers; multidimensional arrays may not.
A multidimensional array that is displaced to a vector that has a fill
pointer can be created.

15.1.1.3.2 Multidimensional Arrays
..................................

15.1.1.3.2.1 Storage Layout for Multidimensional Arrays
.......................................................

Multidimensional arrays store their components in row-major order; that
is, internally a multidimensional array is stored as a one-dimensional
array, with the multidimensional index sets ordered lexicographically,
last index varying fastest.

15.1.1.3.2.2 Implementation Limits on Array Rank
................................................

An implementation may impose a limit on the rank of an array, but there
is a minimum requirement on that limit.  See the variable *note
array-rank-limit::.


File: ansicl,  Node: Specialized Arrays,  Prev: Array Elements,  Up: Array Concepts

15.1.2 Specialized Arrays
-------------------------

An array can be a general array, meaning each element may be any object,
or it may be a specialized array, meaning that each element must be of
a restricted type.

The phrasing "an array specialized to type «type»" is sometimes used to
emphasize the element type of an array.  This phrasing is tolerated
even when the «type» is ‘t’, even though an array specialized to type t
is a general array, not a specialized array.

The next figure lists some defined names that are applicable to array
creation, access, and information operations.

adjust-array            array-has-fill-pointer-p   make-array
adjustable-array-p      array-in-bounds-p          svref
aref                    array-rank                 upgraded-array-element-type
array-dimension         array-rank-limit           upgraded-complex-part-type
array-dimension-limit   array-row-major-index      vector
array-dimensions        array-total-size           vector-pop
array-displacement      array-total-size-limit     vector-push
array-element-type      fill-pointer               vector-push-extend

Figure 15.1: General Purpose Array-Related Defined Names

15.1.2.1 Array Upgrading
........................

The "upgraded array element type" of a type T₁ is a type T₂ that is a
supertype of T₁ and that is used instead of T₁ whenever T₁ is used as
an array element type for object creation or type discrimination.

During creation of an array, the element type that was requested is
called the "expressed array element type".  The upgraded array element
type of the expressed array element type becomes the "actual array
element type" of the array that is created.

Type upgrading implies a movement upwards in the type hierarchy lattice.
A type is always a subtype of its upgraded array element type.  Also,
if a type T_x is a subtype of another type T_y, then the upgraded array
element type of T_x must be a subtype of the upgraded array element
type of T_y.  Two disjoint types can be upgraded to the same type.

The upgraded array element type T₂ of a type T₁ is a function only of
T₁ itself; that is, it is independent of any other property of the array
for which T₂ will be used, such as rank, adjustability, fill pointers,
or displacement.  The function ‘upgraded-array-element-type’ can be
used by conforming programs to predict how the implementation will
upgrade a given type.

15.1.2.2 Required Kinds of Specialized Arrays
.............................................

Vectors whose elements are restricted to type ‘character’ or a subtype
of ‘character’ are called "strings".  Strings are of type ‘string’.
The next figure lists some defined names related to strings.

Strings are specialized arrays and might logically have been included
in this chapter.  However, for purposes of readability most information
about strings does not appear in this chapter; see instead *note
Chapter 16 (Strings): Strings.

char                 string-equal          string-upcase
make-string          string-greaterp       string‘/=’
nstring-capitalize   string-left-trim      string‘<’
nstring-downcase     string-lessp          string‘<=’
nstring-upcase       string-not-equal      string‘=’
schar                string-not-greaterp   string‘>’
string               string-not-lessp      string‘>=’
string-capitalize    string-right-trim     
string-downcase      string-trim           

Figure 15.2: Operators that Manipulate Strings

Vectors whose elements are restricted to type ‘bit’ are called "bit
vectors".  Bit vectors are of type ‘bit-vector’.  The next figure lists
some defined names for operations on bit arrays.

bit         bit-ior    bit-orc2
bit-and     bit-nand   bit-xor
bit-andc1   bit-nor    sbit
bit-andc2   bit-not    
bit-eqv     bit-orc1   

Figure 15.3: Operators that Manipulate Bit Arrays


File: ansicl,  Node: array,  Next: simple-array,  Prev: Array Concepts,  Up: Arrays

array (System Class)
====================

Class Precedence List:
......................

‘array’, ‘t’

Description:
............

An array contains objects arranged according to a Cartesian coordinate
system.  An array provides mappings from a set of fixnums
{i₀,i₁,...,i_{r-1}} to corresponding elements of the array, where 0 ≤
i_j < d_j, r is the rank of the array, and d_j is the size of dimension
j of the array.

When an array is created, the program requesting its creation may
declare that all elements are of a particular type, called the
expressed array element type.  The implementation is permitted to
upgrade this type in order to produce the actual array element type,
which is the element type for the array is actually specialized.  See
the function *note upgraded-array-element-type::.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION--a valid array dimension.

ELEMENT-TYPE--a type specifier.

RANK--a non-negative fixnum.

Compound Type Specifier Description:
....................................

This denotes the set of arrays whose element type,  rank,  and
dimensions match any given ELEMENT-TYPE, RANK, and DIMENSIONS.
Specifically:

If ELEMENT-TYPE is the symbol *, arrays are not excluded on the basis
of their element type.  Otherwise, only those ARRAYS are included whose
actual array element type is the result of upgrading ELEMENT-TYPE; see
*note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If the DIMENSION-SPEC is a RANK, the set includes only those ARRAYS
having that rank.  If the DIMENSION-SPEC is a list of DIMENSIONS, the
set includes only those ARRAYS having a rank given by the length of the
DIMENSIONS, and having the indicated DIMENSIONS; in this case, *
matches any value for the corresponding dimension.  If the
DIMENSION-SPEC is the symbol *, the set is not restricted on the basis
of rank or dimension.

See Also:
.........

*note *print-array*::, *note aref::, *note make-array::, *note vector
(System Class)::, *note Section 2.4.8.12 (Sharpsign A): SharpsignA,
*note Section 22.1.3.8 (Printing Other Arrays): PrintingOtherArrays.

Notes:
......

Note that the type ‘(array t)’ is a proper subtype of the type ‘(array
*)’.  The reason is that the type ‘(array t)’ is the set of arrays that
can hold any object (the elements are of type ‘t’,  which includes all
objects).  On the other hand, the type ‘(array *)’ is the set of all
arrays whatsoever, including for example arrays that can hold only
characters.  The type ‘(array character)’ is not a subtype of the type
‘(array t)’; the two sets are disjoint because the type ‘(array
character)’ is not the set of all arrays that can hold characters, but
rather the set of arrays that are specialized to hold precisely
characters and no other objects.


File: ansicl,  Node: simple-array,  Next: vector (System Class),  Prev: array,  Up: Arrays

simple-array (Type)
===================

Supertypes:
...........

‘simple-array’, ‘array’, ‘t’

Description:
............

The type of an array that is not displaced to another array, has no
fill pointer, and is not expressly adjustable is a subtype of type
‘simple-array’.  The concept of a simple array exists to allow the
implementation to use a specialized representation and to allow the
user to declare that certain values will always be simple arrays.

The types ‘simple-vector’, ‘simple-string’, and ‘simple-bit-vector’ are
disjoint subtypes of type ‘simple-array’, for they respectively mean
‘(simple-array t (*))’, the union of all ‘(simple-array c (*))’ for any
c being a subtype of type ‘character’, and ‘(simple-array bit (*))’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-array [{element-type | *} [dimension-spec]])

DIMENSION-SPEC::=
     rank | * | ({dimension | *}*)

Compound Type Specifier Arguments:
..................................

DIMENSION--a valid array dimension.

ELEMENT-TYPE--a type specifier.

RANK--a non-negative fixnum.

Compound Type Specifier Description:
....................................

This compound type specifier is treated exactly as the corresponding
compound type specifier for type ‘array’ would be treated, except that
the set is further constrained to include only simple arrays.

Notes:
......

It is implementation-dependent whether displaced arrays, vectors with
fill pointers, or arrays that are actually adjustable are simple arrays.

‘(simple-array *)’ refers to all simple arrays regardless of element
type, ‘(simple-array TYPE-SPECIFIER)’ refers only to those simple arrays
that can result from giving TYPE-SPECIFIER as the :element-type
argument to ‘make-array’.


File: ansicl,  Node: vector (System Class),  Next: simple-vector,  Prev: simple-array,  Up: Arrays

vector (System Class)
=====================

Class Precedence List:
......................

‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

Any one-dimensional array is a vector.

The type ‘vector’ is a subtype of type ‘array’; for all types ‘x’,
‘(vector x)’ is the same as ‘(array x (*))’.

The type ‘(vector t)’, the type ‘string’, and the type ‘bit-vector’ are
disjoint subtypes of type ‘vector’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(vector [{element-type | *} [{size | *}]])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum.

ELEMENT-TYPE--a type specifier.

Compound Type Specifier Description:
....................................

This denotes the set of specialized vectors whose element type and
DIMENSION match the specified values.  Specifically:

If ELEMENT-TYPE is the symbol *, vectors are not excluded on the basis
of their element type.  Otherwise, only those VECTORS are included
whose actual array element type is the result of upgrading ELEMENT-TYPE;
see *note Section 15.1.2.1 (Array Upgrading): ArrayUpgrading.

If a SIZE is specified, the set includes only those VECTORS whose only
dimension is SIZE.  If the symbol * is specified instead of a SIZE, the
set is not restricted on the basis of dimension.

See Also:
.........

*note Section 15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays, *note Section 2.4.8.3 (Sharpsign
Left-Parenthesis): SharpsignLeftParen, *note Section 22.1.3.7 (Printing
Other Vectors): PrintingOtherVectors, *note Section 2.4.8.12 (Sharpsign
A): SharpsignA.

Notes:
......

The type ‘(vector E S)’ is equivalent to the type ‘(array E (S))’.

The type ‘(vector bit)’ has the name ‘bit-vector’.

The union of all types ‘(vector C)’, where C is any subtype of
‘character’, has the name ‘string’.

‘(vector *)’ refers to all vectors regardless of element type, ‘(vector
TYPE-SPECIFIER)’ refers only to those vectors that can result from
giving TYPE-SPECIFIER as the :element-type argument to ‘make-array’.


File: ansicl,  Node: simple-vector,  Next: bit-vector,  Prev: vector (System Class),  Up: Arrays

simple-vector (Type)
====================

Supertypes:
...........

‘simple-vector’, ‘vector’, ‘simple-array’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type of a vector that is not displaced to another array, has no
fill pointer, is not expressly adjustable and is able to hold elements
of any type is a subtype of type ‘simple-vector’.

The type ‘simple-vector’ is a subtype of type ‘vector’, and is a
subtype of type ‘(vector t)’.

Compound Type Specifier Kind:
.............................

Specializing.

Compound Type Specifier Syntax:
...............................

(simple-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This is the same as ‘(simple-array t (SIZE))’.


File: ansicl,  Node: bit-vector,  Next: simple-bit-vector,  Prev: simple-vector,  Up: Arrays

bit-vector (System Class)
=========================

Class Precedence List:
......................

‘bit-vector’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

A bit vector is a vector the element type of which is bit.

The type ‘bit-vector’ is a subtype of type ‘vector’, for ‘bit-vector’
means ‘(vector bit)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ‘(array bit (SIZE))’; that is,
the set of bit vectors of size SIZE.

See Also:
.........

*note Section 2.4.8.4 (Sharpsign Asterisk): SharpsignStar, *note
Section 22.1.3.6 (Printing Bit Vectors): PrintingBitVectors, *note
Section 15.1.2.2 (Required Kinds of Specialized Arrays):
RequiredSpecializedArrays.


File: ansicl,  Node: simple-bit-vector,  Next: make-array,  Prev: bit-vector,  Up: Arrays

simple-bit-vector (Type)
========================

Supertypes:
...........

‘simple-bit-vector’, ‘bit-vector’, ‘vector’, ‘simple-array’, ‘array’,
‘sequence’, ‘t’

Description:
............

The type of a bit vector that is not displaced to another array, has no
fill pointer, and is not expressly adjustable is a subtype of type
‘simple-bit-vector’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-bit-vector [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.  The default is the
symbol *.

Compound Type Specifier Description:
....................................

This denotes the same type as the type ‘(simple-array bit (SIZE))’;
that is, the set of simple bit vectors of size SIZE.


File: ansicl,  Node: make-array,  Next: adjust-array,  Prev: simple-bit-vector,  Up: Arrays

make-array (Function)
=====================

Syntax:
.......

 -- Function: make-array dimensions &key element-type initial-element
          initial-contents adjustable fill-pointer displaced-to
          displaced-index-offset → new-array

Arguments and Values:
.....................

DIMENSIONS--a designator for a list of valid array dimensions.

ELEMENT-TYPE--a type specifier.  The default is ‘t’.

INITIAL-ELEMENT--an object.

INITIAL-CONTENTS--an object.

ADJUSTABLE--a generalized boolean.  The default is ‘nil’.

FILL-POINTER--a valid fill pointer for the array to be created, or
‘t’ or ‘nil’.  The default is ‘nil’.

DISPLACED-TO--an array or ‘nil’.  The default is ‘nil’.  This option
must not be supplied if either INITIAL-ELEMENT or INITIAL-CONTENTS is
supplied.

DISPLACED-INDEX-OFFSET--a valid array row-major index for DISPLACED-TO.
The default is ‘0’.  This option must not be supplied unless a non-nil
DISPLACED-TO is supplied.

NEW-ARRAY--an array.

Description:
............

Creates and returns an array constructed of the most specialized type
that can accommodate elements of type given by ELEMENT-TYPE.  If
DIMENSIONS is ‘nil’ then a zero-dimensional array is created.

DIMENSIONS represents the dimensionality of the new array.

ELEMENT-TYPE indicates the type of the elements intended to be stored
in the NEW-ARRAY.  The NEW-ARRAY can actually store any objects of the
type which results from upgrading ELEMENT-TYPE; see *note Section
15.1.2.1 (Array Upgrading): ArrayUpgrading.

If INITIAL-ELEMENT is supplied, it is used to initialize each element
of NEW-ARRAY.  If INITIAL-ELEMENT is supplied, it must be of the type
given by ELEMENT-TYPE.  INITIAL-ELEMENT cannot be supplied if either
the :initial-contents option is supplied or DISPLACED-TO is non-nil.
If INITIAL-ELEMENT is not supplied, the consequences of later reading
an uninitialized element of NEW-ARRAY are undefined unless either
INITIAL-CONTENTS is supplied or DISPLACED-TO is non-nil.

INITIAL-CONTENTS is used to initialize the contents of array.  For
example:

 (make-array '(4 2 3) :initial-contents
             '(((a b c) (1 2 3))
              ((d e f) (3 1 2))
              ((g h i) (2 3 1))
              ((j k l) (0 0 0))))

INITIAL-CONTENTS is composed of a nested structure of sequences.  The
numbers of levels in the structure must equal the rank of array.  Each
leaf of the nested structure must be of the type given by ELEMENT-TYPE.
If array is zero-dimensional, then INITIAL-CONTENTS specifies the single
element.  Otherwise, INITIAL-CONTENTS must be a sequence whose length
is equal to the first dimension; each element must be a nested
structure for an array whose dimensions are the remaining dimensions,
and so on.  INITIAL-CONTENTS cannot be supplied if either
INITIAL-ELEMENT is supplied or DISPLACED-TO is non-nil.  If
INITIAL-CONTENTS is not supplied, the consequences of later reading an
uninitialized element of NEW-ARRAY are undefined unless either
INITIAL-ELEMENT is supplied or DISPLACED-TO is non-nil.

If ADJUSTABLE is non-nil, the array is expressly adjustable (and so
actually adjustable); otherwise, the array is not expressly adjustable
(and it is implementation-dependent whether the array is actually
adjustable).

If FILL-POINTER is non-nil, the array must be one-dimensional; that is,
the array must be a vector.  If FILL-POINTER is ‘t’, the length of the
vector is used to initialize the fill pointer.  If FILL-POINTER is an
integer, it becomes the initial fill pointer for the vector.

If DISPLACED-TO is non-nil, ‘make-array’ will create a displaced array
and DISPLACED-TO is the target of that displaced array.  In that case,
the consequences are undefined if the actual array element type of
DISPLACED-TO is not type equivalent to the actual array element type of
the array being created.  If DISPLACED-TO is ‘nil’, the array is not a
displaced array.

The DISPLACED-INDEX-OFFSET is made to be the index offset of the array.
When an array A is given as the :displaced-to argument to ‘make-array’
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  It is
required that the total size of A be no smaller than the sum of the
total size of B plus the offset ‘n’ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A.  The mapping treats both arrays as if they
were one-dimensional by taking the elements in row-major order, and
then maps an access to element ‘k’ of array B to an access to element
‘k’+‘n’ of array A.

If ‘make-array’ is called with ADJUSTABLE, FILL-POINTER, and
DISPLACED-TO each ‘nil’, then the result is a simple array.  If
‘make-array’ is called with one or more of ADJUSTABLE, FILL-POINTER, or
DISPLACED-TO being true, whether the resulting array is a simple array
is implementation-dependent.

When an array A is given as the :displaced-to argument to ‘make-array’
when creating array B, then array B is said to be displaced to array A.
The total number of elements in an array, called the total size of the
array, is calculated as the product of all the dimensions.  The
consequences are unspecified if the total size of A is smaller than the
sum of the total size of B plus the offset ‘n’ supplied by the
DISPLACED-INDEX-OFFSET.  The effect of displacing is that array B does
not have any elements of its own, but instead maps accesses to itself
into accesses to array A.  The mapping treats both arrays as if they
were one-dimensional by taking the elements in row-major order, and
then maps an access to element ‘k’ of array B to an access to element
‘k’+‘n’ of array A.

Examples:
.........


 (make-array 5) ;; Creates a one-dimensional array of five elements.
 (make-array '(3 4) :element-type '(mod 16)) ;; Creates a
                ;;two-dimensional array, 3 by 4, with four-bit elements.
 (make-array 5 :element-type 'single-float) ;; Creates an array of single-floats.

 (make-array nil :initial-element nil) → #0ANIL
 (make-array 4 :initial-element nil) → #(NIL NIL NIL NIL)
 (make-array '(2 4)
              :element-type '(unsigned-byte 2)
              :initial-contents '((0 1 2 3) (3 2 1 0)))
→ #2A((0 1 2 3) (3 2 1 0))
 (make-array 6
              :element-type 'character
              :initial-element #\a
              :fill-pointer 3) → "aaa"

The following is an example of making a displaced array.

 (setq a (make-array '(4 3)))
→ #<ARRAY 4x3 simple 32546632>
 (dotimes (i 4)
   (dotimes (j 3)
     (setf (aref a i j) (list i 'x j '= (* i j)))))
→ NIL
 (setq b (make-array 8 :displaced-to a
                       :displaced-index-offset 2))
→ #<ARRAY 8 indirect 32550757>
 (dotimes (i 8)
   (print (list i (aref b i))))
▷ (0 (0 X 2 = 0))
▷ (1 (1 X 0 = 0))
▷ (2 (1 X 1 = 1))
▷ (3 (1 X 2 = 2))
▷ (4 (2 X 0 = 0))
▷ (5 (2 X 1 = 2))
▷ (6 (2 X 2 = 4))
▷ (7 (3 X 0 = 0))
→ NIL

The last example depends on the fact that arrays are, in effect, stored
in row-major order.

 (setq a1 (make-array 50))
→ #<ARRAY 50 simple 32562043>
 (setq b1 (make-array 20 :displaced-to a1 :displaced-index-offset 10))
→ #<ARRAY 20 indirect 32563346>
 (length b1) → 20

 (setq a2 (make-array 50 :fill-pointer 10))
→ #<ARRAY 50 fill-pointer 10 46100216>
 (setq b2 (make-array 20 :displaced-to a2 :displaced-index-offset 10))
→ #<ARRAY 20 indirect 46104010>
 (length a2) → 10
 (length b2) → 20

 (setq a3 (make-array 50 :fill-pointer 10))
→ #<ARRAY 50 fill-pointer 10 46105663>
 (setq b3 (make-array 20 :displaced-to a3 :displaced-index-offset 10
                         :fill-pointer 5))
→ #<ARRAY 20 indirect, fill-pointer 5 46107432>
 (length a3) → 10
 (length b3) → 5

See Also:
.........

*note adjustable-array-p::, *note aref::, *note arrayp::, *note
array-element-type::, *note array-rank-limit::, *note
array-dimension-limit::, *note fill-pointer::, *note
upgraded-array-element-type::

Notes:
......

There is no specified way to create an array for which
‘adjustable-array-p’ definitely returns false.  There is no specified
way to create an array that is not a simple array.


File: ansicl,  Node: adjust-array,  Next: adjustable-array-p,  Prev: make-array,  Up: Arrays

adjust-array (Function)
=======================

Syntax:
.......

 -- Function: adjust-array array new-dimensions &key element-type
          initial-element initial-contents fill-pointer displaced-to
          displaced-index-offset → adjusted-array

Arguments and Values:
.....................

ARRAY--an array.

NEW-DIMENSIONS--a valid array dimension or a list of valid array
dimensions.

ELEMENT-TYPE--a type specifier.

INITIAL-ELEMENT--an object.  INITIAL-ELEMENT must not be supplied if
either INITIAL-CONTENTS or DISPLACED-TO is supplied.

INITIAL-CONTENTS--an object.  If array has rank greater than zero, then
INITIAL-CONTENTS is composed of nested sequences, the depth of which
must equal the rank of ARRAY.  Otherwise, array is zero-dimensional and
INITIAL-CONTENTS supplies the single element.  INITIAL-CONTENTS must
not be supplied if either INITIAL-ELEMENT or DISPLACED-TO is given.

FILL-POINTER--a valid fill pointer for the array to be created, or ‘t’,
or ‘nil’.  The default is ‘nil’.

DISPLACED-TO--an array or ‘nil’.  INITIAL-ELEMENTS and INITIAL-CONTENTS
must not be supplied if DISPLACED-TO is supplied.

DISPLACED-INDEX-OFFSET--an object of type ‘(fixnum 0 n)’ where n is
‘(array-total-size DISPLACED-TO)’.  DISPLACED-INDEX-OFFSET may be
supplied only if DISPLACED-TO is supplied.

ADJUSTED-ARRAY--an array.

Description:
............

‘adjust-array’ changes the dimensions or elements of ARRAY.  The result
is an array of the same type and rank as ARRAY, that is either the
modified ARRAY, or a newly created array to which ARRAY can be
displaced, and that has the given NEW-DIMENSIONS.

NEW-DIMENSIONS specify the size of each dimension of ARRAY.

ELEMENT-TYPE specifies the type of the elements of the resulting array.
If ELEMENT-TYPE is supplied, the consequences are unspecified if the
upgraded array element type of ELEMENT-TYPE is not the same as the
actual array element type of ARRAY.

If INITIAL-CONTENTS is supplied, it is treated as for ‘make-array’.  In
this case none of the original contents of ARRAY appears in the
resulting array.

If FILL-POINTER is an integer, it becomes the fill pointer for the
resulting array.  If FILL-POINTER is the symbol ‘t’, it indicates that
the size of the resulting array should be used as the fill pointer.  If
FILL-POINTER is ‘nil’, it indicates that the fill pointer should be
left as it is.

If DISPLACED-TO non-nil, a displaced array is created. The resulting
array shares its contents with the array given by DISPLACED-TO.  The
resulting array cannot contain more elements than the array it is
displaced to.  If DISPLACED-TO is not supplied or ‘nil’, the resulting
array is not a displaced array.  If array A is created displaced to
array B and subsequently array B is given to ‘adjust-array’, array A
will still be displaced to array B.  Although ARRAY might be a
displaced array, the resulting array is not a displaced array unless
DISPLACED-TO is supplied and not ‘nil’.  The interaction between
‘adjust-array’ and displaced arrays is as follows given three arrays,
‘A’, ‘B’, and ‘C’:

‘A’ is not displaced before or after the call
      (adjust-array A ...)

     The dimensions of ‘A’ are altered, and the contents rearranged as
     appropriate.  Additional elements of ‘A’ are taken from
     INITIAL-ELEMENT.  The use of INITIAL-CONTENTS causes all old
     contents to be discarded.

‘A’ is not displaced before, but is displaced to  ‘C’ after the call
      (adjust-array A ... :displaced-to C)

     None of the original contents of ‘A’ appears in ‘A’ afterwards;
     ‘A’ now contains the contents of ‘C’, without any rearrangement of
     ‘C’.

‘A’ is displaced to ‘B’  before the call, and is displaced to ‘C’ after  the call
      (adjust-array A ... :displaced-to B)
      (adjust-array A ... :displaced-to C)

     ‘B’ and ‘C’ might be the same. The contents of ‘B’ do not appear in
     ‘A’ afterward unless such contents also happen to be in ‘C’  If
     DISPLACED-INDEX-OFFSET is not supplied in the ‘adjust-array’ call,
     it defaults to zero; the old offset into ‘B’ is not retained.

‘A’ is displaced to ‘B’ before the call, but not displaced afterward.
      (adjust-array A ... :displaced-to B)
      (adjust-array A ... :displaced-to nil)

     ‘A’ gets a new "data region," and contents of ‘B’ are copied into
     it as appropriate to maintain the existing old contents;
     additional elements of ‘A’ are taken from INITIAL-ELEMENT if
     supplied.  However, the use of INITIAL-CONTENTS causes all old
     contents to be discarded.

If DISPLACED-INDEX-OFFSET is supplied, it specifies the offset of the
resulting array from the beginning of the array that it is displaced to.
If DISPLACED-INDEX-OFFSET is not supplied, the offset is 0.  The size
of the resulting array plus the offset value cannot exceed the size of
the array that it is displaced to.

If only NEW-DIMENSIONS and an INITIAL-ELEMENT argument are supplied,
those elements of ARRAY that are still in bounds appear in the
resulting array. The elements of the resulting array that are not in
the bounds of array are initialized to INITIAL-ELEMENT; if
INITIAL-ELEMENT is not provided, the consequences of later reading any
such new element of NEW-ARRAY before it has been initialized are
undefined.

If INITIAL-CONTENTS or DISPLACED-TO is supplied, then none of the
original contents of ARRAY appears in the new array.

The consequences are unspecified if ARRAY is adjusted to a size smaller
than its fill pointer without supplying the FILL-POINTER argument so
that its fill-pointer is properly adjusted in the process.

If ‘A’ is displaced to ‘B’, the consequences are unspecified if ‘B’ is
adjusted in such a way that it no longer has enough elements to satisfy
‘A’.

If ‘adjust-array’ is applied to an array that is actually adjustable,
the array returned is identical to ARRAY.  If the array returned by
‘adjust-array’ is distinct from ARRAY, then the argument ARRAY is
unchanged.

Note that if an array A is displaced to another array B, and B is
displaced to another array C, and B is altered by ‘adjust-array’, A
must now refer to the adjust contents of B.  This means that an
implementation cannot collapse the chain to make A refer to C directly
and forget that the chain of reference passes through B.  However,
caching techniques are permitted as long as they preserve the semantics
specified here.

Examples:
.........

 (adjustable-array-p
  (setq ada (adjust-array
              (make-array '(2 3)
                          :adjustable t
                          :initial-contents '((a b c) (1 2 3)))
              '(4 6)))) → T
 (array-dimensions ada) → (4 6)
 (aref ada 1 1) → 2
 (setq beta (make-array '(2 3) :adjustable t))
→ #2A((NIL NIL NIL) (NIL NIL NIL))
 (adjust-array beta '(4 6) :displaced-to ada)
→ #2A((A B C NIL NIL NIL)
       (1 2 3 NIL NIL NIL)
       (NIL NIL NIL NIL NIL NIL)
       (NIL NIL NIL NIL NIL NIL))
 (array-dimensions beta) → (4 6)
 (aref beta 1 1) → 2

Suppose that the 4-by-4 array in ‘m’ looks like this:

#2A(( alpha     beta      gamma     delta )
    ( epsilon   zeta      eta       theta )
    ( iota      kappa     lambda    mu    )
    ( nu        xi        omicron   pi    ))

Then the result of

 (adjust-array m '(3 5) :initial-element 'baz)

is a 3-by-5 array with contents

#2A(( alpha     beta      gamma     delta     baz )
    ( epsilon   zeta      eta       theta     baz )
    ( iota      kappa     lambda    mu        baz ))

Exceptional Situations:
.......................

An error of type ‘error’ is signaled if FILL-POINTER is supplied and
non-nil but ARRAY has no fill pointer.

See Also:
.........

*note adjustable-array-p::,    *note make-array::, *note
array-dimension-limit::, *note array-total-size-limit::, *note array::


File: ansicl,  Node: adjustable-array-p,  Next: aref,  Prev: adjust-array,  Up: Arrays

adjustable-array-p (Function)
=============================

Syntax:
.......

 -- Function: adjustable-array-p array → generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if and only if ‘adjust-array’ could return a value which
is identical to ARRAY when given that array as its first argument.

Examples:
.........

 (adjustable-array-p
   (make-array 5
               :element-type 'character
               :adjustable t
               :fill-pointer 3)) → true
 (adjustable-array-p (make-array 4)) → implementation-dependent

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note adjust-array::, *note make-array::


File: ansicl,  Node: aref,  Next: array-dimension,  Prev: adjustable-array-p,  Up: Arrays

aref (Accessor)
===============

Syntax:
.......

 -- Function: aref array &rest subscripts → element

(setf (aref array &rest subscripts) new-element)

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of valid array indices for the ARRAY.

ELEMENT, NEW-ELEMENT--an object.

Description:
............

Accesses the ARRAY element specified by the SUBSCRIPTS.  If no
SUBSCRIPTS are supplied and ARRAY is zero rank, ‘aref’ accesses the
sole element of ARRAY.

‘aref’ ignores fill pointers.  It is permissible to use ‘aref’ to
access any ARRAY element, whether active or not.

Examples:
.........

If the variable ‘foo’ names a 3-by-5 array, then the first index could
be 0, 1, or 2, and then second index could be 0, 1, 2, 3, or 4.  The
array elements can be referred to by using the function ‘aref’; for
example, ‘(aref foo 2 1)’ refers to element (2, 1) of the array.

 (aref (setq alpha (make-array 4)) 3) → implementation-dependent
 (setf (aref alpha 3) 'sirens) → SIRENS
 (aref alpha 3) → SIRENS
 (aref (setq beta (make-array '(2 4)
                    :element-type '(unsigned-byte 2)
                    :initial-contents '((0 1 2 3) (3 2 1 0))))
        1 2) → 1
 (setq gamma '(0 2))
 (apply #'aref beta gamma) → 2
 (setf (apply #'aref beta gamma) 3) → 3
 (apply #'aref beta gamma) → 3
 (aref beta 0 2) → 3

See Also:
.........

*note bit::, *note char::, *note elt::, *note row-major-aref::, *note
svref::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.


File: ansicl,  Node: array-dimension,  Next: array-dimensions,  Prev: aref,  Up: Arrays

array-dimension (Function)
==========================

Syntax:
.......

 -- Function: array-dimension array axis-number → dimension

Arguments and Values:
.....................

ARRAY--an array.

AXIS-NUMBER--an integer greater than or equal to zero and less than the
rank of the ARRAY.

DIMENSION--a non-negative integer.

Description:
............

‘array-dimension’ returns the AXIS-NUMBER dimension₁ of ARRAY.  (Any
fill pointer is ignored.)

Examples:
.........

 (array-dimension (make-array 4) 0) → 4
 (array-dimension (make-array '(2 3)) 1) → 3

Affected By:
............

None.

See Also:
.........

*note array-dimensions::, *note length::

Notes:
......

 (array-dimension array n) ≡ (nth n (array-dimensions array))


File: ansicl,  Node: array-dimensions,  Next: array-element-type,  Prev: array-dimension,  Up: Arrays

array-dimensions (Function)
===========================

Syntax:
.......

 -- Function: array-dimensions array → dimensions

Arguments and Values:
.....................

ARRAY--an array.

DIMENSIONS--a list of integers.

Description:
............

Returns a list of the dimensions of ARRAY.  (If ARRAY is a vector with
a fill pointer, that fill pointer is ignored.)

Examples:
.........

 (array-dimensions (make-array 4)) → (4)
 (array-dimensions (make-array '(2 3))) → (2 3)
 (array-dimensions (make-array 4 :fill-pointer 2)) → (4)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array-dimension::


File: ansicl,  Node: array-element-type,  Next: array-has-fill-pointer-p,  Prev: array-dimensions,  Up: Arrays

array-element-type (Function)
=============================

Syntax:
.......

 -- Function: array-element-type array → typespec

Arguments and Values:
.....................

ARRAY--an array.

TYPESPEC--a type specifier.

Description:
............

Returns a type specifier which represents the actual array element type
of the array, which is the set of objects that such an ARRAY can hold.
(Because of array upgrading, this type specifier can in some cases
denote a supertype of the expressed array element type of the ARRAY.)

Examples:
.........

 (array-element-type (make-array 4)) → T
 (array-element-type (make-array 12 :element-type '(unsigned-byte 8)))
→ implementation-dependent
 (array-element-type (make-array 12 :element-type '(unsigned-byte 5)))
→ implementation-dependent

 (array-element-type (make-array 5 :element-type '(mod 5)))

could be ‘(mod 5)’, ‘(mod 8)’, ‘fixnum’, ‘t’, or any other type of
which ‘(mod 5)’ is a subtype.

Affected By:
............

The implementation.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array::, *note make-array::, *note subtypep::, *note
upgraded-array-element-type::


File: ansicl,  Node: array-has-fill-pointer-p,  Next: array-displacement,  Prev: array-element-type,  Up: Arrays

array-has-fill-pointer-p (Function)
===================================

Syntax:
.......

 -- Function: array-has-fill-pointer-p array → generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if ARRAY has a fill pointer; otherwise returns false.

Examples:
.........

 (array-has-fill-pointer-p (make-array 4)) → implementation-dependent
 (array-has-fill-pointer-p (make-array '(2 3))) → false
 (array-has-fill-pointer-p
   (make-array 8
               :fill-pointer 2
               :initial-element 'filler)) → true

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note make-array::, *note fill-pointer::

Notes:
......

Since arrays of rank other than one cannot have a fill pointer,
‘array-has-fill-pointer-p’ always returns ‘nil’ when its argument is
such an array.


File: ansicl,  Node: array-displacement,  Next: array-in-bounds-p,  Prev: array-has-fill-pointer-p,  Up: Arrays

array-displacement (Function)
=============================

Syntax:
.......

 -- Function: array-displacement array → displaced-to,
          displaced-index-offset

Arguments and Values:
.....................

ARRAY--an array.

DISPLACED-TO--an ARRAY or ‘nil’.

DISPLACED-INDEX-OFFSET--a non-negative fixnum.

Description:
............

If the ARRAY is a displaced array, returns the values of the
:displaced-to and :displaced-index-offset options for the array (see
the functions *note make-array:: and ‘adjust-array’).  If the ARRAY is
not a displaced array, ‘nil’ and ‘0’ are returned.

If ‘array-displacement’ is called on an ARRAY for which a non-nil
object was provided as the :displaced-to argument to ‘make-array’ or
‘adjust-array’, it must return that object as its first value. It is
implementation-dependent whether ‘array-displacement’ returns a non-nil
primary value for any other ARRAY.

Examples:
.........

 (setq a1 (make-array 5)) → #<ARRAY 5 simple 46115576>
 (setq a2 (make-array 4 :displaced-to a1
                        :displaced-index-offset 1))
→ #<ARRAY 4 indirect 46117134>
 (array-displacement a2)
→ #<ARRAY 5 simple 46115576>, 1
 (setq a3 (make-array 2 :displaced-to a2
                        :displaced-index-offset 2))
→ #<ARRAY 2 indirect 46122527>
 (array-displacement a3)
→ #<ARRAY 4 indirect 46117134>, 2

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if ARRAY is not an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-in-bounds-p,  Next: array-rank,  Prev: array-displacement,  Up: Arrays

array-in-bounds-p (Function)
============================

Syntax:
.......

 -- Function: array-in-bounds-p array &rest subscripts →
          generalized-boolean

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of integers of length equal to the rank of the array.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if the SUBSCRIPTS are all in bounds for ARRAY; otherwise
returns false.  (If ARRAY is a vector with a fill pointer, that fill
pointer is ignored.)

Examples:
.........

 (setq a (make-array '(7 11) :element-type 'string-char))
 (array-in-bounds-p a 0  0) → true
 (array-in-bounds-p a 6 10) → true
 (array-in-bounds-p a 0 -1) → false
 (array-in-bounds-p a 0 11) → false
 (array-in-bounds-p a 7  0) → false

See Also:
.........

*note array-dimensions::

Notes:
......

 (array-in-bounds-p array subscripts)
 ≡ (and (not (some #'minusp (list subscripts)))
         (every #'< (list subscripts) (array-dimensions array)))


File: ansicl,  Node: array-rank,  Next: array-row-major-index,  Prev: array-in-bounds-p,  Up: Arrays

array-rank (Function)
=====================

Syntax:
.......

 -- Function: array-rank array → rank

Arguments and Values:
.....................

ARRAY--an array.

RANK--a non-negative integer.

Description:
............

Returns the number of dimensions of ARRAY.

Examples:
.........

 (array-rank (make-array '())) → 0
 (array-rank (make-array 4)) → 1
 (array-rank (make-array '(4))) → 1
 (array-rank (make-array '(2 3))) → 2

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note array-rank-limit::, *note make-array::


File: ansicl,  Node: array-row-major-index,  Next: array-total-size,  Prev: array-rank,  Up: Arrays

array-row-major-index (Function)
================================

Syntax:
.......

 -- Function: array-row-major-index array &rest subscripts → index

Arguments and Values:
.....................

ARRAY--an array.

SUBSCRIPTS--a list of valid array indices for the ARRAY.

INDEX--a valid array row-major index for the ARRAY.

Description:
............

Computes the position according to the row-major ordering of ARRAY for
the element that is specified by SUBSCRIPTS, and returns the offset of
the element in the computed position from the beginning of ARRAY.

For a one-dimensional ARRAY, the result of ‘array-row-major-index’
equals SUBSCRIPT.

‘array-row-major-index’ ignores fill pointers.

Examples:
.........

 (setq a (make-array '(4 7) :element-type '(unsigned-byte 8)))
 (array-row-major-index a 1 2) → 9
 (array-row-major-index
    (make-array '(2 3 4)
                :element-type '(unsigned-byte 8)
                :displaced-to a
                :displaced-index-offset 4)
    0 2 1) → 9

Notes:
......

A possible definition of ‘array-row-major-index’, with no
error-checking, is

 (defun array-row-major-index (a &rest subscripts)
   (apply #'+ (maplist #'(lambda (x y)
                            (* (car x) (apply #'* (cdr y))))
                       subscripts
                       (array-dimensions a))))


File: ansicl,  Node: array-total-size,  Next: arrayp,  Prev: array-row-major-index,  Up: Arrays

array-total-size (Function)
===========================

Syntax:
.......

 -- Function: array-total-size array → size

Arguments and Values:
.....................

ARRAY--an array.

SIZE--a non-negative integer.

Description:
............

Returns the array total size of the ARRAY.

Examples:
.........

 (array-total-size (make-array 4)) → 4
 (array-total-size (make-array 4 :fill-pointer 2)) → 4
 (array-total-size (make-array 0)) → 0
 (array-total-size (make-array '(4 2))) → 8
 (array-total-size (make-array '(4 0))) → 0
 (array-total-size (make-array '())) → 1

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its argument is not an
array.

See Also:
.........

*note make-array::, *note array-dimensions::

Notes:
......

If the ARRAY is a vector with a fill pointer, the fill pointer is
ignored when calculating the array total size.

Since the product of no arguments is one, the array total size of a
zero-dimensional array is one.

 (array-total-size x)
    ≡ (apply #'* (array-dimensions x))
    ≡ (reduce #'* (array-dimensions x))


File: ansicl,  Node: arrayp,  Next: fill-pointer,  Prev: array-total-size,  Up: Arrays

arrayp (Function)
=================

Syntax:
.......

 -- Function: arrayp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘array’; otherwise, returns false.

Examples:
.........

 (arrayp (make-array '(2 3 4) :adjustable t)) → true
 (arrayp (make-array 6)) → true
 (arrayp #*1011) → true
 (arrayp "hi") → true
 (arrayp 'hi) → false
 (arrayp 12) → false

See Also:
.........

*note typep::

Notes:
......

 (arrayp OBJECT) ≡ (typep OBJECT 'array)


File: ansicl,  Node: fill-pointer,  Next: row-major-aref,  Prev: arrayp,  Up: Arrays

fill-pointer (Accessor)
=======================

Syntax:
.......

 -- Function: fill-pointer vector → fill-pointer

(setf (fill-pointer vector) new-fill-pointer)

Arguments and Values:
.....................

VECTOR--a vector with a fill pointer.

FILL-POINTER, NEW-FILL-POINTER--a valid fill pointer for the VECTOR.

Description:
............

Accesses the fill pointer of VECTOR.

Examples:
.........

 (setq a (make-array 8 :fill-pointer 4)) → #(NIL NIL NIL NIL)
 (fill-pointer a) → 4
 (dotimes (i (length a)) (setf (aref a i) (* i i))) → NIL
 a → #(0 1 4 9)
 (setf (fill-pointer a) 3) → 3
 (fill-pointer a) → 3
 a → #(0 1 4)
 (setf (fill-pointer a) 8) → 8
 a → #(0 1 4 9 NIL NIL NIL NIL)

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if VECTOR is not a vector
with a fill pointer.

See Also:
.........

*note make-array::, *note length::

Notes:
......

There is no operator that will remove a vector's fill pointer.


File: ansicl,  Node: row-major-aref,  Next: upgraded-array-element-type,  Prev: fill-pointer,  Up: Arrays

row-major-aref (Accessor)
=========================

Syntax:
.......

 -- Function: row-major-aref array index → element

(setf (row-major-aref array index) new-element)

Arguments and Values:
.....................

ARRAY--an array.

INDEX--a valid array row-major index for the ARRAY.

ELEMENT, NEW-ELEMENT--an object.

Description:
............

Considers array as a vector by viewing its elements in row-major order,
and returns the element of that vector which is referred to by the
given INDEX.

‘row-major-aref’ is valid for use with ‘setf’.

See Also:
.........

*note aref::, *note array-row-major-index::

Notes:
......

 (row-major-aref array index) ≡
   (aref (make-array (array-total-size array)
                     :displaced-to array
                     :element-type (array-element-type array))
         index)

 (aref array i1 i2 ...) ≡
     (row-major-aref array (array-row-major-index array i1 i2))


File: ansicl,  Node: upgraded-array-element-type,  Next: array-dimension-limit,  Prev: row-major-aref,  Up: Arrays

upgraded-array-element-type (Function)
======================================

Syntax:
.......

 -- Function: upgraded-array-element-type typespec &optional
          environment → upgraded-typespec

Arguments and Values:
.....................

TYPESPEC--a type specifier.

ENVIRONMENT--an environment object.  The default is ‘nil’, denoting the
null lexical environment and the current global environment.

UPGRADED-TYPESPEC--a type specifier.

Description:
............

Returns the element type of the most specialized array representation
capable of holding items of the type denoted by TYPESPEC.

The TYPESPEC is a subtype of (and possibly type equivalent to) the
UPGRADED-TYPESPEC.

If TYPESPEC is ‘bit’, the result is type equivalent to ‘bit’.  If
TYPESPEC is ‘base-char’, the result is type equivalent to ‘base-char’.
If TYPESPEC is ‘character’, the result is type equivalent to
‘character’.

The purpose of ‘upgraded-array-element-type’ is to reveal how an
implementation does its upgrading.

The ENVIRONMENT is used to expand any derived type specifiers that are
mentioned in the TYPESPEC.

See Also:
.........

*note array-element-type::, *note make-array::

Notes:
......

Except for storage allocation consequences and dealing correctly with
the optional ENVIRONMENT argument, ‘upgraded-array-element-type’ could
be defined as:

 (defun upgraded-array-element-type (type &optional environment)
   (array-element-type (make-array 0 :element-type type)))


File: ansicl,  Node: array-dimension-limit,  Next: array-rank-limit,  Prev: upgraded-array-element-type,  Up: Arrays

array-dimension-limit (Constant Variable)
=========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘1024’.

Description:
............

The upper exclusive bound on each individual dimension of an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-rank-limit,  Next: array-total-size-limit,  Prev: array-dimension-limit,  Up: Arrays

array-rank-limit (Constant Variable)
====================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘8’.

Description:
............

The upper exclusive bound on the rank of an array.

See Also:
.........

*note make-array::


File: ansicl,  Node: array-total-size-limit,  Next: simple-vector-p,  Prev: array-rank-limit,  Up: Arrays

array-total-size-limit (Constant Variable)
==========================================

Constant Value:
...............

A positive fixnum, the exact magnitude of which is
implementation-dependent, but which is not less than ‘1024’.

Description:
............

The upper exclusive bound on the array total size of an array.

The actual limit on the array total size imposed by the implementation
might vary according the element type of the array; in this case, the
value of ‘array-total-size-limit’ will be the smallest of these
possible limits.

See Also:
.........

*note make-array::, *note array-element-type::


File: ansicl,  Node: simple-vector-p,  Next: svref,  Prev: array-total-size-limit,  Up: Arrays

simple-vector-p (Function)
==========================

Syntax:
.......

 -- Function: simple-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-vector’; otherwise, returns
false..

Examples:
.........

 (simple-vector-p (make-array 6)) → true
 (simple-vector-p "aaaaaa") → false
 (simple-vector-p (make-array 6 :fill-pointer t)) → false

See Also:
.........

*note simple-vector::

Notes:
......

 (simple-vector-p OBJECT) ≡ (typep OBJECT 'simple-vector)


File: ansicl,  Node: svref,  Next: vector (Function),  Prev: simple-vector-p,  Up: Arrays

svref (Accessor)
================

Syntax:
.......

 -- Function: svref simple-vector index → element

(setf (svref simple-vector index) new-element)

Arguments and Values:
.....................

SIMPLE-VECTOR--a simple vector.

INDEX--a valid array index for the SIMPLE-VECTOR.

ELEMENT, NEW-ELEMENT--an object (whose type is a subtype of the array
element type of the SIMPLE-VECTOR).

Description:
............

Accesses the element of SIMPLE-VECTOR specified by INDEX.

Examples:
.........

 (simple-vector-p (setq v (vector 1 2 'sirens))) → true
 (svref v 0) → 1
 (svref v 2) → SIRENS
 (setf (svref v 1) 'newcomer) → NEWCOMER
 v → #(1 NEWCOMER SIRENS)

See Also:
.........

*note aref::, *note sbit::, *note schar::, *note vector (Function)::,
*note Section 3.2.1 (Compiler Terminology): Compiler Terminology.

Notes:
......

‘svref’ is identical to ‘aref’ except that it requires its first
argument to be a simple vector.

 (svref V I) ≡ (aref (the simple-vector V) I)


File: ansicl,  Node: vector (Function),  Next: vector-pop,  Prev: svref,  Up: Arrays

vector (Function)
=================

Syntax:
.......

 -- Function: vector &rest objects → vector

Arguments and Values:
.....................

OBJECT--an object.

VECTOR--a vector of type ‘(vector t ‘*’)’.

Description:
............

Creates a fresh simple general vector whose size corresponds to the
number of OBJECTS.

The vector is initialized to contain the OBJECTS.

Examples:
.........

 (arrayp (setq v (vector 1 2 'sirens))) → true
 (vectorp v) → true
 (simple-vector-p v) → true
 (length v) → 3

See Also:
.........

*note make-array::

Notes:
......

‘vector’ is analogous to ‘list’.

 (vector a₁ a₂ ... a_n)
  ≡ (make-array (list n) :element-type t
                          :initial-contents
                            (list a₁ a₂ ... a_n))


File: ansicl,  Node: vector-pop,  Next: vector-push; vector-push-extend,  Prev: vector (Function),  Up: Arrays

vector-pop (Function)
=====================

Syntax:
.......

 -- Function: vector-pop vector → element

Arguments and Values:
.....................

VECTOR--a vector with a fill pointer.

ELEMENT--an object.

Description:
............

Decreases the fill pointer of VECTOR by one, and retrieves the element
of VECTOR that is designated by the new fill pointer.

Examples:
.........

 (vector-push (setq fable (list 'fable))
              (setq fa (make-array 8
                                   :fill-pointer 2
                                   :initial-element 'sisyphus))) → 2
 (fill-pointer fa) → 3
 (eq (vector-pop fa) fable) → true
 (vector-pop fa) → SISYPHUS
 (fill-pointer fa) → 1

Side Effects:
.............

The fill pointer is decreased by one.

Affected By:
............

The value of the fill pointer.

Exceptional Situations:
.......................

An error of type ‘type-error’ is signaled if VECTOR does not have a
fill pointer.

If the fill pointer is zero, ‘vector-pop’ signals an error of type
‘error’.

See Also:
.........

*note vector-push::, *note vector-push-extend::, *note fill-pointer::


File: ansicl,  Node: vector-push; vector-push-extend,  Next: vectorp,  Prev: vector-pop,  Up: Arrays

vector-push, vector-push-extend (Function)
==========================================

Syntax:
.......

 -- Function: vector-push new-element vector → new-index-p

 -- Function: vector-push-extend new-element vector &optional extension
          → new-index

Arguments and Values:
.....................

NEW-ELEMENT--an object.

VECTOR--a vector with a fill pointer.

EXTENSION--a positive integer.  The default is implementation-dependent.

NEW-INDEX-P--a valid array index for VECTOR, or ‘nil’.

NEW-INDEX--a valid array index for VECTOR.

Description:
............

‘vector-push’ and ‘vector-push-extend’ store NEW-ELEMENT in VECTOR.
‘vector-push’ attempts to store NEW-ELEMENT in the element of VECTOR
designated by the fill pointer, and to increase the fill pointer by
one.  If the ‘(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))’,
neither VECTOR nor its fill pointer are affected.  Otherwise, the store
and increment take place and ‘vector-push’ returns the former value of
the fill pointer which is one less than the one it leaves in VECTOR.

‘vector-push-extend’ is just like ‘vector-push’ except that if the fill
pointer gets too large, VECTOR is extended using ‘adjust-array’ so that
it can contain more elements.  EXTENSION is the minimum number of
elements to be added to VECTOR if it must be extended.

‘vector-push’ and ‘vector-push-extend’ return the index of NEW-ELEMENT
in VECTOR.  If ‘(>= (fill-pointer VECTOR) (array-dimension VECTOR 0))’,
‘vector-push’ returns ‘nil’.

Examples:
.........

 (vector-push (setq fable (list 'fable))
              (setq fa (make-array 8
                                   :fill-pointer 2
                                   :initial-element 'first-one))) → 2
 (fill-pointer fa) → 3
 (eq (aref fa 2) fable) → true
 (vector-push-extend #\X
                    (setq aa
                          (make-array 5
                                      :element-type 'character
                                      :adjustable t
                                      :fill-pointer 3))) → 3
 (fill-pointer aa) → 4
 (vector-push-extend #\Y aa 4) → 4
 (array-total-size aa) → at least 5
 (vector-push-extend #\Z aa 4) → 5
 (array-total-size aa) → 9 ;(or more)

Affected By:
............

The value of the fill pointer.

How VECTOR was created.

Exceptional Situations:
.......................

An error of type ‘error’ is signaled by ‘vector-push-extend’ if it
tries to extend VECTOR and VECTOR is not actually adjustable.

An error of type ‘error’ is signaled if VECTOR does not have a fill
pointer.

See Also:
.........

*note adjustable-array-p::, *note fill-pointer::, *note vector-pop::


File: ansicl,  Node: vectorp,  Next: bit; sbit,  Prev: vector-push; vector-push-extend,  Up: Arrays

vectorp (Function)
==================

Syntax:
.......

 -- Function: vectorp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘vector’; otherwise, returns false.

Examples:
.........

 (vectorp "aaaaaa") → true
 (vectorp (make-array 6 :fill-pointer t)) → true
 (vectorp (make-array '(2 3 4))) → false
 (vectorp #*11) → true
 (vectorp #b11) → false

Notes:
......

 (vectorp OBJECT) ≡ (typep OBJECT 'vector)


File: ansicl,  Node: bit; sbit,  Next: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Prev: vectorp,  Up: Arrays

bit, sbit (Accessor)
====================

Syntax:
.......

 -- Function: bit bit-array &rest subscripts → bit

 -- Function: sbit bit-array &rest subscripts → bit

Arguments and Values:
.....................

BIT-ARRAY--for ‘bit’,  a bit array; for ‘sbit’, a simple bit array.

SUBSCRIPTS--a list of valid array indices for the BIT-ARRAY.

BIT--a bit.

Description:
............

‘bit’ and ‘sbit’ access the BIT-ARRAY element specified by SUBSCRIPTS.

These functions ignore the fill pointer when accessing elements.

Examples:
.........

 (bit (setq ba (make-array 8
                            :element-type 'bit
                            :initial-element 1))
       3) → 1
 (setf (bit ba 3) 0) → 0
 (bit ba 3) → 0
 (sbit ba 5) → 1
 (setf (sbit ba 5) 1) → 1
 (sbit ba 5) → 1

See Also:
.........

*note aref::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology.

Notes:
......

‘bit’ and ‘sbit’ are like ‘aref’ except that they require ARRAYS to be
a bit array and a simple bit array, respectively.

‘bit’ and ‘sbit’, unlike ‘char’ and ‘schar’, allow the first argument
to be an array of any rank.


File: ansicl,  Node: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Next: bit-vector-p,  Prev: bit; sbit,  Up: Arrays

bit-and, bit-andc1, bit-andc2, bit-eqv, bit-ior, bit-nand, bit-nor, bit-not, bit-orc1, bit-orc2, bit-xor (Function)
===================================================================================================================

Syntax:
.......

 -- Function: bit-and bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-andc1 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-andc2 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-eqv bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-ior bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-nand bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-nor bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-orc1 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-orc2 bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-xor bit-array1 bit-array2 &optional opt-arg →
          resulting-bit-array

 -- Function: bit-not bit-array &optional opt-arg → resulting-bit-array

Arguments and Values:
.....................

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2--a bit array.

OPT-ARG--a bit array, or ‘t’, or ‘nil’.  The default is ‘nil’.

BIT-ARRAY, BIT-ARRAY1, BIT-ARRAY2, and OPT-ARG (if an array) must all
be of the same rank and dimensions.

RESULTING-BIT-ARRAY--a bit array.

Description:
............

These functions perform bit-wise logical operations on BIT-ARRAY1 and
BIT-ARRAY2 and return an array of matching rank and dimensions, such
that any given bit of the result is produced by operating on
corresponding bits from each of the arguments.

In the case of ‘bit-not’, an array of rank and dimensions matching
BIT-ARRAY is returned that contains a copy of BIT-ARRAY with all the
bits inverted.

If OPT-ARG is of type ‘(array bit)’ the contents of the result are
destructively placed into OPT-ARG.  If OPT-ARG is the symbol ‘t’,
BIT-ARRAY or BIT-ARRAY1 is replaced with the result; if OPT-ARG is
‘nil’ or omitted, a new array is created to contain the result.

The next figure indicates the logical operation performed by each of
the functions.

Function      Operation
------------------------------------------------------------- 
‘bit-nor’     complement of BIT-ARRAY1 or BIT-ARRAY2
‘bit-andc1’   and complement of BIT-ARRAY1 with BIT-ARRAY2
‘bit-andc2’   and BIT-ARRAY1 with complement of BIT-ARRAY2
‘bit-orc1’    or complement of BIT-ARRAY1 with BIT-ARRAY2
‘bit-orc2’    or BIT-ARRAY1 with complement of BIT-ARRAY2

Figure 15.4: Bit-wise Logical Operations on Bit Arrays

Examples:
.........

 (bit-and (setq ba #*11101010) #*01101011) → #*01101010
 (bit-and #*1100 #*1010) → #*1000
 (bit-andc1 #*1100 #*1010) → #*0010
 (setq rba (bit-andc2 ba #*00110011 t)) → #*11001000
 (eq rba ba) → true
 (bit-not (setq ba #*11101010)) → #*00010101
 (setq rba (bit-not ba
                     (setq tba (make-array 8
                                           :element-type 'bit))))
→ #*00010101
 (equal rba tba) → true
 (bit-xor #*1100 #*1010) → #*0110

See Also:
.........

*note lognot::, *note logand::


File: ansicl,  Node: bit-vector-p,  Next: simple-bit-vector-p,  Prev: bit-and; bit-andc1; bit-andc2; bit-eqv; bit-ior; bit-nand; bit-nor; bit+,  Up: Arrays

bit-vector-p (Function)
=======================

Syntax:
.......

 -- Function: bit-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘bit-vector’; otherwise, returns
false.

Examples:
.........

 (bit-vector-p (make-array 6
                           :element-type 'bit
                           :fill-pointer t)) → true
 (bit-vector-p #*) → true
 (bit-vector-p (make-array 6)) → false

See Also:
.........

*note typep::

Notes:
......

 (bit-vector-p OBJECT) ≡ (typep OBJECT 'bit-vector)


File: ansicl,  Node: simple-bit-vector-p,  Prev: bit-vector-p,  Up: Arrays

simple-bit-vector-p (Function)
==============================

Syntax:
.......

 -- Function: simple-bit-vector-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-bit-vector’; otherwise,
returns false.

Examples:
.........

 (simple-bit-vector-p (make-array 6)) → false
 (simple-bit-vector-p #*) → true

See Also:
.........

*note simple-vector-p::

Notes:
......

 (simple-bit-vector-p OBJECT) ≡ (typep OBJECT 'simple-bit-vector)


File: ansicl,  Node: Strings,  Next: Sequences,  Prev: Arrays,  Up: Top

16 Strings
**********

* Menu:

* String Concepts::

Dictionary

* string (System Class)::
* base-string::
* simple-string::
* simple-base-string::
* simple-string-p::
* char; schar::
* string (Function)::
* string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+::
* string-trim; string-left-trim; string-right-trim::
* string=; string/=; string<; string>; string<=; string>=; string-equal; +::
* stringp::
* make-string::


File: ansicl,  Node: String Concepts,  Next: string (System Class),  Up: Strings

16.1 String Concepts
====================

* Menu:

* Implications of Strings Being Arrays::
* Subtypes of STRING::


File: ansicl,  Node: Implications of Strings Being Arrays,  Next: Subtypes of STRING,  Up: String Concepts

16.1.1 Implications of Strings Being Arrays
-------------------------------------------

Since all strings are arrays, all rules which apply generally to arrays
also apply to strings.  See *note Section 15.1 (Array Concepts): Array
Concepts.

For example, strings can have fill pointers, and strings are also
subject to the rules of element type upgrading that apply to arrays.


File: ansicl,  Node: Subtypes of STRING,  Prev: Implications of Strings Being Arrays,  Up: String Concepts

16.1.2 Subtypes of STRING
-------------------------

All functions that operate on strings will operate on subtypes of
string as well.

However, the consequences are undefined if a character is inserted into
a string for which the element type of the string does not include that
character.


File: ansicl,  Node: string (System Class),  Next: base-string,  Prev: String Concepts,  Up: Strings

string (System Class)
=====================

Class Precedence List:
......................

‘string’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

A string is a specialized vector whose elements are of type ‘character’
or a suptype of type ‘character’.  When used as a type specifier for
object creation, ‘string’ means ‘(vector character)’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ‘(array c (SIZE))’ for all subtypes
c of ‘character’; that is, the set of strings of size SIZE.

See Also:
.........

*note Section 16.1 (String Concepts): String Concepts, *note Section
2.4.5 (Double-Quote): Double-Quote, *note Section 22.1.3.4 (Printing
Strings): PrintingStrings.


File: ansicl,  Node: base-string,  Next: simple-string,  Prev: string (System Class),  Up: Strings

base-string (Type)
==================

Supertypes:
...........

‘base-string’, ‘string’, ‘vector’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type ‘base-string’ is equivalent to ‘(vector base-char)’.  The base
string representation is the most efficient string representation that
can hold an arbitrary sequence of standard characters.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ‘(vector base-char SIZE)’; that is, the
set of base strings of size SIZE.


File: ansicl,  Node: simple-string,  Next: simple-base-string,  Prev: base-string,  Up: Strings

simple-string (Type)
====================

Supertypes:
...........

‘simple-string’, ‘string’, ‘vector’, ‘simple-array’, ‘array’,
‘sequence’, ‘t’

Description:
............

A simple string is a specialized one-dimensional simple array whose
elements are of type ‘character’ or a suptype of type ‘character’.
When used as a type specifier for object creation, ‘simple-string’
means ‘(simple-array character (size))’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This denotes the union of all types ‘(simple-array c (SIZE))’ for all
subtypes c of ‘character’; that is, the set of simple strings of size
SIZE.


File: ansicl,  Node: simple-base-string,  Next: simple-string-p,  Prev: simple-string,  Up: Strings

simple-base-string (Type)
=========================

Supertypes:
...........

‘simple-base-string’, ‘base-string’, ‘simple-string’, ‘string’,
‘vector’, ‘simple-array’, ‘array’, ‘sequence’, ‘t’

Description:
............

The type ‘simple-base-string’ is equivalent to ‘(simple-array base-char
(*))’.

Compound Type Specifier Kind:
.............................

Abbreviating.

Compound Type Specifier Syntax:
...............................

(simple-base-string [size])

Compound Type Specifier Arguments:
..................................

SIZE--a non-negative fixnum, or the symbol *.

Compound Type Specifier Description:
....................................

This is equivalent to the type ‘(simple-array base-char (SIZE))’; that
is, the set of simple base strings of size SIZE.


File: ansicl,  Node: simple-string-p,  Next: char; schar,  Prev: simple-base-string,  Up: Strings

simple-string-p (Function)
==========================

Syntax:
.......

 -- Function: simple-string-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘simple-string’; otherwise, returns
false.

Examples:
.........

 (simple-string-p "aaaaaa") → true
 (simple-string-p (make-array 6
                              :element-type 'character
                              :fill-pointer t)) → false

Notes:
......

 (simple-string-p OBJECT) ≡ (typep OBJECT 'simple-string)


File: ansicl,  Node: char; schar,  Next: string (Function),  Prev: simple-string-p,  Up: Strings

char, schar (Accessor)
======================

Syntax:
.......

 -- Function: char string index → character

 -- Function: schar string index → character

Arguments and Values:
.....................

STRING--for ‘char’,  a string; for ‘schar’, a simple string.

INDEX--a valid array index for the STRING.

CHARACTER, NEW-CHARACTER--a character.

Description:
............

‘char’ and ‘schar’ access the element of STRING specified by INDEX.

‘char’ ignores fill pointers when accessing elements.

Examples:
.........

 (setq my-simple-string (make-string 6 :initial-element #\A)) → "AAAAAA"
 (schar my-simple-string 4) → #\A
 (setf (schar my-simple-string 4) #\B) → #\B
 my-simple-string → "AAAABA"
 (setq my-filled-string
       (make-array 6 :element-type 'character
                     :fill-pointer 5
                     :initial-contents my-simple-string))
→ "AAAAB"
 (char my-filled-string 4) → #\B
 (char my-filled-string 5) → #\A
 (setf (char my-filled-string 3) #\C) → #\C
 (setf (char my-filled-string 5) #\D) → #\D
 (setf (fill-pointer my-filled-string) 6) → 6
 my-filled-string → "AAACBD"

See Also:
.........

*note aref::, *note elt::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

 (char s j) ≡ (aref (the string s) j)


File: ansicl,  Node: string (Function),  Next: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Prev: char; schar,  Up: Strings

string (Function)
=================

Syntax:
.......

 -- Function: string x → string

Arguments and Values:
.....................

X--a string, a symbol, or a character.

STRING--a string.

Description:
............

Returns a string described by X; specifically:

   * If X is a string, it is returned.

   * If X is a symbol, its name is returned.

   * If X is a character, then a string containing that one character
     is returned.

   * ‘string’ might perform additional, implementation-defined
     conversions.

Examples:
.........

 (string "already a string") → "already a string"
 (string 'elm) → "ELM"
 (string #\c) → "c"

Exceptional Situations:
.......................

In the case where a conversion is defined neither by this specification
nor by the implementation, an error of type ‘type-error’ is signaled.

See Also:
.........

*note coerce::, *note string (System Class):: (type).

Notes:
......

‘coerce’ can be used to convert a sequence of characters to a string.

‘prin1-to-string’, ‘princ-to-string’, ‘write-to-string’, or ‘format’
(with a first argument of ‘nil’) can be used to get a string
representation of a number or any other object.


File: ansicl,  Node: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Next: string-trim; string-left-trim; string-right-trim,  Prev: string (Function),  Up: Strings

string-upcase, string-downcase, string-capitalize, nstring-upcase, nstring-downcase, nstring-capitalize (Function)
==================================================================================================================

Syntax:
.......

 -- Function: string-upcase string &key start end → cased-string

 -- Function: string-downcase string &key start end → cased-string

 -- Function: string-capitalize string &key start end → cased-string

 -- Function: nstring-upcase string &key start end → string

 -- Function: nstring-downcase string &key start end → string

 -- Function: nstring-capitalize string &key start end → string

Arguments and Values:
.....................

STRING--a string designator.  For ‘nstring-upcase’, ‘nstring-downcase’,
and ‘nstring-capitalize’, the STRING designator must be a string.

START, END--bounding index designators of STRING.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

CASED-STRING--a string.

Description:
............

‘string-upcase’,  ‘string-downcase’,  ‘string-capitalize’,
‘nstring-upcase’, ‘nstring-downcase’, ‘nstring-capitalize’ change the
case of the subsequence of STRING bounded by START and END as follows:

string-upcase
     ‘string-upcase’ returns a string just like STRING with all
     lowercase characters replaced by the corresponding uppercase
     characters.  More precisely, each character of the result string
     is produced by applying the function ‘char-upcase’ to the
     corresponding character of STRING.

string-downcase
     ‘string-downcase’ is like ‘string-upcase’ except that all
     uppercase characters are replaced by the corresponding lowercase
     characters (using ‘char-downcase’).

string-capitalize
     ‘string-capitalize’ produces a copy of STRING such that, for every
     word in the copy, the first character of the "word," if it has
     case, is uppercase and any other characters with case in the word
     are lowercase.  For the purposes of ‘string-capitalize’, a "word"
     is defined to be a consecutive subsequence consisting of
     alphanumeric characters, delimited at each end either by a
     non-alphanumeric character or by an end of the string.

nstring-upcase, nstring-downcase, nstring-capitalize
     ‘nstring-upcase’, ‘nstring-downcase’, and ‘nstring-capitalize’ are
     identical to ‘string-upcase’, ‘string-downcase’, and
     ‘string-capitalize’ respectively except that they  modify STRING.

For ‘string-upcase’, ‘string-downcase’, and ‘string-capitalize’, STRING
is not modified.  However, if no characters in STRING require
conversion, the result may be either STRING or a copy of it, at the
implementation's discretion.

Examples:
.........

 (string-upcase "abcde") → "ABCDE"
 (string-upcase "Dr. Livingston, I presume?")
→ "DR. LIVINGSTON, I PRESUME?"
 (string-upcase "Dr. Livingston, I presume?" :start 6 :end 10)
→ "Dr. LiVINGston, I presume?"
 (string-downcase "Dr. Livingston, I presume?")
→ "dr. livingston, i presume?"

 (string-capitalize "elm 13c arthur;fig don't") → "Elm 13c Arthur;Fig Don'T"
 (string-capitalize " hello ") → " Hello "
 (string-capitalize "occlUDeD cASEmenTs FOreSTAll iNADVertent DEFenestraTION")
→  "Occluded Casements Forestall Inadvertent Defenestration"
 (string-capitalize 'kludgy-hash-search) → "Kludgy-Hash-Search"
 (string-capitalize "DON'T!") → "Don'T!"    ;not "Don't!"
 (string-capitalize "pipe 13a, foo16c") → "Pipe 13a, Foo16c"

 (setq str (copy-seq "0123ABCD890a")) → "0123ABCD890a"
 (nstring-downcase str :start 5 :end 7) → "0123AbcD890a"
 str → "0123AbcD890a"

Side Effects:
.............

‘nstring-upcase’, ‘nstring-downcase’, and ‘nstring-capitalize’ modify
STRING as appropriate rather than constructing a new string.

See Also:
.........

*note char-upcase::, *note char-downcase::

Notes:
......

The result is always of the same length as STRING.


File: ansicl,  Node: string-trim; string-left-trim; string-right-trim,  Next: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Prev: string-upcase; string-downcase; string-capitalize; nstring-upcase; nstr+,  Up: Strings

string-trim, string-left-trim, string-right-trim (Function)
===========================================================

Syntax:
.......

 -- Function: string-trim character-bag string → trimmed-string

 -- Function: string-left-trim character-bag string → trimmed-string

 -- Function: string-right-trim character-bag string → trimmed-string

Arguments and Values:
.....................

CHARACTER-BAG--a sequence containing characters.

STRING--a string designator.

TRIMMED-STRING--a string.

Description:
............

‘string-trim’ returns a substring of STRING, with all characters in
CHARACTER-BAG stripped off the beginning and end.  ‘string-left-trim’
is similar but strips characters off only the beginning;
‘string-right-trim’ strips off only the end.

If no characters need to be trimmed from the STRING, then either STRING
itself or a copy of it may be returned, at the discretion of the
implementation.

All of these functions observe the fill pointer.

Examples:
.........

 (string-trim "abc" "abcaakaaakabcaaa") → "kaaak"
 (string-trim '(#\Space #\Tab #\Newline) " garbanzo beans
        ") → "garbanzo beans"
 (string-trim " (*)" " ( *three (silly) words* ) ")
→ "three (silly) words"

 (string-left-trim "abc" "labcabcabc") → "labcabcabc"
 (string-left-trim " (*)" " ( *three (silly) words* ) ")
→ "three (silly) words* ) "

 (string-right-trim " (*)" " ( *three (silly) words* ) ")
→ " ( *three (silly) words"

Affected By:
............

The implementation.


File: ansicl,  Node: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Next: stringp,  Prev: string-trim; string-left-trim; string-right-trim,  Up: Strings

string=, string/=, string<, string>, string<=, string>=, string-equal, string-not-equal, string-lessp, string-greaterp, string-not-greaterp, string-not-lessp (Function)
========================================================================================================================================================================

Syntax:
.......

 -- Function: string= string1 string2 &key start1 end1 start2 end2 →
          generalized-boolean

 -- Function: string/= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string< string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string> string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string<= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string>= string1 string2 &key start1 end1 start2 end2 →
          mismatch-index

 -- Function: string-equal string1 string2 &key start1 end1 start2 end2
          → generalized-boolean

 -- Function: string-not-equal string1 string2 &key start1 end1 start2
          end2 → mismatch-index

 -- Function: string-lessp string1 string2 &key start1 end1 start2 end2
          → mismatch-index

 -- Function: string-greaterp string1 string2 &key start1 end1 start2
          end2 → mismatch-index

 -- Function: string-not-greaterp string1 string2 &key start1 end1
          start2 end2 → mismatch-index

 -- Function: string-not-lessp string1 string2 &key start1 end1 start2
          end2 → mismatch-index

Arguments and Values:
.....................

STRING1--a string designator.

STRING2--a string designator.

START1, END1--bounding index designators of STRING1.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

START2, END2--bounding index designators of STRING2.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

GENERALIZED-BOOLEAN--a generalized boolean.

MISMATCH-INDEX--a bounding index of STRING1, or ‘nil’.

Description:
............

These functions perform lexicographic comparisons on STRING1 and
STRING2.  ‘string=’ and ‘string-equal’ are called equality functions;
the others are called inequality functions.  The comparison operations
these functions perform are restricted to the subsequence of STRING1
bounded by start1 and END1 and to the subsequence of STRING2 bounded by
start2 and END2.

A string a is equal to a string b if it contains the same number of
characters, and the corresponding characters are the same under ‘char=’
or ‘char-equal’, as appropriate.

A string a is less than a string b if in the first position in which
they differ the character of a is less than the corresponding character
of b according to ‘char<’ or ‘char-lessp’ as appropriate, or if string
a is a proper prefix of string b (of shorter length and matching in all
the characters of a).

The equality functions return a GENERALIZED BOOLEAN that is true if the
strings are equal, or false otherwise.

The inequality functions return a MISMATCH-INDEX that is true if the
strings are not equal, or false otherwise.  When the MISMATCH-INDEX is
true, it is an integer representing the first character position at
which the two substrings differ, as an offset from the beginning of
STRING1.

The comparison has one of the following results:

‘string=’
     ‘string=’ is true if the supplied substrings are of the same
     length and contain the same characters in corresponding positions;
     otherwise it is false.

‘string/=’
     ‘string/=’ is true if the supplied substrings are different;
     otherwise it is false.

‘string-equal’
     ‘string-equal’ is just like ‘string=’ except that differences in
     case are ignored; two characters are considered to be the same if
     ‘char-equal’ is true of them.

‘string<’
     ‘string<’ is true if substring1 is less than substring2; otherwise
     it is false.

‘string>’
     ‘string>’ is true if substring1 is greater than substring2;
     otherwise it is false.

‘string-lessp’, ‘string-greaterp’
     ‘string-lessp’ and ‘string-greaterp’ are exactly like ‘string<’
     and ‘string>’, respectively, except that distinctions between
     uppercase and lowercase letters are ignored.  It is as if
     ‘char-lessp’ were used instead of ‘char<’ for comparing characters.

‘string<=’
     ‘string<=’ is true if substring1 is less than or equal to
     substring2; otherwise it is false.

‘string>=’
     ‘string>=’ is true if substring1 is greater than or equal to
     substring2; otherwise it is false.

‘string-not-greaterp’, ‘string-not-lessp’
     ‘string-not-greaterp’ and ‘string-not-lessp’ are exactly like
     ‘string<=’ and ‘string>=’, respectively, except that distinctions
     between uppercase and lowercase letters are ignored.  It is as if
     ‘char-lessp’ were used instead of ‘char<’ for comparing characters.

Examples:
.........

 (string= "foo" "foo") → true
 (string= "foo" "Foo") → false
 (string= "foo" "bar") → false
 (string= "together" "frog" :start1 1 :end1 3 :start2 2) → true
 (string-equal "foo" "Foo") → true
 (string= "abcd" "01234abcd9012" :start2 5 :end2 9) → true
 (string< "aaaa" "aaab") → 3
 (string>= "aaaaa" "aaaa") → 4
 (string-not-greaterp "Abcde" "abcdE") → 5
 (string-lessp "012AAAA789" "01aaab6" :start1 3 :end1 7
                                      :start2 2 :end2 6) → 6
 (string-not-equal "AAAA" "aaaA") → false

See Also:
.........

*note char=::

Notes:
......

‘equal’ calls ‘string=’ if applied to two strings.


File: ansicl,  Node: stringp,  Next: make-string,  Prev: string=; string/=; string<; string>; string<=; string>=; string-equal; +,  Up: Strings

stringp (Function)
==================

Syntax:
.......

 -- Function: stringp object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘string’; otherwise, returns false.

Examples:
.........

 (stringp "aaaaaa") → true
 (stringp #\a) → false

See Also:
.........

*note typep::, *note string (System Class):: (type)

Notes:
......

 (stringp OBJECT) ≡ (typep OBJECT 'string)


File: ansicl,  Node: make-string,  Prev: stringp,  Up: Strings

make-string (Function)
======================

Syntax:
.......

 -- Function: make-string size &key initial-element element-type →
          string

Arguments and Values:
.....................

SIZE--a valid array dimension.

INITIAL-ELEMENT--a character.  The default is implementation-dependent.

ELEMENT-TYPE--a type specifier.  The default is ‘character’.

STRING--a simple string.

Description:
............

‘make-string’ returns a simple string of length SIZE whose elements
have been initialized to INITIAL-ELEMENT.

The ELEMENT-TYPE names the type of the elements of the string; a string
is constructed of the most specialized type that can accommodate
elements of the given type.

Examples:
.........

 (make-string 10 :initial-element #\5) → "5555555555"
 (length (make-string 10)) → 10

Affected By:
............

The implementation.


File: ansicl,  Node: Sequences,  Next: Hash Tables,  Prev: Strings,  Up: Top

17 Sequences
************

* Menu:

* Sequence Concepts::
* Rules about Test Functions::

Dictionary

* sequence::
* copy-seq::
* elt::
* fill::
* make-sequence::
* subseq::
* map::
* map-into::
* reduce::
* count; count-if; count-if-not::
* length::
* reverse; nreverse::
* sort; stable-sort::
* find; find-if; find-if-not::
* position; position-if; position-if-not::
* search::
* mismatch::
* replace::
* substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+::
* concatenate::
* merge::
* remove; remove-if; remove-if-not; delete; delete-if; delete-if-not::
* remove-duplicates; delete-duplicates::


File: ansicl,  Node: Sequence Concepts,  Next: Rules about Test Functions,  Up: Sequences

17.1 Sequence Concepts
======================

A "sequence" is an ordered collection of elements, implemented as
either a vector or a list.

Sequences can be created by the function ‘make-sequence’, as well as
other functions that create objects of types that are subtypes of
‘sequence’ (e.g., ‘list’, ‘make-list’, ‘mapcar’, and ‘vector’).

A "sequence function" is a function defined by this specification or
added as an extension by the implementation that operates on one or
more sequences.  Whenever a sequence function must construct and return
a new vector, it always returns a simple vector.  Similarly, any
strings constructed will be simple strings.

concatenate         length               remove
copy-seq            map                  remove-duplicates
count               map-into             remove-if
count-if            merge                remove-if-not
count-if-not        mismatch             replace
delete              notany               reverse
delete-duplicates   notevery             search
delete-if           nreverse             some
delete-if-not       nsubstitute          sort
elt                 nsubstitute-if       stable-sort
every               nsubstitute-if-not   subseq
fill                position             substitute
find                position-if          substitute-if
find-if             position-if-not      substitute-if-not
find-if-not         reduce               

Figure 17.1: Standardized Sequence Functions

* Menu:

* General Restrictions on Parameters that must be Sequences::


File: ansicl,  Node: General Restrictions on Parameters that must be Sequences,  Up: Sequence Concepts

17.1.1 General Restrictions on Parameters that must be Sequences
----------------------------------------------------------------

In general, lists (including association lists and property lists) that
are treated as sequences must be proper lists.


File: ansicl,  Node: Rules about Test Functions,  Next: sequence,  Prev: Sequence Concepts,  Up: Sequences

17.2 Rules about Test Functions
===============================

* Menu:

* Satisfying a Two-Argument Test::
* Satisfying a One-Argument Test::


File: ansicl,  Node: Satisfying a Two-Argument Test,  Next: Satisfying a One-Argument Test,  Up: Rules about Test Functions

17.2.1 Satisfying a Two-Argument Test
-------------------------------------

When an object O is being considered iteratively against each element
E_i of a sequence S by an operator F listed in the next figure, it is
sometimes useful to control the way in which the presence of O is
tested in S is tested by F.  This control is offered on the basis of a
function designated with either a :test or :test-not argument.

adjoin            nset-exclusive-or   search
assoc             nsublis             set-difference
count             nsubst              set-exclusive-or
delete            nsubstitute         sublis
find              nunion              subsetp
intersection      position            subst
member            pushnew             substitute
mismatch          rassoc              tree-equal
nintersection     remove              union
nset-difference   remove-duplicates   

Figure 17.2: Operators that have Two-Argument Tests to be Satisfied

The object O might not be compared directly to E_i.  If a :key argument
is provided, it is a designator for a function of one argument to be
called with each E_i as an argument, and yielding an object Z_i to be
used for comparison.  (If there is no :key argument, Z_i is E_i.)

The function designated by the :key argument is never called on O
itself.  However, if the function operates on multiple sequences (e.g.,
as happens in ‘set-difference’), O will be the result of calling the
:key function on an element of the other sequence.

A :test argument, if supplied to F, is a designator for a  function of
two arguments, O and Z_i.  An E_i is said (or, sometimes, an O and an
E_i are said) to "satisfy the test" if this :test function returns a
generalized boolean representing true.

A :test-not argument, if supplied to F, is designator for a function of
two arguments, O and Z_i.  An E_i is said (or, sometimes, an O and an
E_i are said) to "satisfy the test" if this :test-not function returns
a generalized boolean representing false.

If neither a :test nor a :test-not argument is supplied, it is as if a
:test argument of ‘#'eql’ was supplied.

The consequences are unspecified if both a :test and a :test-not
argument are supplied in the same call to F.

17.2.1.1 Examples of Satisfying a Two-Argument Test
...................................................

 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equal)
→ (foo bar "BAR" "foo" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'equalp)
→ (foo bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string-equal)
→ (bar "BAR" "bar")
 (remove "FOO" '(foo bar "FOO" "BAR" "foo" "bar") :test #'string=)
→ (BAR "BAR" "foo" "bar")

 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'eql)
→ (1)
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test-not #'=)
→ (1 1.0 #C(1.0 0.0))
 (remove 1 '(1 1.0 #C(1.0 0.0) 2 2.0 #C(2.0 0.0)) :test (complement #'=))
→ (1 1.0 #C(1.0 0.0))

 (count 1 '((one 1) (uno 1) (two 2) (dos 2)) :key #'cadr) → 2

 (count 2.0 '(1 2 3) :test #'eql :key #'float) → 1

 (count "FOO" (list (make-pathname :name "FOO" :type "X")
                    (make-pathname :name "FOO" :type "Y"))
        :key #'pathname-name
        :test #'equal)
→ 2


File: ansicl,  Node: Satisfying a One-Argument Test,  Prev: Satisfying a Two-Argument Test,  Up: Rules about Test Functions

17.2.2 Satisfying a One-Argument Test
-------------------------------------

When using one of the functions in the next figure, the elements E of a
sequence S are filtered not on the basis of the presence or absence of
an object O under a two argument predicate, as with the functions
described in *note Section 17.2.1 (Satisfying a Two-Argument Test):
Satisfying a Two-Argument Test, but rather on the basis of a one
argument predicate.

assoc-if        member-if            rassoc-if
assoc-if-not    member-if-not        rassoc-if-not
count-if        nsubst-if            remove-if
count-if-not    nsubst-if-not        remove-if-not
delete-if       nsubstitute-if       subst-if
delete-if-not   nsubstitute-if-not   subst-if-not
find-if         position-if          substitute-if
find-if-not     position-if-not      substitute-if-not

Figure 17.3: Operators that have One-Argument Tests to be Satisfied

The element E_i might not be considered directly.  If a :key argument
is provided, it is a designator for a function of one argument to be
called with each E_i as an argument, and yielding an object Z_i to be
used for comparison.  (If there is no :key argument, Z_i is E_i.)

Functions defined in this specification and having a name that ends in
"‘-if’" accept a first argument that is a designator for a function of
one argument, Z_i.  An E_i is said to "satisfy the test" if this :test
function returns a generalized boolean representing true.

Functions defined in this specification and having a name that ends in
"‘-if-not’" accept a first argument that is a designator for a function
of one argument, Z_i.  An E_i is said to "satisfy the test" if this
:test function returns a generalized boolean representing false.

17.2.2.1 Examples of Satisfying a One-Argument Test
...................................................

 (count-if #'zerop '(1 #C(0.0 0.0) 0 0.0d0 0.0s0 3)) → 4

 (remove-if-not #'symbolp '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
→ (A B C D E F)
 (remove-if (complement #'symbolp) '(0 1 2 3 4 5 6 7 8 9 A B C D E F))
→ (A B C D E F)

 (count-if #'zerop '("foo" "" "bar" "" "" "baz" "quux") :key #'length)
→ 3


File: ansicl,  Node: sequence,  Next: copy-seq,  Prev: Rules about Test Functions,  Up: Sequences

sequence (System Class)
=======================

Class Precedence List:
......................

‘sequence’, ‘t’

Description:
............

Sequences are ordered collections of objects, called the elements of
the sequence.

The types ‘vector’ and the type ‘list’ are disjoint subtypes of type
‘sequence’, but are not necessarily an exhaustive partition of sequence.

When viewing a vector as a sequence, only the active elements of that
vector are considered elements of the sequence; that is, sequence
operations respect the fill pointer when given sequences represented as
vectors.


File: ansicl,  Node: copy-seq,  Next: elt,  Prev: sequence,  Up: Sequences

copy-seq (Function)
===================

Syntax:
.......

 -- Function: copy-seq sequence → copied-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

COPIED-SEQUENCE--a proper sequence.

Description:
............

Creates a copy of SEQUENCE.  The elements of the new sequence are the
same as the corresponding elements of the given SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE
is a list, the result is a fresh list.

Examples:
.........

 (setq str "a string") → "a string"
 (equalp str (copy-seq str)) → true
 (eql str (copy-seq str)) → false

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note copy-list::

Notes:
......

From a functional standpoint,
 (copy-seq x) ≡ (subseq x 0)

However, the programmer intent is typically very different in these two
cases.


File: ansicl,  Node: elt,  Next: fill,  Prev: copy-seq,  Up: Sequences

elt (Accessor)
==============

Syntax:
.......

 -- Function: elt sequence index → object

(setf (elt sequence index) new-object)

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

INDEX--a valid sequence index for SEQUENCE.

OBJECT--an object.

NEW-OBJECT--an object.

Description:
............

Accesses the element of SEQUENCE specified by INDEX.

Examples:
.........

 (setq str (copy-seq "0123456789")) → "0123456789"
 (elt str 6) → #\6
 (setf (elt str 0) #\#) → #\#
 str → "#123456789"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if INDEX is not a valid sequence index for SEQUENCE.

See Also:
.........

*note aref::, *note nth::, *note Section 3.2.1 (Compiler Terminology):
Compiler Terminology.

Notes:
......

‘aref’ may be used to access vector elements that are beyond the
vector's fill pointer.


File: ansicl,  Node: fill,  Next: make-sequence,  Prev: elt,  Up: Sequences

fill (Function)
===============

Syntax:
.......

 -- Function: fill sequence item &key start end → sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

ITEM--a sequence.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

Description:
............

Replaces the elements of SEQUENCE bounded by START and END with ITEM.

Examples:
.........

 (fill (list 0 1 2 3 4 5) '(444)) → ((444) (444) (444) (444) (444) (444))
 (fill (copy-seq "01234") #\e :start 3) → "012ee"
 (setq x (vector 'a 'b 'c 'd 'e)) → #(A B C D E)
 (fill x 'z :start 1 :end 3) → #(A Z Z D E)
 x → #(A Z Z D E)
 (fill x 'p) → #(P P P P P)
 x → #(P P P P P)

Side Effects:
.............

SEQUENCE is destructively modified.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should signal an error of type ‘type-error’
if START is not a non-negative integer.  Should signal an error of type
‘type-error’ if END is not a non-negative integer or ‘nil’.

See Also:
.........

*note replace::, *note nsubstitute::

Notes:
......

‘(fill SEQUENCE ITEM) ≡ (nsubstitute-if ITEM (constantly t) SEQUENCE)’


File: ansicl,  Node: make-sequence,  Next: subseq,  Prev: fill,  Up: Sequences

make-sequence (Function)
========================

Syntax:
.......

 -- Function: make-sequence result-type size &key initial-element →
          sequence

Arguments and Values:
.....................

RESULT-TYPE--a ‘sequence’ type specifier.

SIZE--a non-negative integer.

INITIAL-ELEMENT--an object.  The default is implementation-dependent.

SEQUENCE--a proper sequence.

Description:
............

Returns a sequence of the type RESULT-TYPE and of length SIZE, each of
the elements of which has been initialized to INITIAL-ELEMENT.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array
is ‘t’; otherwise, an error is signaled.

Examples:
.........

 (make-sequence 'list 0) → ()
 (make-sequence 'string 26 :initial-element #\.)
→ ".........................."
 (make-sequence '(vector double-float) 2
                :initial-element 1d0)
→ #(1.0d0 1.0d0)

 (make-sequence '(vector * 2) 3) should signal an error
 (make-sequence '(vector * 4) 3) should signal an error

Affected By:
............

The implementation.

Exceptional Situations:
.......................

The consequences are unspecified if INITIAL-ELEMENT is not an object
which can be stored in the resulting sequence.

An error of type ‘type-error’ must be signaled if the RESULT-TYPE is
neither a recognizable subtype of ‘list’, nor a recognizable subtype of
‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and SIZE is different from that number.

See Also:
.........

*note make-array::, *note make-list::

Notes:
......

 (make-sequence 'string 5) ≡ (make-string 5)


File: ansicl,  Node: subseq,  Next: map,  Prev: make-sequence,  Up: Sequences

subseq (Accessor)
=================

Syntax:
.......

 -- Function: subseq sequence start &optional end → subsequence

(setf (subseq sequence start &optional end) new-subsequence)

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

START, END--bounding index designators of SEQUENCE.  The default for
END is ‘nil’.

SUBSEQUENCE--a proper sequence.

NEW-SUBSEQUENCE--a proper sequence.

Description:
............

‘subseq’ creates a sequence that is a copy of the subsequence of
SEQUENCE BOUNDED by START and END.

START specifies an offset into the original SEQUENCE and marks the
beginning position of the subsequence.  END marks the position
following the last element of the subsequence.

‘subseq’ always allocates a new sequence for a result; it never shares
storage with an old sequence.  The result subsequence is always of the
same type as SEQUENCE.

If SEQUENCE is a vector, the result is a fresh simple array of rank one
that has the same actual array element type as SEQUENCE.  If SEQUENCE
is a list, the result is a fresh list.

‘setf’ may be used with ‘subseq’ to destructively replace elements of a
subsequence with elements taken from a sequence of new values.  If the
subsequence and the new sequence are not of equal length, the shorter
length determines the number of elements that are replaced.  The
remaining elements at the end of the longer sequence are not modified
in the operation.

Examples:
.........

 (setq str "012345") → "012345"
 (subseq str 2) → "2345"
 (subseq str 3 5) → "34"
 (setf (subseq str 4) "abc") → "abc"
 str → "0123ab"
 (setf (subseq str 0 2) "A") → "A"
 str → "A123ab"

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.  Should be prepared to signal an error of
type ‘type-error’ if NEW-SUBSEQUENCE is not a proper sequence.

See Also:
.........

*note replace::


File: ansicl,  Node: map,  Next: map-into,  Prev: subseq,  Up: Sequences

map (Function)
==============

Syntax:
.......

 -- Function: map result-type function &rest sequences+ → result

Arguments and Values:
.....................

RESULT-TYPE--a ‘sequence’ type specifier, or ‘nil’.

FUNCTION--a function designator.  FUNCTION must take as many arguments
as there are SEQUENCES.

SEQUENCE--a proper sequence.

RESULT--if RESULT-TYPE is a type specifier other than ‘nil’, then a
sequence of the type it denotes; otherwise (if the RESULT-TYPE is
‘nil’), ‘nil’.

Description:
............

Applies FUNCTION to successive sets of arguments in which one argument
is obtained from each sequence.  The FUNCTION is called first on all
the elements with index ‘0’, then on all those with index ‘1’, and so
on.  The RESULT-TYPE specifies the type of the resulting sequence.

‘map’ returns ‘nil’ if RESULT-TYPE is ‘nil’.  Otherwise, ‘map’ returns
a sequence such that element ‘j’ is the result of applying FUNCTION to
element ‘j’ of each of the SEQUENCES.  The result sequence is as long
as the shortest of the SEQUENCES.  The consequences are undefined if
the result of applying FUNCTION to the successive elements of the
SEQUENCES cannot be contained in a sequence of the type given by
RESULT-TYPE.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array
is ‘t’; otherwise, an error is signaled.

Examples:
.........

 (map 'string #'(lambda (x y)
                  (char "01234567890ABCDEF" (mod (+ x y) 16)))
       '(1 2 3 4)
       '(10 9 8 7)) → "AAAA"
 (setq seq '("lower" "UPPER" "" "123")) → ("lower" "UPPER" "" "123")
 (map nil #'nstring-upcase seq) → NIL
 seq → ("LOWER" "UPPER" "" "123")
 (map 'list #'- '(1 2 3 4)) → (-1 -2 -3 -4)
 (map 'string
      #'(lambda (x) (if (oddp x) #\1 #\0))
      '(1 2 3 4)) → "1010"

 (map '(vector * 4) #'cons "abc" "de") should signal an error

Exceptional Situations:
.......................

An error of type ‘type-error’ must be signaled if the RESULT-TYPE is
not a recognizable subtype of ‘list’, not a recognizable subtype of
‘vector’, and not ‘nil’.

Should be prepared to signal an error of type ‘type-error’ if any
SEQUENCE is not a proper sequence.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the minimum length of the SEQUENCES
is different from that number.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: map-into,  Next: reduce,  Prev: map,  Up: Sequences

map-into (Function)
===================

Syntax:
.......

 -- Function: map-into result-sequence function &rest sequences →
          result-sequence

Arguments and Values:
.....................

RESULT-SEQUENCE--a proper sequence.

FUNCTION--a designator for a function of as many arguments as there are
SEQUENCES.

SEQUENCE--a proper sequence.

Description:
............

Destructively modifies RESULT-SEQUENCE to contain the results of
applying FUNCTION to each element in the argument SEQUENCES in turn.

RESULT-SEQUENCE and each element of SEQUENCES can each be either a list
or a vector.  If RESULT-SEQUENCE and each element of SEQUENCES are not
all the same length, the iteration terminates when the shortest sequence
(of any of the SEQUENCES or the RESULT-SEQUENCE) is exhausted.  If
RESULT-SEQUENCE is a vector with a fill pointer, the fill pointer is
ignored when deciding how many iterations to perform, and afterwards
the fill pointer is set to the number of times FUNCTION was applied.
If RESULT-SEQUENCE is longer than the shortest element of SEQUENCES,
extra elements at the end of RESULT-SEQUENCE are left unchanged.  If
RESULT-SEQUENCE is ‘nil’, ‘map-into’ immediately returns ‘nil’, since
‘nil’ is a sequence of length zero.

If FUNCTION has side effects, it can count on being called first on all
of the elements with index 0, then on all of those numbered 1, and so
on.

Examples:
.........

 (setq a (list 1 2 3 4) b (list 10 10 10 10)) → (10 10 10 10)
 (map-into a #'+ a b) → (11 12 13 14)
 a → (11 12 13 14)
 b → (10 10 10 10)
 (setq k '(one two three)) → (ONE TWO THREE)
 (map-into a #'cons k a) → ((ONE . 11) (TWO . 12) (THREE . 13) 14)
 (map-into a #'gensym) → (#:G9090 #:G9091 #:G9092 #:G9093)
 a → (#:G9090 #:G9091 #:G9092 #:G9093)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if
RESULT-SEQUENCE is not a proper sequence.  Should be prepared to signal
an error of type ‘type-error’ if SEQUENCE is not a proper sequence.

Notes:
......

‘map-into’ differs from ‘map’ in that it modifies an existing sequence
rather than creating a new one.  In addition, ‘map-into’ can be called
with only two arguments, while ‘map’ requires at least three arguments.

‘map-into’ could be defined by:

 (defun map-into (result-sequence function &rest sequences)
   (loop for index below (apply #'min
                                (length result-sequence)
                                (mapcar #'length sequences))
         do (setf (elt result-sequence index)
                  (apply function
                         (mapcar #'(lambda (seq) (elt seq index))
                                 sequences))))
   result-sequence)


File: ansicl,  Node: reduce,  Next: count; count-if; count-if-not,  Prev: map-into,  Up: Sequences

reduce (Function)
=================

Syntax:
.......

 -- Function: reduce function sequence &key key from-end start end
          initial-value → result

Arguments and Values:
.....................

FUNCTION--a designator for a function that might be called with either
zero or two arguments.

SEQUENCE--a proper sequence.

KEY--a designator for a function of one argument, or ‘nil’.

FROM-END--a generalized boolean.  The default is false.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

INITIAL-VALUE--an object.

RESULT--an object.

Description:
............

‘reduce’ uses a binary operation, FUNCTION, to combine the elements of
SEQUENCE bounded by START and END.

The FUNCTION must accept as arguments two elements of SEQUENCE or the
results from combining those elements.  The FUNCTION must also be able
to accept no arguments.

If KEY is supplied, it is used is used to extract the values to reduce.
The KEY function is applied exactly once to each element of SEQUENCE in
the order implied by the reduction order but not to the value of
INITIAL-VALUE, if supplied.  The KEY function typically returns part of
the element of SEQUENCE.  If KEY is not supplied or is ‘nil’, the
SEQUENCE element itself is used.

The reduction is left-associative, unless FROM-END is true in which
case it is right-associative.

If INITIAL-VALUE is supplied, it is logically placed before the
subsequence (or after it if FROM-END is true) and included in the
reduction operation.

In the normal case, the result of ‘reduce’ is the combined result of
FUNCTION's being applied to successive pairs of elements of SEQUENCE.
If the subsequence contains exactly one element and no INITIAL-VALUE is
given, then that element is returned and FUNCTION is not called.  If
the subsequence is empty and an INITIAL-VALUE is given, then the
INITIAL-VALUE is returned and FUNCTION is not called.  If the
subsequence is empty and no INITIAL-VALUE is given, then the FUNCTION
is called with zero arguments, and ‘reduce’ returns whatever FUNCTION
does.  This is the only case where the FUNCTION is called with other
than two arguments.

Examples:
.........

 (reduce #'* '(1 2 3 4 5)) → 120
 (reduce #'append '((1) (2)) :initial-value '(i n i t)) → (I N I T 1 2)
 (reduce #'append '((1) (2)) :from-end t
                             :initial-value '(i n i t)) → (1 2 I N I T)
 (reduce #'- '(1 2 3 4)) ≡ (- (- (- 1 2) 3) 4) → -8
 (reduce #'- '(1 2 3 4) :from-end t)    ;Alternating sum.
≡ (- 1 (- 2 (- 3 4))) → -2
 (reduce #'+ '()) → 0
 (reduce #'+ '(3)) → 3
 (reduce #'+ '(foo)) → FOO
 (reduce #'list '(1 2 3 4)) → (((1 2) 3) 4)
 (reduce #'list '(1 2 3 4) :from-end t) → (1 (2 (3 4)))
 (reduce #'list '(1 2 3 4) :initial-value 'foo) → ((((foo 1) 2) 3) 4)
 (reduce #'list '(1 2 3 4)
        :from-end t :initial-value 'foo) → (1 (2 (3 (4 foo))))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: count; count-if; count-if-not,  Next: length,  Prev: reduce,  Up: Sequences

count, count-if, count-if-not (Function)
========================================

Syntax:
.......

 -- Function: count item sequence &key from-end start end key test
          test-not → n

 -- Function: count-if predicate sequence &key from-end start end key →
          n

 -- Function: count-if-not predicate sequence &key from-end start end
          key → n

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY--a designator for a function of one argument, or ‘nil’.

N--a non-negative integer less than or equal to the length of SEQUENCE.

Description:
............

‘count’, ‘count-if’, and ‘count-if-not’ count and return the number of
elements in the SEQUENCE bounded by START and END that satisfy the test.

The FROM-END has no direct effect on the result.  However, if FROM-END
is true, the elements of SEQUENCE will be supplied as arguments to the
TEST, TEST-NOT, and KEY in reverse order, which may change the
side-effects, if any, of those functions.

Examples:
.........

 (count #\a "how many A's are there in here?") → 2
 (count-if-not #'oddp '((1) (2) (3) (4)) :key #'car) → 2
 (count-if #'upper-case-p "The Crying of Lot 49" :start 4) → 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 17.2 (Rules about Test Functions): Rules about Test
Functions, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘count-if-not’ is deprecated.


File: ansicl,  Node: length,  Next: reverse; nreverse,  Prev: count; count-if; count-if-not,  Up: Sequences

length (Function)
=================

Syntax:
.......

 -- Function: length sequence → n

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

N--a non-negative integer.

Description:
............

Returns the number of elements in SEQUENCE.

If SEQUENCE is a vector with a fill pointer, the active length as
specified by the fill pointer is returned.

Examples:
.........

 (length "abc") → 3
 (setq str (make-array '(3) :element-type 'character
                            :initial-contents "abc"
                            :fill-pointer t)) → "abc"
 (length str) → 3
 (setf (fill-pointer str) 2) → 2
 (length str) → 2

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note list-length::, *note sequence::


File: ansicl,  Node: reverse; nreverse,  Next: sort; stable-sort,  Prev: length,  Up: Sequences

reverse, nreverse (Function)
============================

Syntax:
.......

 -- Function: reverse sequence → reversed-sequence

 -- Function: nreverse sequence → reversed-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

REVERSED-SEQUENCE--a sequence.

Description:
............

‘reverse’ and ‘nreverse’ return a new sequence of the same kind as
SEQUENCE, containing the same elements, but in reverse order.

‘reverse’ and ‘nreverse’ differ in that ‘reverse’ always creates and
returns a new sequence, whereas ‘nreverse’ might modify and return the
given SEQUENCE.  ‘reverse’ never modifies the given SEQUENCE.

For ‘reverse’, if SEQUENCE is a vector, the result is a fresh simple
array of rank one that has the same actual array element type as
SEQUENCE.  If SEQUENCE is a list, the result is a fresh list.

For ‘nreverse’, if SEQUENCE is a vector, the result is a vector that
has the same actual array element type as SEQUENCE.  If SEQUENCE is a
list, the result is a list.

For ‘nreverse’, SEQUENCE might be destroyed and re-used to produce the
result.  The result might or might not be identical to SEQUENCE.
Specifically, when SEQUENCE is a list, ‘nreverse’ is permitted to
‘setf’ any part, ‘car’ or ‘cdr’, of any cons that is part of the list
structure of SEQUENCE.  When SEQUENCE is a vector, ‘nreverse’ is
permitted to re-order the elements of SEQUENCE in order to produce the
resulting vector.

Examples:
.........

 (setq str "abc") → "abc"
 (reverse str) → "cba"
 str → "abc"
 (setq str (copy-seq str)) → "abc"
 (nreverse str) → "cba"
 str → implementation-dependent
 (setq l (list 1 2 3)) → (1 2 3)
 (nreverse l) → (3 2 1)
 l → implementation-dependent

Side Effects:
.............

‘nreverse’ might either create a new sequence, modify the argument
SEQUENCE, or both.  (‘reverse’ does not modify SEQUENCE.)

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.


File: ansicl,  Node: sort; stable-sort,  Next: find; find-if; find-if-not,  Prev: reverse; nreverse,  Up: Sequences

sort, stable-sort (Function)
============================

Syntax:
.......

 -- Function: sort sequence predicate &key key → sorted-sequence

 -- Function: stable-sort sequence predicate &key key → sorted-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

SORTED-SEQUENCE--a sequence.

Description:
............

‘sort’ and ‘stable-sort’ destructively sort SEQUENCES according to the
order determined by the PREDICATE function.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

‘sort’ determines the relationship between two elements by giving keys
extracted from the elements to the PREDICATE.  The first argument to
the PREDICATE function is the part of one element of SEQUENCE extracted
by the KEY function (if supplied); the second argument is the part of
another element of SEQUENCE extracted by the KEY function (if supplied).
PREDICATE should return true if and only if the first argument is
strictly less than the second (in some appropriate sense).  If the
first argument is greater than or equal to the second (in the
appropriate sense), then the PREDICATE should return false.

The argument to the KEY function is the SEQUENCE element.  The return
value of the KEY function becomes an argument to PREDICATE.  If KEY is
not supplied or ‘nil’, the SEQUENCE element itself is used.  There is
no guarantee on the number of times the KEY will be called.

If the KEY and PREDICATE always return, then the sorting operation will
always terminate, producing a sequence containing the same elements as
SEQUENCE (that is, the result is a permutation of SEQUENCE).  This is
guaranteed even if the PREDICATE does not really consistently represent
a total order (in which case the elements will be scrambled in some
unpredictable way, but no element will be lost).  If the KEY
consistently returns meaningful keys, and the PREDICATE does reflect
some total ordering criterion on those keys, then the elements of the
SORTED-SEQUENCE will be properly sorted according to that ordering.

The sorting operation performed by ‘sort’ is not guaranteed stable.
Elements considered equal by the PREDICATE might or might not stay in
their original order.  The PREDICATE is assumed to consider two
elements ‘x’ and ‘y’ to be equal if ‘(funcall predicate x y)’ and
‘(funcall predicate y x)’ are both false.  ‘stable-sort’ guarantees
stability.

The sorting operation can be destructive in all cases.  In the case of a
vector argument, this is accomplished by permuting the elements in
place.  In the case of a list, the list is destructively reordered in
the same manner as for ‘nreverse’.

Examples:
.........

 (setq tester (copy-seq "lkjashd")) → "lkjashd"
 (sort tester #'char-lessp) → "adhjkls"
 (setq tester (list '(1 2 3) '(4 5 6) '(7 8 9))) → ((1 2 3) (4 5 6) (7 8 9))
 (sort tester #'> :key #'car)  → ((7 8 9) (4 5 6) (1 2 3))
 (setq tester (list 1 2 3 4 5 6 7 8 9 0)) → (1 2 3 4 5 6 7 8 9 0)
 (stable-sort tester #'(lambda (x y) (and (oddp x) (evenp y))))
→ (1 3 5 7 9 2 4 6 8 0)
 (sort (setq committee-data
             (vector (list (list "JonL" "White") "Iteration")
                     (list (list "Dick" "Waters") "Iteration")
                     (list (list "Dick" "Gabriel") "Objects")
                     (list (list "Kent" "Pitman") "Conditions")
                     (list (list "Gregor" "Kiczales") "Objects")
                     (list (list "David" "Moon") "Objects")
                     (list (list "Kathy" "Chapman") "Editorial")
                     (list (list "Larry" "Masinter") "Cleanup")
                     (list (list "Sandra" "Loosemore") "Compiler")))
       #'string-lessp :key #'cadar)
→ #((("Kathy" "Chapman") "Editorial")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("Sandra" "Loosemore") "Compiler")
     (("Larry" "Masinter") "Cleanup")
     (("David" "Moon") "Objects")
     (("Kent" "Pitman") "Conditions")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration"))
 ;; Note that individual alphabetical order within `committees'
 ;; is preserved.
 (setq committee-data
       (stable-sort committee-data #'string-lessp :key #'cadr))
→ #((("Larry" "Masinter") "Cleanup")
     (("Sandra" "Loosemore") "Compiler")
     (("Kent" "Pitman") "Conditions")
     (("Kathy" "Chapman") "Editorial")
     (("Dick" "Waters") "Iteration")
     (("JonL" "White") "Iteration")
     (("Dick" "Gabriel") "Objects")
     (("Gregor" "Kiczales") "Objects")
     (("David" "Moon") "Objects"))

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note merge::, *note Section 3.2.1 (Compiler Terminology): Compiler
Terminology, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects, *note Section 3.7 (Destructive
Operations): Destructive Operations.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.


File: ansicl,  Node: find; find-if; find-if-not,  Next: position; position-if; position-if-not,  Prev: sort; stable-sort,  Up: Sequences

find, find-if, find-if-not (Function)
=====================================

Syntax:
.......

 -- Function: find item sequence &key from-end test test-not start end
          key → element

 -- Function: find-if predicate sequence &key from-end start end key →
          element

 -- Function: find-if-not predicate sequence &key from-end start end
          key → element

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY--a designator for a function of one argument, or ‘nil’.

ELEMENT--an element of the SEQUENCE, or ‘nil’.

Description:
............

‘find’, ‘find-if’, and ‘find-if-not’ each search for an element of the
SEQUENCE bounded by START and end that satisfies the predicate PREDICATE
or that satisfies the test TEST or TEST-NOT, as appropriate.

If FROM-END is true, then the result is the rightmost element that
satisfies the test.

If the SEQUENCE contains an element that satisfies the test, then the
leftmost or rightmost SEQUENCE element, depending on FROM-END, is
returned; otherwise ‘nil’ is returned.

Examples:
.........

 (find #\d "here are some letters that can be looked at" :test #'char>)
→ #\Space
 (find-if #'oddp '(1 2 3 4 5) :end 3 :from-end t) → 3
 (find-if-not #'complexp
             '#(3.5 2 #C(1.0 0.0) #C(0.0 1.0))
             :start 2) → NIL

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note position::, *note Section 17.2 (Rules about Test Functions):
Rules about Test Functions, *note Section 3.6 (Traversal Rules and Side
Effects): Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘find-if-not’ is deprecated.


File: ansicl,  Node: position; position-if; position-if-not,  Next: search,  Prev: find; find-if; find-if-not,  Up: Sequences

position, position-if, position-if-not (Function)
=================================================

Syntax:
.......

 -- Function: position item sequence &key from-end test test-not start
          end key → position

 -- Function: position-if predicate sequence &key from-end start end
          key → position

 -- Function: position-if-not predicate sequence &key from-end start
          end key → position

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY--a designator for a function of one argument, or ‘nil’.

POSITION--a bounding index of SEQUENCE, or ‘nil’.

Description:
............

‘position’, ‘position-if’, and ‘position-if-not’ each search SEQUENCE
for an element that satisfies the test.

The POSITION returned is the index within SEQUENCE of the leftmost  (if
FROM-END is true) or of the rightmost (if FROM-END is false) element
that satisfies the test; otherwise ‘nil’ is returned.  The index
returned is relative to the left-hand end of the entire SEQUENCE,
regardless of the value of start, end, or from-end.

Examples:
.........

 (position #\a "baobab" :from-end t) → 4
 (position-if #'oddp '((1) (2) (3) (4)) :start 1 :key #'car) → 2
 (position 595 '()) → NIL
 (position-if-not #'integerp '(1 2 3 4 5.0)) → 4

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note find::, *note Section 3.6 (Traversal Rules and Side Effects):
Traversal Rules and Side Effects.

Notes:
......

The :test-not argument is deprecated.

The function ‘position-if-not’ is deprecated.


File: ansicl,  Node: search,  Next: mismatch,  Prev: position; position-if; position-if-not,  Up: Sequences

search (Function)
=================

Syntax:
.......

 -- Function: search sequence-1 sequence-2 &key from-end test test-not
          key start1 start2 end1 end2 → position

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ‘0’ and ‘nil’, respectively.

POSITION--a bounding index of SEQUENCE-2, or ‘nil’.

Description:
............

Searches SEQUENCE-2 for a subsequence that matches SEQUENCE-1.

The implementation may choose to search SEQUENCE-2 in any order; there
is no guarantee on the number of times the test is made.  For example,
when START-END is true, the SEQUENCE might actually be searched from
left to right instead of from right to left (but in either case would
return the rightmost matching subsequence).  If the search succeeds,
‘search’ returns the offset into SEQUENCE-2 of the first element of the
leftmost or rightmost matching subsequence, depending on FROM-END;
otherwise ‘search’ returns ‘nil’.

If FROM-END is true, the index of the leftmost element of the rightmost
matching subsequence is returned.

Examples:
.........

 (search "dog" "it's a dog's life") → 7
 (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) → 2

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: ansicl,  Node: mismatch,  Next: replace,  Prev: search,  Up: Sequences

mismatch (Function)
===================

Syntax:
.......

 -- Function: mismatch sequence-1 sequence-2 &key from-end test
          test-not key start1 start2 end1 end2 → position

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ‘0’ and ‘nil’, respectively.

KEY--a designator for a function of one argument, or ‘nil’.

POSITION--a bounding index of SEQUENCE-1, or ‘nil’.

Description:
............

The specified subsequences of SEQUENCE-1 and SEQUENCE-2 are compared
element-wise.

The KEY argument is used for both the SEQUENCE-1 and the SEQUENCE-2.

If SEQUENCE-1 and SEQUENCE-2 are of equal length and match in every
element, the result is false.  Otherwise, the result is a non-negative
integer, the index within SEQUENCE-1 of the leftmost or rightmost
position, depending on FROM-END, at which the two subsequences fail to
match.  If one subsequence is shorter than and a matching prefix of the
other, the result is the index relative to SEQUENCE-1 beyond the last
position tested.

If FROM-END is true, then one plus the index of the rightmost position
in which the SEQUENCES differ is returned.  In effect, the subsequences
are aligned at their right-hand ends; then, the last elements are
compared, the penultimate elements, and so on.  The index returned is
an index relative to SEQUENCE-1.

Examples:
.........

 (mismatch "abcd" "ABCDE" :test #'char-equal) → 4
 (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) → 3
 (mismatch '(1 2 3) '(2 3 4) :test-not #'eq :key #'oddp) → NIL
 (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) → NIL

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.

Notes:
......

The :test-not argument is deprecated.


File: ansicl,  Node: replace,  Next: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Prev: mismatch,  Up: Sequences

replace (Function)
==================

Syntax:
.......

 -- Function: replace sequence-1 sequence-2 &key start1 end1 start2
          end2 → sequence-1

Arguments and Values:
.....................

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

START1, END1--bounding index designators of SEQUENCE-1.  The defaults
for START1 and END1 are ‘0’ and ‘nil’, respectively.

START2, END2--bounding index designators of SEQUENCE-2.  The defaults
for START2 and END2 are ‘0’ and ‘nil’, respectively.

Description:
............

Destructively modifies SEQUENCE-1 by replacing the elements of
SUBSEQUENCE-1 bounded by START1 and END1 with the elements of
SUBSEQUENCE-2 bounded by START2 and END2.

SEQUENCE-1 is destructively modified by copying successive elements
into it from SEQUENCE-2.  Elements of the subsequence of SEQUENCE-2
bounded by START2 and END2 are copied into the subsequence of SEQUENCE-1
bounded by START1 and END1.  If these subsequences are not of the same
length, then the shorter length determines how many elements are copied;
the extra elements near the end of the longer subsequence are not
involved in the operation.  The number of elements copied can be
expressed as:

 (min (- end1 start1) (- end2 start2))

If SEQUENCE-1 and SEQUENCE-2 are the same object and the region being
modified overlaps the region being copied from, then it is as if the
entire source region were copied to another place and only then copied
back into the target region.  However, if SEQUENCE-1 and SEQUENCE-2 are
not the same, but the region being modified overlaps the region being
copied from (perhaps because of shared list structure or displaced
arrays), then after the ‘replace’ operation the subsequence of
SEQUENCE-1 being modified will have unpredictable contents.  It is an
error if the elements of SEQUENCE-2 are not of a type that can be
stored into SEQUENCE-1.

Examples:
.........

 (replace "abcdefghij" "0123456789" :start1 4 :end1 7 :start2 4)
→ "abcd456hij"
 (setq lst "012345678") → "012345678"
 (replace lst lst :start1 2 :start2 0) → "010123456"
 lst → "010123456"

Side Effects:
.............

The SEQUENCE-1 is modified.

See Also:
.........

*note fill::


File: ansicl,  Node: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Next: concatenate,  Prev: replace,  Up: Sequences

substitute, substitute-if, substitute-if-not, nsubstitute, nsubstitute-if, nsubstitute-if-not (Function)
========================================================================================================

Syntax:
.......

 -- Function: substitute newitem olditem sequence &key from-end test
          test-not start end count key → result-sequence

 -- Function: substitute-if newitem predicate sequence &key from-end
          start end count key → result-sequence

 -- Function: substitute-if-not newitem predicate sequence &key
          from-end start end count key → result-sequence

 -- Function: nsubstitute newitem olditem sequence &key from-end test
          test-not start end count key → sequence

 -- Function: nsubstitute-if newitem predicate sequence &key from-end
          start end count key → sequence

 -- Function: nsubstitute-if-not newitem predicate sequence &key
          from-end start end count key → sequence

Arguments and Values:
.....................

NEWITEM--an object.

OLDITEM--an object.

SEQUENCE--a proper sequence.

PREDICATE--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

COUNT--an integer or ‘nil’.  The default is ‘nil’.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE--a sequence.

Description:
............

‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ return a copy of
SEQUENCE in which each element that satisfies the test has been
replaced with NEWITEM.

‘nsubstitute’, ‘nsubstitute-if’, and ‘nsubstitute-if-not’ are like
‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ respectively,
but they may modify SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

COUNT, if supplied, limits the number of elements altered; if more than
COUNT elements satisfy the test, then of these elements only the
leftmost or rightmost, depending on FROM-END, are replaced, as many as
specified by COUNT.  If COUNT is supplied and negative, the behavior is
as if zero had been supplied instead.  If COUNT is ‘nil’, all matching
items are affected.

Supplying a FROM-END of true matters only when the COUNT is provided
(and non-nil); in that case, only the rightmost COUNT elements
satisfying the test are removed (instead of the leftmost).

PREDICATE, TEST, and TEST-NOT might be called more than once for each
sequence element, and their side effects can happen in any order.

The result of all these functions is a sequence of the same type as
SEQUENCE that has the same elements except that those in the subsequence
bounded by START and END and satisfying the test have been replaced by
NEWITEM.

‘substitute’, ‘substitute-if’, and ‘substitute-if-not’ return a
SEQUENCE which can share with SEQUENCE or may be identical to the input
SEQUENCE if no elements need to be changed.

‘nsubstitute’ and  ‘nsubstitute-if’ are required to ‘setf’ any ‘car’
(if SEQUENCE is a list) or ‘aref’ (if SEQUENCE is a vector) of SEQUENCE
that is required to be replaced with NEWITEM.  If SEQUENCE is a list,
none of the cdrs of the top-level list can be modified.

Examples:
.........

 (substitute #\. #\SPACE "0 2 4 6") → "0.2.4.6"
 (substitute 9 4 '(1 2 4 1 3 4 5)) → (1 2 9 1 3 9 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) → (1 2 9 1 3 4 5)
 (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
→ (1 2 4 1 3 9 5)
 (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) → (9 9 4 9 3 4 5)

 (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
→ ((1) (2) (3) 0)
 (substitute-if 9 #'oddp '(1 2 4 1 3 4 5)) → (9 2 4 9 9 4 9)
 (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
→ (1 2 4 1 3 9 5)

 (setq some-things (list 'a 'car 'b 'cdr 'c)) → (A CAR B CDR C)
 (nsubstitute-if "function was here" #'fboundp some-things
                 :count 1 :from-end t) → (A CAR B "function was here" C)
 some-things → (A CAR B "function was here" C)
 (setq alpha-tester (copy-seq "ab ")) → "ab "
 (nsubstitute-if-not #\z #'alpha-char-p alpha-tester) → "abz"
 alpha-tester → "abz"

Side Effects:
.............

‘nsubstitute’, ‘nsubstitute-if’, and ‘nsubstitute-if-not’ modify
SEQUENCE.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note subst::, *note nsubst::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ‘substitute-if-not’ and ‘nsubstitute-if-not’ are
deprecated.

‘nsubstitute’ and ‘nsubstitute-if’ can be used in for-effect-only
positions in code.

Because the side-effecting variants (e.g., ‘nsubstitute’) potentially
change the path that is being traversed, their effects in the presence
of shared or circular structure may vary in surprising ways when
compared to their non-side-effecting alternatives.  To see this,
consider the following side-effect behavior, which might be exhibited by
some implementations:

 (defun test-it (fn)
   (let ((x (cons 'b nil)))
     (rplacd x x)
     (funcall fn 'a 'b x :count 1)))
 (test-it #'substitute) → (A . #1=(B . #1#))
 (test-it #'nsubstitute) → (A . #1#)


File: ansicl,  Node: concatenate,  Next: merge,  Prev: substitute; substitute-if; substitute-if-not; nsubstitute; nsubstitute-+,  Up: Sequences

concatenate (Function)
======================

Syntax:
.......

 -- Function: concatenate result-type &rest sequences → result-sequence

Arguments and Values:
.....................

RESULT-TYPE--a ‘sequence’ type specifier.

SEQUENCES--a sequence.

RESULT-SEQUENCE--a proper sequence of type RESULT-TYPE.

Description:
............

‘concatenate’ returns a sequence that contains all the individual
elements of all the SEQUENCES in the order that they are supplied.  The
sequence is of type RESULT-TYPE, which must be a subtype of type
‘sequence’.

All of the SEQUENCES are copied from; the result does not share any
structure with any of the SEQUENCES.  Therefore, if only one SEQUENCE
is provided and it is of type RESULT-TYPE, ‘concatenate’ is required to
copy SEQUENCE rather than simply returning it.

It is an error if any element of the SEQUENCES cannot be an element of
the sequence result.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array
is ‘t’; otherwise, an error is signaled.

Examples:
.........

(concatenate 'string "all" " " "together" " " "now") → "all together now"
(concatenate 'list "ABC" '(d e f) #(1 2 3) #*1011)
→ (#\A #\B #\C D E F 1 2 3 1 0 1 1)
(concatenate 'list) → NIL

  (concatenate '(vector * 2) "a" "bc") should signal an error

Exceptional Situations:
.......................

An error is signaled if the RESULT-TYPE is neither a recognizable
subtype of ‘list’, nor a recognizable subtype of ‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of SEQUENCES is different
from that number.

See Also:
.........

*note append::


File: ansicl,  Node: merge,  Next: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Prev: concatenate,  Up: Sequences

merge (Function)
================

Syntax:
.......

 -- Function: merge result-type sequence-1 sequence-2 predicate &key
          key → result-sequence

Arguments and Values:
.....................

RESULT-TYPE--a ‘sequence’ type specifier.

SEQUENCE-1--a sequence.

SEQUENCE-2--a sequence.

PREDICATE--a designator for a function of two arguments that returns a
generalized boolean.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE--a proper sequence of type RESULT-TYPE.

Description:
............

Destructively merges SEQUENCE-1 with SEQUENCE-2 according to an order
determined by the PREDICATE.  ‘merge’ determines the relationship
between two elements by giving keys extracted from the sequence
elements to the PREDICATE.

The first argument to the PREDICATE function is an element of
SEQUENCE-1 as returned by the KEY (if supplied); the second argument is
an element of SEQUENCE-2 as returned by the KEY (if supplied).
PREDICATE should return true if and only if its first argument is
strictly less than the second (in some appropriate sense).  If the
first argument is greater than or equal to the second (in the
appropriate sense), then PREDICATE should return false.  ‘merge’
considers two elements ‘x’ and ‘y’ to be equal if ‘(funcall predicate x
y)’ and ‘(funcall predicate y x)’ both yield false.

The argument to the KEY is the SEQUENCE element.  Typically, the return
value of the KEY becomes the argument to PREDICATE.  If KEY is not
supplied or ‘nil’, the sequence element itself is used.  The KEY may be
executed more than once for each sequence element, and its side effects
may occur in any order.

If KEY and PREDICATE return, then the merging operation will terminate.
The result of merging two sequences ‘x’ and ‘y’ is a new sequence of
type RESULT-TYPE ‘z’, such that the length of ‘z’ is the sum of the
lengths of ‘x’ and ‘y’, and ‘z’ contains all the elements of ‘x’ and
‘y’.  If ‘x1’ and ‘x2’ are two elements of ‘x’, and ‘x1’ precedes ‘x2’
in ‘x’, then ‘x1’ precedes ‘x2’ in ‘z’, and similarly for elements of
‘y’.  In short, ‘z’ is an interleaving of ‘x’ and ‘y’.

If ‘x’ and ‘y’ were correctly sorted according to the PREDICATE, then
‘z’ will also be correctly sorted.  If ‘x’ or ‘y’ is not so sorted,
then ‘z’ will not be sorted, but will nevertheless be an interleaving
of ‘x’ and ‘y’.

The merging operation is guaranteed stable; if two or more elements are
considered equal by the PREDICATE, then the elements from SEQUENCE-1
will precede those from SEQUENCE-2 in the result.

SEQUENCE-1 and/or SEQUENCE-2 may be destroyed.

If the RESULT-TYPE is a subtype of ‘list’, the result will be a list.

If the RESULT-TYPE is a subtype of ‘vector’, then if the implementation
can determine the element type specified for the RESULT-TYPE, the
element type of the resulting array is the result of upgrading that
element type; or, if the implementation can determine that the element
type is unspecified (or ‘*’), the element type of the resulting array
is ‘t’; otherwise, an error is signaled.

Examples:
.........

 (setq test1 (list 1 3 4 6 7))
 (setq test2 (list 2 5 8))
 (merge 'list test1 test2 #'<) → (1 2 3 4 5 6 7 8)
 (setq test1 (copy-seq "BOY"))
 (setq test2 (copy-seq :nosy"))
 (merge 'string test1 test2 #'char-lessp) → "BnOosYy"
 (setq test1 (vector ((red . 1) (blue . 4))))
 (setq test2 (vector ((yellow . 2) (green . 7))))
 (merge 'vector test1 test2 #'< :key #'cdr)
→ #((RED . 1) (YELLOW . 2) (BLUE . 4) (GREEN . 7))

 (merge '(vector * 4) '(1 5) '(2 4 6) #'<) should signal an error

Exceptional Situations:
.......................

An error must be signaled if the RESULT-TYPE is neither a recognizable
subtype of ‘list’, nor a recognizable subtype of ‘vector’.

An error of type ‘type-error’ should be signaled if RESULT-TYPE
specifies the number of elements and the sum of the lengths of
SEQUENCE-1 and SEQUENCE-2 is different from that number.

See Also:
.........

*note sort::, *note stable-sort::, *note Section 3.2.1 (Compiler
Terminology): Compiler Terminology, *note Section 3.6 (Traversal Rules
and Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Next: remove-duplicates; delete-duplicates,  Prev: merge,  Up: Sequences

remove, remove-if, remove-if-not, delete, delete-if, delete-if-not (Function)
=============================================================================

Syntax:
.......

 -- Function: remove item sequence &key from-end test test-not start
          end count key → result-sequence

 -- Function: remove-if test sequence &key from-end start end count key
          → result-sequence

 -- Function: remove-if-not test sequence &key from-end start end count
          key → result-sequence

 -- Function: delete item sequence &key from-end test test-not start
          end count key → result-sequence

 -- Function: delete-if test sequence &key from-end start end count key
          → result-sequence

 -- Function: delete-if-not test sequence &key from-end start end count
          key → result-sequence

Arguments and Values:
.....................

ITEM--an object.

SEQUENCE--a proper sequence.

TEST--a designator for a function of one argument that returns a
generalized boolean.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

COUNT--an integer or ‘nil’.  The default is ‘nil’.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE--a sequence.

Description:
............

‘remove’, ‘remove-if’, and ‘remove-if-not’ return a SEQUENCE from which
the elements that satisfy the test have been removed.

‘delete’, ‘delete-if’, and ‘delete-if-not’ are like ‘remove’,
‘remove-if’, and ‘remove-if-not’ respectively, but they may modify
SEQUENCE.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

Supplying a FROM-END of true matters only when the COUNT is provided;
in that case only the rightmost COUNT elements satisfying the test are
deleted.

COUNT, if supplied, limits the number of elements removed or deleted;
if more than COUNT elements satisfy the test, then of these elements
only the leftmost or rightmost, depending on FROM-END, are deleted or
removed, as many as specified by COUNT.  If COUNT is supplied and
negative, the behavior is as if zero had been supplied instead.  If
COUNT is ‘nil’, all matching items are affected.

For all these functions, elements not removed or deleted occur in the
same order in the result as they did in SEQUENCE.

‘remove’, ‘remove-if’, ‘remove-if-not’ return a sequence of the same
type as SEQUENCE that has the same elements except that those in the
subsequence bounded by START and END and satisfying the test have been
removed.  This is a non-destructive operation. If any elements need to
be removed, the result will be a copy.  The result of ‘remove’ may share
with SEQUENCE; the result may be identical to the input SEQUENCE if no
elements need to be removed.

‘delete’, ‘delete-if’, and ‘delete-if-not’ return a sequence of the
same type as SEQUENCE that has the same elements except that those in
the subsequence bounded by START and END and satisfying the test have
been deleted.  SEQUENCE may be destroyed and used to construct the
result; however, the result might or might not be identical to SEQUENCE.

‘delete’, when SEQUENCE is a list, is permitted to ‘setf’ any part,
‘car’ or ‘cdr’, of the top-level list structure in that SEQUENCE.  When
SEQUENCE is a vector,  ‘delete’ is permitted to change the dimensions
of the vector and to slide its elements into new positions without
permuting them to produce the resulting vector.

‘delete-if’ is constrained to behave exactly as follows:

 (delete nil sequence
             :test #'(lambda (ignore item) (funcall test item))
             ...)

Examples:
.........

 (remove 4 '(1 3 4 5 9)) → (1 3 5 9)
 (remove 4 '(1 2 4 1 3 4 5)) → (1 2 1 3 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1) → (1 2 1 3 4 5)
 (remove 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) → (1 2 4 1 3 5)
 (remove 3 '(1 2 4 1 3 4 5) :test #'>) → (4 3 4 5)
 (setq lst '(list of four elements)) → (LIST OF FOUR ELEMENTS)
 (setq lst2 (copy-seq lst)) → (LIST OF FOUR ELEMENTS)
 (setq lst3 (delete 'four lst)) → (LIST OF ELEMENTS)
 (equal lst lst2) → false
 (remove-if #'oddp '(1 2 4 1 3 4 5)) → (2 4 4)
 (remove-if #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
→ (1 2 4 1 3 5)
 (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9) :count 2 :from-end t)
→ (1 2 3 4 5 6 8)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete 4 tester) → (1 2 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete 4 tester :count 1) → (1 2 1 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete 4 tester :count 1 :from-end t) → (1 2 4 1 3 5)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete 3 tester :test #'>) → (4 3 4 5)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete-if #'oddp tester) → (2 4 4)
 (setq tester (list 1 2 4 1 3 4 5)) → (1 2 4 1 3 4 5)
 (delete-if #'evenp tester :count 1 :from-end t) → (1 2 4 1 3 5)
 (setq tester (list 1 2 3 4 5 6)) → (1 2 3 4 5 6)
 (delete-if #'evenp tester) → (1 3 5)
 tester → implementation-dependent

 (setq foo (list 'a 'b 'c)) → (A B C)
 (setq bar (cdr foo)) → (B C)
 (setq foo (delete 'b foo)) → (A C)
 bar → ((C)) or ...
 (eq (cdr foo) (car bar)) → T or ...

Side Effects:
.............

For ‘delete’, ‘delete-if’, and ‘delete-if-not’, SEQUENCE may be
destroyed and used to construct the result.

Exceptional Situations:
.......................

Should be prepared to signal an error of type ‘type-error’ if SEQUENCE
is not a proper sequence.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

The functions ‘delete-if-not’ and ‘remove-if-not’ are deprecated.


File: ansicl,  Node: remove-duplicates; delete-duplicates,  Prev: remove; remove-if; remove-if-not; delete; delete-if; delete-if-not,  Up: Sequences

remove-duplicates, delete-duplicates (Function)
===============================================

Syntax:
.......

 -- Function: remove-duplicates sequence &key from-end test test-not
          start end key → result-sequence

 -- Function: delete-duplicates sequence &key from-end test test-not
          start end key → result-sequence

Arguments and Values:
.....................

SEQUENCE--a proper sequence.

FROM-END--a generalized boolean.  The default is false.

TEST--a designator for a function of two arguments that returns a
generalized boolean.

TEST-NOT--a designator for a function of two arguments that returns a
generalized boolean.

START, END--bounding index designators of SEQUENCE.  The defaults for
START and END are ‘0’ and ‘nil’, respectively.

KEY--a designator for a function of one argument, or ‘nil’.

RESULT-SEQUENCE--a sequence.

Description:
............

‘remove-duplicates’ returns a modified copy of SEQUENCE from which any
element that matches another element occurring in SEQUENCE has been
removed.

If SEQUENCE is a vector, the result is a vector that has the same
actual array element type as SEQUENCE.  If SEQUENCE is a list, the
result is a list.

‘delete-duplicates’ is like ‘remove-duplicates’, but
‘delete-duplicates’ may modify SEQUENCE.

The elements of SEQUENCE are compared pairwise, and if any two match,
then the one occurring earlier in SEQUENCE is discarded, unless
FROM-END is true, in which case the one later in SEQUENCE is discarded.

‘remove-duplicates’ and ‘delete-duplicates’ return a sequence of the
same type as SEQUENCE with enough elements removed so that no two of
the remaining elements match.  The order of the elements remaining in
the result is the same as the order in which they appear in SEQUENCE.

‘remove-duplicates’ returns a sequence that may share with SEQUENCE or
may be identical to SEQUENCE if no elements need to be removed.

‘delete-duplicates’, when SEQUENCE is a list, is permitted to ‘setf’
any part, ‘car’ or ‘cdr’, of the top-level list structure in that
SEQUENCE.  When SEQUENCE is a vector, ‘delete-duplicates’ is permitted
to change the dimensions of the vector and to slide its elements into
new positions without permuting them to produce the resulting vector.

Examples:
.........

 (remove-duplicates "aBcDAbCd" :test #'char-equal :from-end t) → "aBcD"
 (remove-duplicates '(a b c b d d e)) → (A C B D E)
 (remove-duplicates '(a b c b d d e) :from-end t) → (A B C D E)
 (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
     :test #'char-equal :key #'cadr) → ((BAR #\%) (BAZ #\A))
 (remove-duplicates '((foo #\a) (bar #\%) (baz #\A))
     :test #'char-equal :key #'cadr :from-end t) → ((FOO #\a) (BAR #\%))
 (setq tester (list 0 1 2 3 4 5 6))
 (delete-duplicates tester :key #'oddp :start 1 :end 6) → (0 4 5 6)

Side Effects:
.............

‘delete-duplicates’ might destructively modify SEQUENCE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if SEQUENCE is not a proper
sequence.

See Also:
.........

*note Section 3.2.1 (Compiler Terminology): Compiler Terminology, *note
Section 3.6 (Traversal Rules and Side Effects): Traversal Rules and
Side Effects.

Notes:
......

If SEQUENCE is a vector, the result might or might not be simple, and
might or might not be identical to SEQUENCE.

The :test-not argument is deprecated.

These functions are useful for converting SEQUENCE into a canonical
form suitable for representing a set.


File: ansicl,  Node: Hash Tables,  Next: Filenames,  Prev: Sequences,  Up: Top

18 Hash Tables
**************

* Menu:

* Hash Table Concepts::

Dictionary

* hash-table::
* make-hash-table::
* hash-table-p::
* hash-table-count::
* hash-table-rehash-size::
* hash-table-rehash-threshold::
* hash-table-size::
* hash-table-test::
* gethash::
* remhash::
* maphash::
* with-hash-table-iterator::
* clrhash::
* sxhash::


File: ansicl,  Node: Hash Table Concepts,  Next: hash-table,  Up: Hash Tables

18.1 Hash Table Concepts
========================

* Menu:

* Hash-Table Operations::
* Modifying Hash Table Keys::


File: ansicl,  Node: Hash-Table Operations,  Next: Modifying Hash Table Keys,  Up: Hash Table Concepts

18.1.1 Hash-Table Operations
----------------------------

The next figure lists some defined names that are applicable to hash
tables.  The following rules apply to hash tables.

   - A hash table can only associate one value with a given key. If an
     attempt is made to add a second value for a given key, the second
     value will replace the first.  Thus, adding a value to a hash
     table is a destructive operation; the hash table is modified.

   - There are four kinds of hash tables: those whose keys are compared
     with ‘eq’, those whose keys are compared with ‘eql’, those whose
     keys are compared with ‘equal’, and those whose keys are compared
     with ‘equalp’.

   - Hash tables are created by ‘make-hash-table’.  ‘gethash’ is used
     to look up a key and find the associated value.  New entries are
     added to hash tables using ‘setf’ with ‘gethash’.  ‘remhash’ is
     used to remove an entry.  For example:

      (setq a (make-hash-table)) → #<HASH-TABLE EQL 0/120 32536573>
      (setf (gethash 'color a) 'brown) → BROWN
      (setf (gethash 'name a) 'fred) → FRED
      (gethash 'color a) → BROWN, true
      (gethash 'name a) → FRED, true
      (gethash 'pointy a) → NIL, false

     In this example, the symbols ‘color’ and ‘name’ are being used as
     keys, and the symbols ‘brown’ and ‘fred’ are being used as the
     associated values.  The hash table has two items in it, one of
     which associates from ‘color’ to ‘brown’, and the other of which
     associates from ‘name’ to ‘fred’.

   - A key or a value may be any object.

   - The existence of an entry in the hash table can be determined from
     the secondary value returned by ‘gethash’.

clrhash            hash-table-p      remhash
gethash            make-hash-table   sxhash
hash-table-count   maphash           

Figure 18.1: Hash-table defined names


File: ansicl,  Node: Modifying Hash Table Keys,  Prev: Hash-Table Operations,  Up: Hash Table Concepts

18.1.2 Modifying Hash Table Keys
--------------------------------

The function supplied as the :test argument to ‘make-hash-table’
specifies the `equivalence test' for the hash table it creates.

An object is `visibly modified' with regard to an equivalence test if
there exists some set of objects (or potential objects) which are
equivalent to the object before the modification but are no longer
equivalent afterwards.

If an object O₁ is used as a key in a hash table H and is then visibly
modified with regard to the equivalence test of H, then the
consequences are unspecified if O₁, or any object O₂ equivalent to O₁
under the equivalence test (either before or after the modification),
is used as a key in further operations on H.  The consequences of using
O₁ as a key are unspecified even if O₁ is visibly modified and then
later modified again in such a way as to undo the visible modification.

Following are specifications of the modifications which are visible to
the equivalence tests which must be supported by hash tables.  The
modifications are described in terms of modification of components, and
are defined recursively.  Visible modifications of components of the
object are visible modifications of the object.

18.1.2.1 Visible Modification of Objects with respect to EQ and EQL
...................................................................

No standardized function is provided that is capable of visibly
modifying an object with regard to ‘eq’ or ‘eql’.

18.1.2.2 Visible Modification of Objects with respect to EQUAL
..............................................................

As a consequence of the behavior for ‘equal’, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *note Section 18.1.2.1 (Visible Modification of
Objects with respect to EQ and EQL): VisModEQL.

18.1.2.2.1 Visible Modification of Conses with respect to EQUAL
...............................................................

Any visible change to the car or the cdr of a cons is considered a
visible modification with regard to ‘equal’.

18.1.2.2.2 Visible Modification of Bit Vectors and Strings with respect to EQUAL
................................................................................

For a vector of type ‘bit-vector’ or of type ‘string’, any visible
change to an active element of the vector, or to the length of the
vector (if it is actually adjustable or has a fill pointer) is
considered a visible modification with regard to ‘equal’.

18.1.2.3 Visible Modification of Objects with respect to EQUALP
...............................................................

As a consequence of the behavior for ‘equalp’, the rules for visible
modification of objects not explicitly mentioned in this section are
inherited from those in *note Section 18.1.2.2 (Visible Modification of
Objects with respect to EQUAL): VisModEQUAL.

18.1.2.3.1 Visible Modification of Structures with respect to EQUALP
....................................................................

Any visible change to a slot of a structure is considered a visible
modification with regard to ‘equalp’.

18.1.2.3.2 Visible Modification of Arrays with respect to EQUALP
................................................................

In an array, any visible change to an active element, to the fill
pointer (if the array can and does have one), or to the dimensions (if
the array is actually adjustable) is considered a visible modification
with regard to ‘equalp’.

18.1.2.3.3 Visible Modification of Hash Tables with respect to EQUALP
.....................................................................

In a hash table, any visible change to the count of entries in the hash
table, to the keys, or to the values associated with the keys is
considered a visible modification with regard to ‘equalp’.

Note that the visibility of modifications to the keys depends on the
equivalence test of the hash table, not on the specification of
‘equalp’.

18.1.2.4 Visible Modifications by Language Extensions
.....................................................

Implementations that extend the language by providing additional mutator
functions (or additional behavior for existing mutator functions) must
document how the use of these extensions interacts with equivalence
tests and hash table searches.

Implementations that extend the language by defining additional
acceptable equivalence tests for hash tables (allowing additional
values for the :test argument to ‘make-hash-table’) must document the
visible components of these tests.


File: ansicl,  Node: hash-table,  Next: make-hash-table,  Prev: Hash Table Concepts,  Up: Hash Tables

hash-table (System Class)
=========================

Class Precedence List:
......................

‘hash-table’, ‘t’

Description:
............

Hash tables provide a way of mapping any object (a key) to an
associated object (a value).

See Also:
.........

*note Section 18.1 (Hash Table Concepts): Hash Table Concepts, *note
Section 22.1.3.13 (Printing Other Objects): PrintingOtherObjects.

Notes:
......

The intent is that this mapping be implemented by a hashing mechanism,
such as that described in Section 6.4 "Hashing" of `The Art of Computer
Programming, Volume 3' (pp506-549).  In spite of this intent, no
conforming implementation is required to use any particular technique
to implement the mapping.


File: ansicl,  Node: make-hash-table,  Next: hash-table-p,  Prev: hash-table,  Up: Hash Tables

make-hash-table (Function)
==========================

Syntax:
.......

 -- Function: make-hash-table &key test size rehash-size
          rehash-threshold → hash-table

Arguments and Values:
.....................

TEST--a designator for one of the functions ‘eq’, ‘eql’, ‘equal’, or
‘equalp’.  The default is ‘eql’.

SIZE--a non-negative integer.  The default is implementation-dependent.

REHASH-SIZE--a real of type ‘(or (integer 1 *) (float (1.0) *))’.  The
default is implementation-dependent.

REHASH-THRESHOLD--a real of type ‘(real 0 1)’.  The default is
implementation-dependent.

HASH-TABLE--a hash table.

Description:
............

Creates and returns a new hash table.

TEST determines how keys are compared.  An object is said to be present
in the HASH-TABLE if that object is the same under the test as the key
for some entry in the HASH-TABLE.

SIZE is a hint to the implementation about how much initial space to
allocate in the HASH-TABLE.  This information, taken together with the
REHASH-THRESHOLD, controls the approximate number of entries which it
should be possible to insert before the table has to grow.  The actual
size might be rounded up from SIZE to the next `good' size; for
example, some implementations might round to the next prime number.

REHASH-SIZE specifies a minimum amount to increase the size of the
HASH-TABLE when it becomes full enough to require rehashing; see
REHASH-THESHOLD below.  If REHASH-SIZE is an integer, the expected
growth rate for the table is additive and the integer is the number of
entries to add; if it is a float, the expected growth rate for the
table is multiplicative and the float is the ratio of the new size to
the old size.  As with SIZE, the actual size of the increase might be
rounded up.

REHASH-THRESHOLD specifies how full the HASH-TABLE can get before it
must grow.  It specifies the maximum desired hash-table occupancy level.

The values of REHASH-SIZE and REHASH-THRESHOLD do not constrain the
implementation to use any particular method for computing when and by
how much the size of HASH-TABLE should be enlarged.  Such decisions are
implementation-dependent, and these values only hints from the
programmer to the implementation, and the implementation is permitted
to ignore them.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 46142754>
 (setf (gethash "one" table) 1) → 1
 (gethash "one" table) → NIL, false
 (setq table (make-hash-table :test 'equal)) → #<HASH-TABLE EQUAL 0/139 46145547>
 (setf (gethash "one" table) 1) → 1
 (gethash "one" table) → 1, T
 (make-hash-table :rehash-size 1.5 :rehash-threshold 0.7)
→ #<HASH-TABLE EQL 0/120 46156620>

See Also:
.........

*note gethash::, *note hash-table::


File: ansicl,  Node: hash-table-p,  Next: hash-table-count,  Prev: make-hash-table,  Up: Hash Tables

hash-table-p (Function)
=======================

Syntax:
.......

 -- Function: hash-table-p object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘hash-table’; otherwise, returns
false.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32511220>
 (hash-table-p table) → true
 (hash-table-p 37) → false
 (hash-table-p '((a . 1) (b . 2))) → false

Notes:
......

 (hash-table-p OBJECT) ≡ (typep OBJECT 'hash-table)


File: ansicl,  Node: hash-table-count,  Next: hash-table-rehash-size,  Prev: hash-table-p,  Up: Hash Tables

hash-table-count (Function)
===========================

Syntax:
.......

 -- Function: hash-table-count hash-table → count

Arguments and Values:
.....................

HASH-TABLE--a hash table.

COUNT--a non-negative integer.

Description:
............

Returns the number of entries in the HASH-TABLE.  If HASH-TABLE has
just been created or newly cleared (see ‘clrhash’) the entry count is
‘0’.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32115135>
 (hash-table-count table) → 0
 (setf (gethash 57 table) "fifty-seven") → "fifty-seven"
 (hash-table-count table) → 1
 (dotimes (i 100) (setf (gethash i table) i)) → NIL
 (hash-table-count table) → 100

Affected By:
............

‘clrhash’, ‘remhash’, ‘setf’ of ‘gethash’

See Also:
.........

*note hash-table-size::

Notes:
......

The following relationships are functionally correct, although in
practice using ‘hash-table-count’ is probably much faster:

 (hash-table-count TABLE) ≡
 (loop for value being the hash-values of TABLE count t) ≡
 (let ((total 0))
   (maphash #'(lambda (key value)
                (declare (ignore key value))
                (incf total))
            TABLE)
   total)


File: ansicl,  Node: hash-table-rehash-size,  Next: hash-table-rehash-threshold,  Prev: hash-table-count,  Up: Hash Tables

hash-table-rehash-size (Function)
=================================

Syntax:
.......

 -- Function: hash-table-rehash-size hash-table → rehash-size

Arguments and Values:
.....................

HASH-TABLE--a hash table.

REHASH-SIZE--a real of type ‘(or (integer 1 *) (float (1.0) *))’.

Description:
............

Returns the current rehash size of HASH-TABLE, suitable for use in a
call to ‘make-hash-table’ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Examples:
.........

 (setq table (make-hash-table :size 100 :rehash-size 1.4))
→ #<HASH-TABLE EQL 0/100 2556371>
 (hash-table-rehash-size table) → 1.4

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::, *note hash-table-rehash-threshold::

Notes:
......

If the hash table was created with an integer rehash size, the result
is an integer, indicating that the rate of growth of the HASH-TABLE
when rehashed is intended to be additive; otherwise, the result is a
float, indicating that the rate of growth of the HASH-TABLE when
rehashed is intended to be multiplicative.  However, this value is only
advice to the implementation; the actual amount by which the HASH-TABLE
will grow upon rehash is implementation-dependent.


File: ansicl,  Node: hash-table-rehash-threshold,  Next: hash-table-size,  Prev: hash-table-rehash-size,  Up: Hash Tables

hash-table-rehash-threshold (Function)
======================================

Syntax:
.......

 -- Function: hash-table-rehash-threshold hash-table → rehash-threshold

Arguments and Values:
.....................

HASH-TABLE--a hash table.

REHASH-THRESHOLD--a real of type ‘(real 0 1)’.

Description:
............

Returns the current rehash threshold of HASH-TABLE, which is suitable
for use in a call to ‘make-hash-table’ in order to produce a hash table
with state corresponding to the current state of the HASH-TABLE.

Examples:
.........

 (setq table (make-hash-table :size 100 :rehash-threshold 0.5))
→ #<HASH-TABLE EQL 0/100 2562446>
 (hash-table-rehash-threshold table) → 0.5

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::, *note hash-table-rehash-size::


File: ansicl,  Node: hash-table-size,  Next: hash-table-test,  Prev: hash-table-rehash-threshold,  Up: Hash Tables

hash-table-size (Function)
==========================

Syntax:
.......

 -- Function: hash-table-size hash-table → size

Arguments and Values:
.....................

HASH-TABLE--a hash table.

SIZE--a non-negative integer.

Description:
............

Returns the current size of HASH-TABLE, which is suitable for use in a
call to ‘make-hash-table’ in order to produce a hash table with state
corresponding to the current state of the HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note hash-table-count::, *note make-hash-table::


File: ansicl,  Node: hash-table-test,  Next: gethash,  Prev: hash-table-size,  Up: Hash Tables

hash-table-test (Function)
==========================

Syntax:
.......

 -- Function: hash-table-test hash-table → test

Arguments and Values:
.....................

HASH-TABLE--a hash table.

TEST--a function designator.  For the four standardized hash table test
functions (see ‘make-hash-table’), the TEST value returned is always a
symbol.  If an implementation permits additional tests, it is
implementation-dependent whether such tests are returned as function
objects or function names.

Description:
............

Returns the test used for comparing keys in HASH-TABLE.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if HASH-TABLE is not a hash
table.

See Also:
.........

*note make-hash-table::


File: ansicl,  Node: gethash,  Next: remhash,  Prev: hash-table-test,  Up: Hash Tables

gethash (Accessor)
==================

Syntax:
.......

 -- Function: gethash key hash-table &optional default → value,
          present-p

(setf (gethash key hash-table &optional default) new-value)

Arguments and Values:
.....................

KEY--an object.

HASH-TABLE--a hash table.

DEFAULT--an object.  The default is ‘nil’.

VALUE--an object.

PRESENT-P--a generalized boolean.

Description:
............

VALUE is the object in HASH-TABLE whose key is the same as KEY under
the HASH-TABLE's equivalence test.  If there is no such entry, VALUE is
the DEFAULT.

PRESENT-P is true if an entry is found; otherwise, it is false.

‘setf’ may be used with ‘gethash’ to modify the value associated with a
given key, or to add a new entry.  When a ‘gethash’ form is used as a
‘setf’ PLACE, any DEFAULT which is supplied is evaluated according to
normal left-to-right evaluation rules, but its value is ignored.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32206334>
 (gethash 1 table) → NIL, false
 (gethash 1 table 2) → 2, false
 (setf (gethash 1 table) "one") → "one"
 (setf (gethash 2 table "two") "two") → "two"
 (gethash 1 table) → "one", true
 (gethash 2 table) → "two", true
 (gethash nil table) → NIL, false
 (setf (gethash nil table) nil) → NIL
 (gethash nil table) → NIL, true
 (defvar *counters* (make-hash-table)) → *COUNTERS*
 (gethash 'foo *counters*) → NIL, false
 (gethash 'foo *counters* 0) → 0, false
 (defmacro how-many (obj) `(values (gethash ,obj *counters* 0))) → HOW-MANY
 (defun count-it (obj) (incf (how-many obj))) → COUNT-IT
 (dolist (x '(bar foo foo bar bar baz)) (count-it x))
 (how-many 'foo) → 2
 (how-many 'bar) → 3
 (how-many 'quux) → 0

See Also:
.........

*note remhash::

Notes:
......

The secondary value, PRESENT-P, can be used to distinguish the absence
of an entry from the presence of an entry that has a value of DEFAULT.


File: ansicl,  Node: remhash,  Next: maphash,  Prev: gethash,  Up: Hash Tables

remhash (Function)
==================

Syntax:
.......

 -- Function: remhash key hash-table → generalized-boolean

Arguments and Values:
.....................

KEY--an object.

HASH-TABLE--a hash table.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Removes the entry for KEY in HASH-TABLE, if any.  Returns true if there
was such an entry, or false otherwise.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32115666>
 (setf (gethash 100 table) "C") → "C"
 (gethash 100 table) → "C", true
 (remhash 100 table) → true
 (gethash 100 table) → NIL, false
 (remhash 100 table) → false

Side Effects:
.............

The HASH-TABLE is modified.


File: ansicl,  Node: maphash,  Next: with-hash-table-iterator,  Prev: remhash,  Up: Hash Tables

maphash (Function)
==================

Syntax:
.......

 -- Function: maphash function hash-table → ‘nil’

Arguments and Values:
.....................

FUNCTION--a designator for a function of two arguments, the key and the
value.

HASH-TABLE--a hash table.

Description:
............

Iterates over all entries in the HASH-TABLE.  For each entry, the
FUNCTION is called with two arguments--the key and the value of that
entry.

The consequences are unspecified if any attempt is made to add or remove
an entry from the HASH-TABLE while a ‘maphash’ is in progress, with two
exceptions: the FUNCTION can use can use ‘setf’ of ‘gethash’ to change
the value part of the entry currently being processed, or it can use
‘remhash’ to remove that entry.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32304110>
 (dotimes (i 10) (setf (gethash i table) i)) → NIL
 (let ((sum-of-squares 0))
    (maphash #'(lambda (key val)
                 (let ((square (* val val)))
                   (incf sum-of-squares square)
                   (setf (gethash key table) square)))
             table)
    sum-of-squares) → 285
 (hash-table-count table) → 10
 (maphash #'(lambda (key val)
               (when (oddp val) (remhash key table)))
           table) → NIL
 (hash-table-count table) → 5
 (maphash #'(lambda (k v) (print (list k v))) table)
(0 0)
(8 64)
(2 4)
(6 36)
(4 16)
→ NIL

Side Effects:
.............

None, other than any which might be done by the FUNCTION.

See Also:
.........

*note loop::, *note with-hash-table-iterator::, *note Section 3.6
(Traversal Rules and Side Effects): Traversal Rules and Side Effects.


File: ansicl,  Node: with-hash-table-iterator,  Next: clrhash,  Prev: maphash,  Up: Hash Tables

with-hash-table-iterator (Macro)
================================

Syntax:
.......

 -- Macro: with-hash-table-iterator (name hash-table) {declaration}*
          {form}* → {result}*

Arguments and Values:
.....................

NAME--a name suitable for the first argument to ‘macrolet’.

HASH-TABLE--a form, evaluated once, that should produce a hash table.

DECLARATION--a declare expression; not evaluated.

FORMS--an implicit progn.

RESULTS--the values returned by FORMS.

Description:
............

Within the lexical scope of the body, NAME is defined via ‘macrolet’
such that successive invocations of ‘(NAME)’ return the items, one by
one, from the hash table that is obtained by evaluating HASH-TABLE only
once.

An invocation ‘(NAME)’ returns three values as follows:

  1. A generalized boolean that is true if an entry is returned.

  2. The key from the HASH-TABLE entry.

  3. The value from the HASH-TABLE entry.

After all entries have been returned by successive invocations of
‘(NAME)’, then only one value is returned, namely ‘nil’.

It is unspecified what happens if any of the implicit interior state of
an iteration is returned outside the dynamic extent of the
‘with-hash-table-iterator’ form such as by returning some closure over
the invocation form.

Any number of invocations of ‘with-hash-table-iterator’ can be nested,
and the body of the innermost one can invoke all of the locally
established macros, provided all of those macros have distinct names.

Examples:
.........

The following function should return ‘t’ on any hash table, and signal
an error if the usage of ‘with-hash-table-iterator’ does not agree with
the corresponding usage of ‘maphash’.

 (defun test-hash-table-iterator (hash-table)
   (let ((all-entries '())
         (generated-entries '())
         (unique (list nil)))
     (maphash #'(lambda (key value) (push (list key value) all-entries))
              hash-table)
     (with-hash-table-iterator (generator-fn hash-table)
       (loop
         (multiple-value-bind (more? key value) (generator-fn)
           (unless more? (return))
           (unless (eql value (gethash key hash-table unique))
             (error "Key ~S not found for value ~S" key value))
           (push (list key value) generated-entries))))
     (unless (= (length all-entries)
                (length generated-entries)
                (length (union all-entries generated-entries
                               :key #'car :test (hash-table-test hash-table))))
       (error "Generated entries and Maphash entries don't correspond"))
     t))

The following could be an acceptable definition of ‘maphash’,
implemented by ‘with-hash-table-iterator’.

 (defun maphash (function hash-table)
   (with-hash-table-iterator (next-entry hash-table)
     (loop (multiple-value-bind (more key value) (next-entry)
             (unless more (return nil))
             (funcall function key value)))))

Exceptional Situations:
.......................

The consequences are undefined if the local function named NAME
established by ‘with-hash-table-iterator’ is called after it has
returned false as its primary value.

See Also:
.........

*note Section 3.6 (Traversal Rules and Side Effects): Traversal Rules
and Side Effects.


File: ansicl,  Node: clrhash,  Next: sxhash,  Prev: with-hash-table-iterator,  Up: Hash Tables

clrhash (Function)
==================

Syntax:
.......

 -- Function: clrhash hash-table → hash-table

Arguments and Values:
.....................

HASH-TABLE--a hash table.

Description:
............

Removes all entries from HASH-TABLE, and then returns that empty hash
table.

Examples:
.........

 (setq table (make-hash-table)) → #<HASH-TABLE EQL 0/120 32004073>
 (dotimes (i 100) (setf (gethash i table) (format nil "~R" i))) → NIL
 (hash-table-count table) → 100
 (gethash 57 table) → "fifty-seven", true
 (clrhash table) → #<HASH-TABLE EQL 0/120 32004073>
 (hash-table-count table) → 0
 (gethash 57 table) → NIL, false

Side Effects:
.............

The HASH-TABLE is modified.


File: ansicl,  Node: sxhash,  Prev: clrhash,  Up: Hash Tables

sxhash (Function)
=================

Syntax:
.......

 -- Function: sxhash object → hash-code

Arguments and Values:
.....................

OBJECT--an object.

HASH-CODE--a non-negative fixnum.

Description:
............

‘sxhash’ returns a hash code for OBJECT.

The manner in which the hash code is computed is
implementation-dependent, but subject to certain constraints:

  1. ‘(equal X Y)’ implies ‘(= (sxhash X) (sxhash Y))’.

  2. For any two objects, X and Y, both of which are bit vectors,
     characters, conses, numbers, pathnames, strings, or symbols, and
     which are similar, ‘(sxhash X)’ and ‘(sxhash Y)’ yield the same
     mathematical value even if X and Y exist in different Lisp images
     of the same implementation.  See *note Section 3.2.4 (Literal
     Objects in Compiled Files): Literal Objects in Compiled Files.

  3. The HASH-CODE for an object is always the same within a single
     session provided that the object is not visibly modified with
     regard to the equivalence test ‘equal’.  See *note Section 18.1.2
     (Modifying Hash Table Keys): Modifying Hash Table Keys.

  4. The HASH-CODE is intended for hashing.  This places no verifiable
     constraint on a conforming implementation, but the intent is that
     an implementation should make a good-faith effort to produce
     HASH-CODES that are well distributed within the range of
     non-negative fixnums.

  5. Computation of the HASH-CODE must terminate, even if the OBJECT
     contains circularities.

Examples:
.........

 (= (sxhash (list 'list "ab")) (sxhash (list 'list "ab"))) → true
 (= (sxhash "a") (sxhash (make-string 1 :initial-element #\a))) → true
 (let ((r (make-random-state)))
   (= (sxhash r) (sxhash (make-random-state r))))
→ implementation-dependent

Affected By:
............

The implementation.

Notes:
......

Many common hashing needs are satisfied by ‘make-hash-table’ and the
related functions on hash tables.  ‘sxhash’ is intended for use where
the pre-defined abstractions are insufficient.  Its main intent is to
allow the user a convenient means of implementing more complicated
hashing paradigms than are provided through hash tables.

The hash codes returned by ‘sxhash’ are not necessarily related to any
hashing strategy used by any other function in Common Lisp.

For objects of types that ‘equal’ compares with ‘eq’, item 3 requires
that the HASH-CODE be based on some immutable quality of the identity
of the object.  Another legitimate implementation technique would be to
have ‘sxhash’ assign (and cache) a random hash code for these objects,
since there is no requirement that similar but non-‘eq’ objects have
the same hash code.

Although similarity is defined for symbols in terms of both the
symbol's name and the packages in which the symbol is accessible, item
3 disallows using package information to compute the hash code, since
changes to the package status of a symbol are not visible to EQUAL.


File: ansicl,  Node: Filenames,  Next: Files,  Prev: Hash Tables,  Up: Top

19 Filenames
************

* Menu:

* Overview of Filenames::
* Pathnames::
* Logical Pathnames::

Dictionary

* pathname (System Class)::
* logical-pathname (System Class)::
* pathname (Function)::
* make-pathname::
* pathnamep::
* pathname-host; pathname-device; pathname-directory; pathname-name; path+::
* load-logical-pathname-translations::
* logical-pathname-translations::
* logical-pathname (Function)::
* *default-pathname-defaults*::
* namestring; file-namestring; directory-namestring; host-namestring; eno+::
* parse-namestring::
* wild-pathname-p::
* pathname-match-p::
* translate-logical-pathname::
* translate-pathname::
* merge-pathnames::


File: ansicl,  Node: Overview of Filenames,  Next: Pathnames,  Up: Filenames

19.1 Overview of Filenames
==========================

There are many kinds of file systems, varying widely both in their
superficial syntactic details, and in their underlying power and
structure.  The facilities provided by Common Lisp for referring to and
manipulating files has been chosen to be compatible with many kinds of
file systems, while at the same time minimizing the program-visible
differences between kinds of file systems.

Since file systems vary in their conventions for naming files, there
are two distinct ways to represent filenames: as namestrings and as
pathnames.

* Menu:

* Namestrings as Filenames::
* Pathnames as Filenames::
* Parsing Namestrings Into Pathnames::


File: ansicl,  Node: Namestrings as Filenames,  Next: Pathnames as Filenames,  Up: Overview of Filenames

19.1.1 Namestrings as Filenames
-------------------------------

A "namestring" is a string that represents a filename.

In general, the syntax of namestrings involves the use of
implementation-defined conventions, usually those customary for the
file system in which the named file resides.  The only exception is the
syntax of a logical pathname namestring, which is defined in this
specification; see *note Section 19.3.1 (Syntax of Logical Pathname
Namestrings): Syntax of Logical Pathname Namestrings.

A conforming program must never unconditionally use a literal
namestring other than a logical pathname namestring because Common
Lisp does not define any namestring syntax other than that for logical
pathnames that would be guaranteed to be portable.  However, a
conforming program can, if it is careful, successfully manipulate
user-supplied data which contains or refers to non-portable namestrings.

A namestring can be coerced to a pathname by the functions ‘pathname’
or ‘parse-namestring’.


File: ansicl,  Node: Pathnames as Filenames,  Next: Parsing Namestrings Into Pathnames,  Prev: Namestrings as Filenames,  Up: Overview of Filenames

19.1.2 Pathnames as Filenames
-----------------------------

"Pathnames" are structured objects that can represent, in an
implementation-independent way, the filenames that are used natively by
an underlying file system.

In addition, pathnames can also represent certain partially composed
filenames for which an underlying file system might not have a specific
namestring representation.

A pathname need not correspond to any file that actually exists, and
more than one pathname can refer to the same file.  For example, the
pathname with a version of :newest might refer to the same file as a
pathname with the same components except a certain number as the
version.  Indeed, a pathname with version :newest might refer to
different files as time passes, because the meaning of such a pathname
depends on the state of the file system.

Some file systems naturally use a structural model for their filenames,
while others do not.  Within the Common Lisp pathname model, all
filenames are seen as having a particular structure, even if that
structure is not reflected in the underlying file system.  The nature
of the mapping between structure imposed by pathnames and the
structure, if any, that is used by the underlying file system is
implementation-defined.

Every pathname has six components: a host, a device, a directory, a
name, a type, and a version.  By naming files with pathnames, Common
Lisp programs can work in essentially the same way even in file systems
that seem superficially quite different.  For a detailed description of
these components, see *note Section 19.2.1 (Pathname Components):
Pathname Components.

The mapping of the pathname components into the concepts peculiar to
each file system is implementation-defined.  There exist conceivable
pathnames for which there is no mapping to a syntactically valid
filename in a particular implementation.  An implementation may use
various strategies in an attempt to find a mapping; for example, an
implementation may quietly truncate filenames that exceed length
limitations imposed by the underlying file system, or ignore certain
pathname components for which the file system provides no support.  If
such a mapping cannot be found, an error of type ‘file-error’ is
signaled.

The time at which this mapping and associated error signaling occurs is
implementation-dependent.  Specifically, it may occur at the time the
pathname is constructed, when coercing a pathname to a namestring, or
when an attempt is made to open or otherwise access the file designated
by the pathname.

The next figure lists some defined names that are applicable to
pathnames.

*default-pathname-defaults*   namestring           pathname-name
directory-namestring          open                 pathname-type
enough-namestring             parse-namestring     pathname-version
file-namestring               pathname             pathnamep
file-string-length            pathname-device      translate-pathname
host-namestring               pathname-directory   truename
make-pathname                 pathname-host        user-homedir-pathname
merge-pathnames               pathname-match-p     wild-pathname-p

Figure 19.1: Pathname Operations


File: ansicl,  Node: Parsing Namestrings Into Pathnames,  Prev: Pathnames as Filenames,  Up: Overview of Filenames

19.1.3 Parsing Namestrings Into Pathnames
-----------------------------------------

Parsing is the operation used to convert a namestring into a pathname.
Except in the case of parsing logical pathname namestrings, this
operation is implementation-dependent, because the format of
namestrings is implementation-dependent.

A conforming implementation is free to accommodate other file system
features in its pathname representation and provides a parser that can
process such specifications in namestrings.  Conforming programs must
not depend on any such features, since those features will not be
portable.


File: ansicl,  Node: Pathnames,  Next: Logical Pathnames,  Prev: Overview of Filenames,  Up: Filenames

19.2 Pathnames
==============

* Menu:

* Pathname Components::
* Interpreting Pathname Component Values::
* Merging Pathnames::


File: ansicl,  Node: Pathname Components,  Next: Interpreting Pathname Component Values,  Up: Pathnames

19.2.1 Pathname Components
--------------------------

A pathname has six components: a host, a device, a directory, a name, a
type, and a version.

19.2.1.1 The Pathname Host Component
....................................

The name of the file system on which the file resides, or the name of a
logical host.

19.2.1.2 The Pathname Device Component
......................................

Corresponds to the "device" or "file structure" concept in many host
file systems: the name of a logical or physical device containing files.

19.2.1.3 The Pathname Directory Component
.........................................

Corresponds to the "directory" concept in many host file systems: the
name of a group of related files.

19.2.1.4 The Pathname Name Component
....................................

The "name" part of a group of files that can be thought of as
conceptually related.

19.2.1.5 The Pathname Type Component
....................................

Corresponds to the "filetype" or "extension" concept in many host file
systems.  This says what kind of file this is.  This component is
always a string, ‘nil’, :wild, or :unspecific.

19.2.1.6 The Pathname Version Component
.......................................

Corresponds to the "version number" concept in many host file systems.

The version is either a positive integer or a symbol from the following
list: ‘nil’, :wild, :unspecific, or :newest (refers to the largest
version number that already exists in the file system when reading a
file, or to a version number greater than any already existing in the
file system when writing a new file).  Implementations can define other
special version symbols.


File: ansicl,  Node: Interpreting Pathname Component Values,  Next: Merging Pathnames,  Prev: Pathname Components,  Up: Pathnames

19.2.2 Interpreting Pathname Component Values
---------------------------------------------

19.2.2.1 Strings in Component Values
....................................

19.2.2.1.1 Special Characters in Pathname Components
....................................................

Strings in pathname component values never contain special characters
that represent separation between pathname fields, such as slash in
Unix filenames.  Whether separator characters are permitted as part of
a string in a pathname component is implementation-defined; however, if
the implementation does permit it, it must arrange to properly "quote"
the character for the file system when constructing a namestring.  For
example,

 ;; In a TOPS-20 implementation, which uses ^V to quote
 (NAMESTRING (MAKE-PATHNAME :HOST "OZ" :NAME "<TEST>"))
→ #P"OZ:PS:^V<TEST^V>"
not→ #P"OZ:PS:<TEST>"

19.2.2.1.2 Case in Pathname Components
......................................

Namestrings always use local file system case conventions, but Common
Lisp functions that manipulate pathname components allow the caller to
select either of two conventions for representing case in component
values by supplying a value for the :case keyword argument.  The next
figure lists the functions relating to pathnames that permit a :case
argument:

make-pathname     pathname-directory   pathname-name
pathname-device   pathname-host        pathname-type

Figure 19.2: Pathname functions using a :CASE argument

19.2.2.1.2.1 Local Case in Pathname Components
..............................................

For the functions in *note Figure 19.2: PathnameCaseFuns, a value of
:local for the :case argument (the default for these functions)
indicates that the functions should receive and yield strings in
component values as if they were already represented according to the
host file system's convention for case.

If the file system supports both cases, strings given or received as
pathname component values under this protocol are to be used exactly as
written.  If the file system only supports one case, the strings will
be translated to that case.

19.2.2.1.2.2 Common Case in Pathname Components
...............................................

For the functions in *note Figure 19.2: PathnameCaseFuns, a value of
:common for the :case argument that these functions should receive and
yield strings in component values according to the following
conventions:

   * All uppercase means to use a file system's customary case.

   * All lowercase means to use the opposite of the customary case.

   * Mixed case represents itself.

Note that these conventions have been chosen in such a way that
translation from :local to :common and back to :local is
information-preserving.

19.2.2.2 Special Pathname Component Values
..........................................

19.2.2.2.1 NIL as a Component Value
...................................

As a pathname component value, ‘nil’ represents that the component is
"unfilled"; see *note Section 19.2.3 (Merging Pathnames): Merging
Pathnames.

The value of any pathname component can be ‘nil’.

When constructing a pathname, ‘nil’ in the host component might mean a
default host rather than an actual ‘nil’ in some implementations.

19.2.2.2.2 :WILD as a Component Value
.....................................

If :wild is the value of a pathname component, that component is
considered to be a wildcard, which matches anything.

A conforming program must be prepared to encounter a value of :wild as
the value of any pathname component, or as an element of a list that is
the value of the directory component.

When constructing a pathname, a conforming program may use :wild as the
value of any or all of the directory, name, type, or version component,
but must not use :wild as the value of the host, or device component.

If :wild is used as the value of the directory component in the
construction of a pathname, the effect is equivalent to specifying the
list ‘(:absolute :wild-inferiors)’, or the same as ‘(:absolute :wild)’
in a file system that does not support :wild-inferiors.  

19.2.2.2.3 :UNSPECIFIC as a Component Value
...........................................

If :unspecific is the value of a pathname component, the component is
considered to be "absent" or to "have no meaning" in the filename being
represented by the pathname.

Whether a value of :unspecific is permitted for any component on any
given file system accessible to the implementation is
implementation-defined.  A conforming program must never
unconditionally use a :unspecific as the value of a pathname component
because such a value is not guaranteed to be permissible in all
implementations.  However, a conforming program can, if it is careful,
successfully manipulate user-supplied data which contains or refers to
non-portable pathname components.  And certainly a conforming program
should be prepared for the possibility that any components of a
pathname could be :unspecific.

When reading₁ the value of any pathname component, conforming programs
should be prepared for the value to be :unspecific.

When writing₁ the value of any pathname component, the consequences are
undefined if :unspecific is given for a pathname in a file system for
which it does not make sense.

19.2.2.2.3.1 Relation between component values NIL and :UNSPECIFIC
..................................................................

If a pathname is converted to a namestring, the symbols ‘nil’ and
:unspecific cause the field to be treated as if it were empty.  That is,
both ‘nil’ and :unspecific cause the component not to appear in the
namestring.

However, when merging a pathname with a set of defaults, only a
‘nil’ value for a component will be replaced with the default for that
component, while a value of :unspecific will be left alone as if the
field were "filled"; see the function *note merge-pathnames:: and *note
Section 19.2.3 (Merging Pathnames): Merging Pathnames.

19.2.2.3 Restrictions on Wildcard Pathnames
...........................................

Wildcard pathnames can be used with ‘directory’ but not with ‘open’,
and return true from ‘wild-pathname-p’. When examining wildcard
components of a wildcard pathname, conforming programs must be prepared
to encounter any of the following additional values in any component or
any element of a list that is the directory component:

   * The symbol :wild, which matches anything.

   * A string containing implementation-dependent special wildcard
     characters.

   * Any object, representing an implementation-dependent wildcard
     pattern.

19.2.2.4 Restrictions on Examining Pathname Components
......................................................

The space of possible objects that a conforming program must be
prepared to read₁ as the value of a pathname component is substantially
larger than the space of possible objects that a conforming program is
permitted to write₁ into such a component.

While the values discussed in the subsections of this section, in *note
Section 19.2.2.2 (Special Pathname Component Values):
SpecialComponentValues, and in *note Section 19.2.2.3 (Restrictions on
Wildcard Pathnames): WildcardRestrictions.  apply to values that might
be seen when reading the component values, substantially more
restrictive rules apply to constructing pathnames; see *note Section
19.2.2.5 (Restrictions on Constructing Pathnames):
ConstructingPathnames.

When examining pathname components, conforming programs should be aware
of the following restrictions.

19.2.2.4.1 Restrictions on Examining a Pathname Host Component
..............................................................

It is implementation-dependent what object is used to represent the
host.

19.2.2.4.2 Restrictions on Examining a Pathname Device Component
................................................................

The device might be a string, :wild, :unspecific, or ‘nil’.

Note that :wild might result from an attempt to read₁ the pathname
component, even though portable programs are restricted from writing₁
such a component value; see *note Section 19.2.2.3 (Restrictions on
Wildcard Pathnames): WildcardRestrictions. and *note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

19.2.2.4.3 Restrictions on Examining a Pathname Directory Component
...................................................................

The directory might be a string, :wild, :unspecific, or ‘nil’.

The directory can be a list of strings and symbols.  The car of the
list is one of the symbols :absolute or :relative , meaning:

:absolute
     A list whose car is the symbol :absolute represents a directory
     path starting from the root directory.  The list ‘(:absolute)’
     represents the root directory.  The list ‘(:absolute "foo" "bar"
     "baz")’ represents the directory called ‘"/foo/bar/baz"’ in Unix
     (except possibly for case).

:relative
     A list whose car is the symbol :relative represents a directory
     path starting from a default directory.  The list ‘(:relative)’
     has the same meaning as ‘nil’ and hence is not used.  The list
     ‘(:relative "foo" "bar")’ represents the directory named ‘"bar"’
     in the directory named ‘"foo"’ in the default directory.

Each remaining element of the list is a string or a symbol.

Each string names a single level of directory structure.  The strings
should contain only the directory names themselves--no punctuation
characters.

In place of a string, at any point in the list, symbols can occur to
indicate special file notations.  The next figure lists the symbols
that have standard meanings.  Implementations are permitted to add
additional objects of any type that is disjoint from ‘string’ if
necessary to represent features of their file systems that cannot be
represented with the standard strings and symbols.

Supplying any non-string, including any of the symbols listed below, to
a file system for which it does not make sense signals an error of type
‘file-error’.  For example, Unix does not support :wild-inferiors in
most implementations.

Symbol            Meaning
----------------------------------------------------------------------- 
:wild             Wildcard match of one level of directory structure
:wild-inferiors   Wildcard match of any number of directory levels
:up               Go upward in directory structure (semantic)
:back             Go upward in directory structure (syntactic)

Figure 19.3: Special Markers In Directory Component

The following notes apply to the previous figure:

Invalid Combinations
     Using :absolute or :wild-inferiors immediately followed by :up or
     :back signals an error of type ‘file-error’.

Syntactic vs Semantic
     "Syntactic" means that the action of :back depends only on the
     pathname and not on the contents of the file system.

     "Semantic" means that the action of :up depends on the contents of
     the file system; to resolve a pathname containing :up to a
     pathname whose directory component contains only :absolute and
     strings requires probing the file system.

     :up differs from :back only in file systems that support multiple
     names for directories, perhaps via symbolic links.  For example,
     suppose that there is a directory ‘(:absolute "X" "Y" "Z")’ linked
     to ‘(:absolute "A" "B" "C")’ and there also exist directories
     ‘(:absolute "A" "B" "Q")’ and ‘(:absolute "X" "Y" "Q")’.  Then
     ‘(:absolute "X" "Y" "Z" :up "Q")’ designates ‘(:absolute "A" "B"
     "Q")’ while ‘(:absolute "X" "Y" "Z" :back "Q")’ designates
     ‘(:absolute "X" "Y" "Q")’

19.2.2.4.3.1 Directory Components in Non-Hierarchical File Systems
..................................................................

In non-hierarchical file systems, the only valid list values for the
directory component of a pathname are ‘(:absolute string)’ and
‘(:absolute :wild)’.  :relative directories and the keywords
:wild-inferiors, :up, and :back are not used in non-hierarchical file
systems.

19.2.2.4.4 Restrictions on Examining a Pathname Name Component
..............................................................

The name might be a string, :wild, :unspecific, or ‘nil’.

19.2.2.4.5 Restrictions on Examining a Pathname Type Component
..............................................................

The type might be a string, :wild, :unspecific, or ‘nil’.

19.2.2.4.6 Restrictions on Examining a Pathname Version Component
.................................................................

The version can be any symbol or any integer.

The symbol :newest refers to the largest version number that already
exists in the file system when reading, overwriting, appending,
superseding, or directory listing an existing file.  The symbol :newest
refers to the smallest version number greater than any existing version
number when creating a new file.

The symbols ‘nil’, :unspecific, and :wild have special meanings and
restrictions; see *note Section 19.2.2.2 (Special Pathname Component
Values): SpecialComponentValues. and *note Section 19.2.2.5
(Restrictions on Constructing Pathnames): ConstructingPathnames.

Other symbols and integers have implementation-defined meaning.

19.2.2.4.7 Notes about the Pathname Version Component
.....................................................

It is suggested, but not required, that implementations do the
following:

   * Use positive integers starting at 1 as version numbers.

   * Recognize the symbol :oldest to designate the smallest existing
     version number.

   * Use keywords for other special versions.

19.2.2.5 Restrictions on Constructing Pathnames
...............................................

When constructing a pathname from components, conforming programs must
follow these rules:

   * Any component can be ‘nil’.  ‘nil’ in the host might mean a
     default host rather than an actual ‘nil’ in some implementations.

   * The host, device, directory, name, and type can be strings.  There
     are implementation-dependent limits on the number and type of
     characters in these strings.

   * The directory can be a list of strings and symbols.  There are
     implementation-dependent limits on the list's length and contents.

   * The version can be :newest.

   * Any component can be taken from the corresponding component of
     another pathname.  When the two pathnames are for different file
     systems (in implementations that support multiple file systems),
     an appropriate translation occurs.  If no meaningful translation
     is possible, an error is signaled.  The definitions of
     "appropriate" and "meaningful" are implementation-dependent.

   * An implementation might support other values for some components,
     but a portable program cannot use those values.  A conforming
     program can use implementation-dependent values but this can make
     it non-portable; for example, it might work only with Unix file
     systems.


File: ansicl,  Node: Merging Pathnames,  Prev: Interpreting Pathname Component Values,  Up: Pathnames

19.2.3 Merging Pathnames
------------------------

Merging takes a pathname with unfilled components and supplies values
for those components from a source of defaults.

If a component's value is ‘nil’, that component is considered to be
unfilled.  If a component's value is any non-nil object, including
:unspecific, that component is considered to be filled.

Except as explicitly specified otherwise, for functions that manipulate
or inquire about files in the file system, the pathname argument to
such a function is merged with ‘*default-pathname-defaults*’ before
accessing the file system (as if by ‘merge-pathnames’).

19.2.3.1 Examples of Merging Pathnames
......................................

Although the following examples are possible to execute only in
implementations which permit :unspecific in the indicated position
andwhich permit four-letter type components, they serve to illustrate
the basic concept of pathname merging.

 (pathname-type
   (merge-pathnames (make-pathname :type "LISP")
                    (make-pathname :type "TEXT")))
→ "LISP"

 (pathname-type
   (merge-pathnames (make-pathname :type nil)
                    (make-pathname :type "LISP")))
→ "LISP"

 (pathname-type
   (merge-pathnames (make-pathname :type :unspecific)
                    (make-pathname :type "LISP")))
→ :UNSPECIFIC


File: ansicl,  Node: Logical Pathnames,  Next: pathname (System Class),  Prev: Pathnames,  Up: Filenames

19.3 Logical Pathnames
======================

* Menu:

* Syntax of Logical Pathname Namestrings::
* Logical Pathname Components::


File: ansicl,  Node: Syntax of Logical Pathname Namestrings,  Next: Logical Pathname Components,  Up: Logical Pathnames

19.3.1 Syntax of Logical Pathname Namestrings
---------------------------------------------

The syntax of a logical pathname namestring is as follows.  (Note that
unlike many notational descriptions in this document, this is a
syntactic description of character sequences, not a structural
description of objects.)

LOGICAL-PATHNAME::=
     [↓host HOST-MARKER]
     [↓RELATIVE-DIRECTORY-MARKER] {↓directory DIRECTORY-MARKER}*
     [↓name] [TYPE-MARKER ↓type [VERSION-MARKER ↓version]]

HOST::=
     ↓word

DIRECTORY::=
     ↓word | ↓wildcard-word | ↓wild-inferiors-word

NAME::=
     ↓word | ↓wildcard-word

TYPE::=
     ↓word | ↓wildcard-word

VERSION::=
     ↓pos-int | NEWEST-WORD | WILDCARD-VERSION

HOST-MARKER--a colon.

RELATIVE-DIRECTORY-MARKER--a semicolon.

DIRECTORY-MARKER--a semicolon.

TYPE-MARKER--a dot.

VERSION-MARKER--a dot.

WILD-INFERIORS-WORD--The two character sequence "‘**’" (two asterisks).

NEWEST-WORD--The six character sequence "‘newest’" or the six character
sequence "‘NEWEST’".

WILDCARD-VERSION--an asterisk.

WILDCARD-WORD--one or more asterisks, uppercase letters, digits, and
hyphens, including at least one asterisk, with no two asterisks
adjacent.

WORD--one or more uppercase letters, digits, and hyphens.

POS-INT--a positive integer.

19.3.1.1 Additional Information about Parsing Logical Pathname Namestrings
..........................................................................

19.3.1.1.1 The Host part of a Logical Pathname Namestring
.........................................................

The HOST must have been defined as a logical pathname host; this can be
done by using ‘setf’ of ‘logical-pathname-translations’.

The logical pathname host name ‘"SYS"’ is reserved for the
implementation.  The existence and meaning of ‘SYS:’ logical pathnames
is implementation-defined.

19.3.1.1.2 The Device part of a Logical Pathname Namestring
...........................................................

There is no syntax for a logical pathname device since the device
component of a logical pathname is always :unspecific; see *note
Section 19.3.2.1 (Unspecific Components of a Logical Pathname):
LogicalPathCompUnspecific.

19.3.1.1.3 The Directory part of a Logical Pathname Namestring
..............................................................

If a RELATIVE-DIRECTORY-MARKER precedes the DIRECTORIES, the directory
component parsed is as relative; otherwise, the directory component is
parsed as absolute.

If a WILD-INFERIORS-MARKER is specified, it parses into :wild-inferiors.

19.3.1.1.4 The Type part of a Logical Pathname Namestring
.........................................................

The TYPE of a logical pathname for a source file is ‘"LISP"’.   This
should be translated into whatever type is appropriate in a physical
pathname.

19.3.1.1.5 The Version part of a Logical Pathname Namestring
............................................................

Some file systems do not have VERSIONS.  Logical pathname translation
to such a file system ignores the VERSION.  This implies that a program
cannot rely on being able to store more than one version of a file
named by a logical pathname.

If a WILDCARD-VERSION is specified, it parses into :wild.

19.3.1.1.6 Wildcard Words in a Logical Pathname Namestring
..........................................................

Each asterisk in a WILDCARD-WORD matches a sequence of zero or more
characters.  The WILDCARD-WORD "‘*’" parses into :wild; other
wildcard-words parse into strings.

19.3.1.1.7 Lowercase Letters in a Logical Pathname Namestring
.............................................................

When parsing WORDS and WILDCARD-WORDS, lowercase letters are translated
to uppercase.

19.3.1.1.8 Other Syntax in a Logical Pathname Namestring
........................................................

The consequences of using characters other than those specified here in
a logical pathname namestring are unspecified.

The consequences of using any value not specified here as a logical
pathname component are unspecified.


File: ansicl,  Node: Logical Pathname Components,  Prev: Syntax of Logical Pathname Namestrings,  Up: Logical Pathnames

19.3.2 Logical Pathname Components
----------------------------------

19.3.2.1 Unspecific Components of a Logical Pathname
....................................................

The device component of a logical pathname is always :unspecific; no
other component of a logical pathname can be :unspecific.

19.3.2.2 Null Strings as Components of a Logical Pathname
.........................................................

The null string, ‘""’, is not a valid value for any component of a
logical pathname.


File: ansicl,  Node: pathname (System Class),  Next: logical-pathname (System Class),  Prev: Logical Pathnames,  Up: Filenames

pathname (System Class)
=======================

Class Precedence List:
......................

‘pathname’, ‘t’

Description:
............

A pathname is a structured object which represents a filename.

There are two kinds of pathnames--physical pathnames and logical
pathnames.


File: ansicl,  Node: logical-pathname (System Class),  Next: pathname (Function),  Prev: pathname (System Class),  Up: Filenames

logical-pathname (System Class)
===============================

Class Precedence List:
......................

‘logical-pathname’, ‘pathname’, ‘t’

Description:
............

A pathname that uses a namestring syntax that is
implementation-independent, and that has component values that are
implementation-independent.  Logical pathnames do not refer directly to
filenames

See Also:
.........

*note Section 20.1 (File System Concepts): File System Concepts, *note
Section 2.4.8.14 (Sharpsign P): SharpsignP, *note Section 22.1.3.11
(Printing Pathnames): PrintingPathnames.


File: ansicl,  Node: pathname (Function),  Next: make-pathname,  Prev: logical-pathname (System Class),  Up: Filenames

pathname (Function)
===================

Syntax:
.......

 -- Function: pathname pathspec → pathname

Arguments and Values:
.....................

PATHSPEC--a pathname designator.

PATHNAME--a pathname.

Description:
............

Returns the pathname denoted by PATHSPEC.

If the PATHSPEC designator is a stream, the stream can be either open
or closed; in both cases, the ‘pathname’ returned corresponds to the
filename used to open the file.  ‘pathname’ returns the same pathname
for a file stream after it is closed as it did when it was open.

If the PATHSPEC designator is a file stream created by opening a
logical pathname, a logical pathname is returned.

Examples:
.........

 ;; There is a great degree of variability permitted here.  The next
 ;; several examples are intended to illustrate just a few of the many
 ;; possibilities.  Whether the name is canonicalized to a particular
 ;; case (either upper or lower) depends on both the file system and the
 ;; implementation since two different implementations using the same
 ;; file system might differ on many issues.  How information is stored
 ;; internally (and possibly presented in #S notation) might vary,
 ;; possibly requiring `accessors' such as PATHNAME-NAME to perform case
 ;; conversion upon access.  The format of a namestring is dependent both
 ;; on the file system and the implementation since, for example, one
 ;; implementation might include the host name in a namestring, and
 ;; another might not.  #S notation would generally only be used in a
 ;; situation where no appropriate namestring could be constructed for use
 ;; with #P.
 (setq p1 (pathname "test"))
→ #P"CHOCOLATE:TEST" ; with case canonicalization (e.g., VMS)
or→ #P"VANILLA:test"   ; without case canonicalization (e.g., Unix)
or→ #P"test"
or→ #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
or→ #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
 (setq p2 (pathname "test"))
→ #P"CHOCOLATE:TEST"
or→ #P"VANILLA:test"
or→ #P"test"
or→ #S(PATHNAME :HOST "STRAWBERRY" :NAME "TEST")
or→ #S(PATHNAME :HOST "BELGIAN-CHOCOLATE" :NAME "test")
 (pathnamep p1) → true
 (eq p1 (pathname p1)) → true
 (eq p1 p2)
→ true
or→ false
 (with-open-file (stream "test" :direction :output)
   (pathname stream))
→ #P"ORANGE-CHOCOLATE:>Gus>test.lisp.newest"

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: make-pathname,  Next: pathnamep,  Prev: pathname (Function),  Up: Filenames

make-pathname (Function)
========================

Syntax:
.......

 -- Function: make-pathname &key host device directory name type
          version defaults case → pathname

Arguments and Values:
.....................

HOST--a valid physical pathname host.  Complicated defaulting behavior;
see below.

DEVICE--a valid pathname device.  Complicated defaulting behavior; see
below.

DIRECTORY--a valid pathname directory.  Complicated defaulting
behavior; see below.

NAME--a valid pathname name.  Complicated defaulting behavior; see
below.

TYPE--a valid pathname type.  Complicated defaulting behavior; see
below.

VERSION--a valid pathname version.  Complicated defaulting behavior;
see below.

DEFAULTS--a pathname designator.  The default is a pathname whose host
component is the same as the host component of the value of
‘*default-pathname-defaults*’, and whose other components are all ‘nil’.

CASE--one of :common or :local.  The default is :local.

PATHNAME--a pathname.

Description:
............

Constructs and returns a pathname from the supplied keyword arguments.

After the components supplied explicitly by HOST, DEVICE, DIRECTORY,
NAME, TYPE, and VERSION are filled in, the merging rules used by
‘merge-pathnames’ are used to fill in any unsupplied components from
the defaults supplied by DEFAULTS.

Whenever a pathname is constructed the components may be canonicalized
if appropriate.  For the explanation of the arguments that can be
supplied for each component, see *note Section 19.2.1 (Pathname
Components): Pathname Components.

If CASE is supplied, it is treated as described in *note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

The resulting PATHNAME is a logical pathname if and only its host
component is a logical host or a string that names a defined logical
host.

If the DIRECTORY is a string, it should be the name of a top level
directory, and should not contain any punctuation characters; that is,
specifying a string, str, is equivalent to specifying the list
‘(:absolute str)’.  Specifying the symbol :wild is equivalent to
specifying the list ‘(:absolute :wild-inferiors)’, or ‘(:absolute
:wild)’ in a file system that does not support :wild-inferiors.

Examples:
.........

 ;; Implementation A -- an implementation with access to a single
 ;;  Unix file system.  This implementation happens to never display
 ;;  the `host' information in a namestring, since there is only one host.
 (make-pathname :directory '(:absolute "public" "games")
                :name "chess" :type "db")
→ #P"/public/games/chess.db"


 ;; Implementation B -- an implementation with access to one or more
 ;;  VMS file systems.  This implementation displays `host' information
 ;;  in the namestring only when the host is not the local host.
 ;;  It uses a double colon to separate a host name from the host's local
 ;;  file name.
 (make-pathname :directory '(:absolute "PUBLIC" "GAMES")
                :name "CHESS" :type "DB")
→ #P"SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
 (make-pathname :host "BOBBY"
                :directory '(:absolute "PUBLIC" "GAMES")
                :name "CHESS" :type "DB")
→ #P"BOBBY::SYS$DISK:[PUBLIC.GAMES]CHESS.DB"


 ;; Implementation C -- an implementation with simultaneous access to
 ;;  multiple file systems from the same Lisp image.  In this
 ;;  implementation, there is a convention that any text preceding the
 ;;  first colon in a pathname namestring is a host name.
 (dolist (case '(:common :local))
   (dolist (host '("MY-LISPM" "MY-VAX" "MY-UNIX"))
     (print (make-pathname :host host :case case
                           :directory '(:absolute "PUBLIC" "GAMES")
                           :name "CHESS" :type "DB"))))
▷ #P"MY-LISPM:>public>games>chess.db"
▷ #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
▷ #P"MY-UNIX:/public/games/chess.db"
▷ #P"MY-LISPM:>public>games>chess.db"
▷ #P"MY-VAX:SYS$DISK:[PUBLIC.GAMES]CHESS.DB"
▷ #P"MY-UNIX:/PUBLIC/GAMES/CHESS.DB"
→ NIL

Affected By:
............

The file system.

See Also:
.........

*note merge-pathnames::, *note pathname (System Class)::, *note
logical-pathname (System Class)::, *note Section 20.1 (File System
Concepts): File System Concepts, *note Section 19.1.2 (Pathnames as
Filenames): Pathnames as Filenames.

Notes:
......

Portable programs should not supply :unspecific for any component.  See
*note Section 19.2.2.2.3 (.UNSPECIFIC as a Component Value):
UnspecificComponent.


File: ansicl,  Node: pathnamep,  Next: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Prev: make-pathname,  Up: Filenames

pathnamep (Function)
====================

Syntax:
.......

 -- Function: pathnamep object → generalized-boolean

Arguments and Values:
.....................

OBJECT--an object.

GENERALIZED-BOOLEAN--a generalized boolean.

Description:
............

Returns true if OBJECT is of type ‘pathname’; otherwise, returns false.

Examples:
.........

 (setq q "test")  → "test"
 (pathnamep q) → false
 (setq q (pathname "test"))
→ #S(PATHNAME :HOST NIL :DEVICE NIL :DIRECTORY NIL :NAME "test" :TYPE NIL
       :VERSION NIL)
 (pathnamep q) → true
 (setq q (logical-pathname "SYS:SITE;FOO.SYSTEM"))
→ #P"SYS:SITE;FOO.SYSTEM"
 (pathnamep q) → true

Notes:
......

 (pathnamep OBJECT) ≡ (typep OBJECT 'pathname)


File: ansicl,  Node: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Next: load-logical-pathname-translations,  Prev: pathnamep,  Up: Filenames

pathname-host, pathname-device, pathname-directory, pathname-name, pathname-type, pathname-version (Function)
=============================================================================================================

Syntax:
.......

 -- Function: pathname-host pathname &key case → host

 -- Function: pathname-device pathname &key case → device

 -- Function: pathname-directory pathname &key case → directory

 -- Function: pathname-name pathname &key case → name

 -- Function: pathname-type pathname &key case → type

 -- Function: pathname-version pathname → version

Arguments and Values:
.....................

PATHNAME--a pathname designator.

CASE--one of :local or :common.  The default is :local.

HOST--a valid pathname host.

DEVICE--a valid pathname device.

DIRECTORY--a valid pathname directory.

NAME--a valid pathname name.

TYPE--a valid pathname type.

VERSION--a valid pathname version.

Description:
............

These functions return the components of PATHNAME.

If the PATHNAME designator is a pathname, it represents the name used
to open the file. This may be, but is not required to be, the actual
name of the file.

If CASE is supplied, it is treated as described in *note Section
19.2.2.1.2 (Case in Pathname Components): PathnameComponentCase.

Examples:
.........

 (setq q (make-pathname :host "KATHY"
                        :directory "CHAPMAN"
                        :name "LOGIN" :type "COM"))
→ #P"KATHY::[CHAPMAN]LOGIN.COM"
 (pathname-host q) → "KATHY"
 (pathname-name q) → "LOGIN"
 (pathname-type q) → "COM"

 ;; Because namestrings are used, the results shown in the remaining
 ;; examples are not necessarily the only possible results.  Mappings
 ;; from namestring representation to pathname representation are
 ;; dependent both on the file system involved and on the implementation
 ;; (since there may be several implementations which can manipulate the
 ;; the same file system, and those implementations are not constrained
 ;; to agree on all details). Consult the documentation for each
 ;; implementation for specific information on how namestrings are treated
 ;; that implementation.

 ;; VMS
 (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP"))
→ (:ABSOLUTE "FOO" "BAR")
 (pathname-directory (parse-namestring "[FOO.*.BAR]BAZ.LSP") :case :common)
→ (:ABSOLUTE "FOO" "BAR")

 ;; Unix
 (pathname-directory "foo.l") → NIL
 (pathname-device "foo.l") → :UNSPECIFIC
 (pathname-name "foo.l") → "foo"
 (pathname-name "foo.l" :case :local) → "foo"
 (pathname-name "foo.l" :case :common) → "FOO"
 (pathname-type "foo.l") → "l"
 (pathname-type "foo.l" :case :local) → "l"
 (pathname-type "foo.l" :case :common) → "L"
 (pathname-type "foo") → :UNSPECIFIC
 (pathname-type "foo" :case :common) → :UNSPECIFIC
 (pathname-type "foo.") → ""
 (pathname-type "foo." :case :common) → ""
 (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
→ (:ABSOLUTE "foo" "bar")
 (pathname-directory (parse-namestring "/foo/bar/baz.lisp") :case :local)
→ (:ABSOLUTE "FOO" "BAR")
 (pathname-directory (parse-namestring "../baz.lisp"))
→ (:RELATIVE :UP)
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz"))
→ (:ABSOLUTE "foo" "BAR" :UP "Mum")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/BAR/../Mum/baz") :case :common)
→ (:ABSOLUTE "FOO" "bar" :UP "Mum")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l"))
→ (:ABSOLUTE "foo" :WILD "bar")
 (PATHNAME-DIRECTORY (PARSE-NAMESTRING "/foo/*/bar/baz.l") :case :common)
→ (:ABSOLUTE "FOO" :WILD "BAR")

 ;; Symbolics LMFS
 (pathname-directory (parse-namestring ">foo>**>bar>baz.lisp"))
→ (:ABSOLUTE "foo" :WILD-INFERIORS "bar")
 (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp"))
→ (:ABSOLUTE "foo" :WILD "bar")
 (pathname-directory (parse-namestring ">foo>*>bar>baz.lisp") :case :common)
→ (:ABSOLUTE "FOO" :WILD "BAR")
 (pathname-device (parse-namestring ">foo>baz.lisp")) → :UNSPECIFIC

Affected By:
............

The implementation and the host file system.

Exceptional Situations:
.......................

Should signal an error of type ‘type-error’ if its first argument is
not a pathname.

See Also:
.........

*note pathname (System Class)::, *note logical-pathname (System
Class)::, *note Section 20.1 (File System Concepts): File System
Concepts, *note Section 19.1.2 (Pathnames as Filenames): Pathnames as
Filenames.


File: ansicl,  Node: load-logical-pathname-translations,  Next: logical-pathname-translations,  Prev: pathname-host; pathname-device; pathname-directory; pathname-name; path+,  Up: Filenames

load-logical-pathname-translations (Function)
=============================================

Syntax:
.......

 -- Function: load-logical-pathname-translations host → just-loaded

Arguments and Values:
.....................

HOST--a string.

just-loaded--a generalized boolean.

Description:
............

Searches for and loads the definition of a logical host named HOST, if
it is not already defined.  The specific nature of the search is
implementation-defined.

If the HOST is already defined, no attempt to find or load a definition
is attempted, and false is returned.  If the HOST is not already
defined, but a definition is successfully found and loaded, true is
returned.  Otherwise, an error is signaled.

Examples:
.........

 (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
▷ Error: The logical host HACKS is not defined.
 (load-logical-pathname-translations "HACKS")
▷ ;; Loading SYS:SITE;HACKS.TRANSLATIONS
▷ ;; Loading done.
→ true
 (translate-logical-pathname "hacks:weather;barometer.lisp.newest")
→ #P"HELIUM:[SHARED.HACKS.WEATHER]BAROMETER.LSP;0"
 (load-logical-pathname-translations "HACKS")
→ false

Exceptional Situations:
.......................

If no definition is found, an error of type ‘error’ is signaled.

See Also:
.........

*note logical-pathname (System Class)::

Notes:
......

Logical pathname definitions will be created not just by implementors
but also by programmers.  As such, it is important that the search
strategy be documented.  For example, an implementation might define
that the definition of a HOST is to be found in a file called
"HOST.translations" in some specifically named directory.


File: ansicl,  Node: logical-pathname-translations,  Next: logical-pathname (Function),  Prev: load-logical-pathname-translations,  Up: Filenames

logical-pathname-translations (Accessor)
========================================

Syntax:
.......

 -- Function: logical-pathname-translations host → translations

(setf (logical-pathname-translations host) new-translations)

Arguments and Values:
.....................

HOST--a logical host designator.

TRANSLATIONS, NEW-TRANSLATIONS--a list.

Description:
............

Returns the host's list of translations.  Each translation is a list of
at least two elements: from-wildcard and to-wildcard.  Any additional
elements are implementation-defined.  From-wildcard is a logical
pathname whose host is HOST.  To-wildcard is a pathname.

‘(setf (logical-pathname-translations HOST) translations)’ sets a
logical pathname host's list of translations.  If HOST is a string that
has not been previously used as a logical pathname host, a new logical
pathname host is defined; otherwise an existing host's translations are
replaced.  logical pathname host names are compared with ‘string-equal’.

When setting the translations list, each from-wildcard can be a logical
pathname whose host is HOST or a logical pathname namestring parseable
by ‘(parse-namestring string host)’, where host represents the
appropriate object as defined by ‘parse-namestring’. Each to-wildcard
can be anything coercible to a pathname by ‘(pathname to-wildcard)’.
If to-wildcard coerces to a logical pathname,
‘translate-logical-pathname’ will perform repeated translation steps
when it uses it.

HOST is either the host component of a logical pathname or a string
that has been defined as a logical pathname host name by ‘setf’ of
‘logical-pathname-translations’.

Examples:
.........

 ;;;A very simple example of setting up a logical pathname host.  No
 ;;;translations are necessary to get around file system restrictions, so
 ;;;all that is necessary is to specify the root of the physical directory
 ;;;tree that contains the logical file system.
 ;;;The namestring syntax on the right-hand side is implementation-dependent.
 (setf (logical-pathname-translations "foo")
       '(("**;*.*.*"              "MY-LISPM:>library>foo>**>")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "foo:bar;baz;mum.quux.3")
→ #P"MY-LISPM:>library>foo>bar>baz>mum.quux.3"


 ;;;A more complex example, dividing the files among two file servers
 ;;;and several different directories.  This Unix doesn't support
 ;;;:WILD-INFERIORS in the directory, so each directory level must
 ;;;be translated individually.  No file name or type translations
 ;;;are required except for .MAIL to .MBX.
 ;;;The namestring syntax on the right-hand side is implementation-dependent.
 (setf (logical-pathname-translations "prog")
       '(("RELEASED;*.*.*"        "MY-UNIX:/sys/bin/my-prog/")
         ("RELEASED;*;*.*.*"      "MY-UNIX:/sys/bin/my-prog/*/")
         ("EXPERIMENTAL;*.*.*"    "MY-UNIX:/usr/Joe/development/prog/")
         ("EXPERIMENTAL;DOCUMENTATION;*.*.*"
                                  "MY-VAX:SYS$DISK:[JOE.DOC]")
         ("EXPERIMENTAL;*;*.*.*"  "MY-UNIX:/usr/Joe/development/prog/*/")
         ("MAIL;**;*.MAIL"        "MY-VAX:SYS$DISK:[JOE.MAIL.PROG...]*.MBX")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:mail;save;ideas.mail.3")
→ #P"MY-VAX:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3"


 ;;;Example translations for a program that uses three files main.lisp,
 ;;;auxiliary.lisp, and documentation.lisp.  These translations might be
 ;;;supplied by a software supplier as examples.

 ;;;For Unix with long file names
 (setf (logical-pathname-translations "prog")
       '(("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
→ #P"/lib/prog/documentation.lisp"

 ;;;For Unix with 14-character file names, using .lisp as the type
 (setf (logical-pathname-translations "prog")
       '(("CODE;DOCUMENTATION.*.*" "/lib/prog/docum.*")
         ("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
→ #P"/lib/prog/docum.lisp"


 ;;;For Unix with 14-character file names, using .l as the type
 ;;;The second translation shortens the compiled file type to .b
 (setf (logical-pathname-translations "prog")
       `(("**;*.LISP.*"            ,(logical-pathname "PROG:**;*.L.*"))
         (,(compile-file-pathname (logical-pathname "PROG:**;*.LISP.*"))
                                   ,(logical-pathname "PROG:**;*.B.*"))
         ("CODE;DOCUMENTATION.*.*" "/lib/prog/documentatio.*")
         ("CODE;*.*.*"             "/lib/prog/")))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
→ #P"/lib/prog/documentatio.l"


 ;;;For a Cray with 6 character names and no directories, types, or versions.
 (setf (logical-pathname-translations "prog")
       (let ((l '(("MAIN" "PGMN")
                  ("AUXILIARY" "PGAUX")
                  ("DOCUMENTATION" "PGDOC")))
             (logpath (logical-pathname "prog:code;"))
             (phypath (pathname "XXX")))
         (append
           ;; Translations for source files
           (mapcar #'(lambda (x)
                       (let ((log (first x))
                             (phy (second x)))
                         (list (make-pathname :name log
                                              :type "LISP"
                                              :version :wild
                                              :defaults logpath)
                               (make-pathname :name phy
                                              :defaults phypath))))
                   l)
           ;; Translations for compiled files
           (mapcar #'(lambda (x)
                       (let* ((log (first x))
                              (phy (second x))
                              (com (compile-file-pathname
                                     (make-pathname :name log
                                                    :type "LISP"
                                                    :version :wild
                                                    :defaults logpath))))
                         (setq phy (concatenate 'string phy "B"))
                         (list com
                               (make-pathname :name phy
                                              :defaults phypath))))
                   l))))

 ;;;Sample use of that logical pathname.  The return value
 ;;;is implementation-dependent.
 (translate-logical-pathname "prog:code;documentation.lisp")
→ #P"PGDOC"

Exceptional Situations:
.......................

If HOST is incorrectly supplied, an error of type ‘type-error’ is
signaled.

See Also:
.........

*note logical-pathname (System Class)::, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.

Notes:
......

Implementations can define additional functions that operate on logical
pathname hosts, for example to specify additional translation rules or
options.


File: ansicl,  Node: logical-pathname (Function),  Next: *default-pathname-defaults*,  Prev: logical-pathname-translations,  Up: Filenames

logical-pathname (Function)
===========================

Syntax:
.......

 -- Function: logical-pathname pathspec → logical-pathname

Arguments and Values:
.....................

PATHSPEC--a logical pathname, a logical pathname namestring, or a
stream.

LOGICAL-PATHNAME--a logical pathname.

Description:
............

‘logical-pathname’ converts PATHSPEC to a logical pathname and returns
the new logical pathname.  If PATHSPEC is a logical pathname namestring,
it should contain a host component and its following colon.  If
PATHSPEC is a stream, it should be one for which ‘pathname’ returns a
logical pathname.

If PATHSPEC is a stream, the stream can be either open or closed.
‘logical-pathname’ returns the same logical pathname after a file is
closed as it did when the file was open.  It is an error if PATHSPEC is
a stream that is created with ‘make-two-way-stream’, ‘make-echo-stream’,
‘make-broadcast-stream’, ‘make-concatenated-stream’,
‘make-string-input-stream’, or ‘make-string-output-stream’.

Exceptional Situations:
.......................

Signals an error of type ‘type-error’ if PATHSPEC isn't supplied
correctly.

See Also:
.........

*note logical-pathname (System Class)::, *note
translate-logical-pathname::, *note Section 19.3 (Logical Pathnames):
Logical Pathnames.


File: ansicl,  Node: *default-pathname-defaults*,  Next: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Prev: logical-pathname (Function),  Up: Filenames

*default-pathname-defaults* (Variable)
======================================

Value Type:
...........

a pathname object.

Initial Value:
..............

An implementation-dependent pathname, typically in the working
directory that was current when Common Lisp was started up.

Description:
............

a pathname, used as the default whenever a function needs a default
pathname and one is not supplied.

Examples:
.........

 ;; This example illustrates a possible usage for a hypothetical Lisp running on a
 ;; DEC TOPS-20 file system.  Since pathname conventions vary between Lisp
 ;; implementations and host file system types, it is not possible to provide a
 ;; general-purpose, conforming example.
 *default-pathname-defaults* → #P"PS:<FRED>"
 (merge-pathnames (make-pathname :name "CALENDAR"))
→ #P"PS:<FRED>CALENDAR"
 (let ((*default-pathname-defaults* (pathname "<MARY>")))
   (merge-pathnames (make-pathname :name "CALENDAR")))
→ #P"<MARY>CALENDAR"

Affected By:
............

The implementation.


File: ansicl,  Node: namestring; file-namestring; directory-namestring; host-namestring; eno+,  Next: parse-namestring,  Prev: *default-pathname-defaults*,  Up: Filenames

namestring, file-namestring, directory-namestring, host-namestring, enough-namestring (Function)
================================================================================================

Syntax:
.......

 -- Function: namestring pathname → namestring

 -- Function: file-namestring pathname → namestring

 -- Function: directory-namestring pathname → namestring

 -- Function: host-namestring pathname → namestring

 -- Function: enough-namestring pathname &optional defaults → namestring

Arguments and Values:
.....................

PATHNAME--a pathname designator.

DEFAULTS--a pathname designator.  The default is the value of
‘*default-pathname-defaults*’.

NAMESTRING--a string or ‘nil’.

Description:
............

These functions convert PATHNAME into a namestring.  The name
represented by PATHNAME is returned as a namestring in an
implementation-dependent canonical form.

‘namestring’ returns the full form of PATHNAME.

‘file-namestring’ returns just the name, type, and version components
of PATHNAME.

‘directory-namestring’ returns the directory name portion.

‘host-namestring’ returns the host name.

‘enough-namestring’ returns an abbreviated namestring that is just
sufficient to identify the file named by PATHNAME when considered
relative to the DEFAULTS.  It is required that

 (merge-pathnames (enough-namestring pathname defaults) defaults)
≡ (merge-pathnames (parse-namestring pathname nil defaults) defaults)

in all cases, and the result of ‘enough-namestring’ is the shortest
reasonable string that will satisfy this criterion.

It is not necessarily possible to construct a valid namestring by
concatenating some of the three shorter namestrings in some order.

Examples:
.........

 (namestring "getty")
→ "getty"
 (setq q (make-pathname :host "kathy"
                         :directory
                           (pathname-directory *default-pathname-defaults*)
                         :name "getty"))
→ #S(PATHNAME :HOST "kathy" :DEVICE NIL :DIRECTORY directory-name
       :NAME "getty" :TYPE NIL :VERSION NIL)
 (file-namestring q) → "getty"
 (directory-namestring q) → directory-name
 (host-namestring q) → "kathy"

 ;;;Using Unix syntax and the wildcard conventions used by the
 ;;;particular version of Unix on which this example was created:
 (namestring
   (translate-pathname "/usr/dmr/hacks/frob.l"
                       "/usr/d*/hacks/*.l"
                       "/usr/d*/backup/hacks/backup-*.*"))
→ "/usr/dmr/backup/hacks/backup-frob.l"
 (namestring
   (translate-pathname "/usr/dmr/hacks/frob.l"
                       "/usr/d*/hacks/fr*.l"
                       "/usr/d*/backup/hacks/backup-*.*"))
→ "/usr/dmr/backup/hacks/backup-ob.l"

 ;;;This is similar to the above example but uses two different hosts,
 ;;;U: which is a Unix and V: which is a VMS.  Note the translation
 ;;;of file type and alphabetic case conventions.
 (namestring
   (translate-pathname "U:/usr/dmr/hacks/frob.l"
                       "U:/usr/d*/hacks/*.l"
                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
→ "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP"
 (namestring
   (translate-pathname "U:/usr/dmr/hacks/frob.l"
                       "U:/usr/d*/hacks/fr*.l"
                       "V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*"))
→ "V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP"

See Also:
.........

*note truename::, *note merge-pathnames::, *note pathname (System
Class)::, *note logical-pathname (System Class)::, *note Section 20.1
(File System Concepts): File System Concepts, *note Section 19.1.2
(Pathnames as Filenames): Pathnames as Filenames.



Local Variables:
coding: utf-8
End:
